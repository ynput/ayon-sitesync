var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Site Sync Addon","text":""},{"location":"index.html#deployment","title":"Deployment:","text":"<p>Content of addon repo must be prepared for proper deployment to the server. Currently it is a manual process consisting of steps: (requirements: at least Python3.9, yarn installed) - clone repo to local machine - run <code>python create_package.py</code> - this will produce <code>package</code> folder in root of cloned repo - install <code>.zip</code> file from <code>package</code> folder via Ayon Server UI (<code>Studio Settings &gt; Bundles &gt; Install Addons</code>)</p> <p>Addon allowing synchronization of published elements between remote and local locations. Implements couple of different protocols (local drive, GDrive API, Dropbox API etc.)</p> <p>Server side should allow reporting of status of presence of published elements on  various sites (eg. studio, specific artist site, GDrive). It should also allow marking each published file(s) to be synched to specific location eventually.</p> <p>Client side runs webserver on artist (or studio) machine which does real synching.</p>"},{"location":"index.html#server-side-debugging","title":"Server side debugging:","text":"<p>To debug server side, eg endpoints returning values from DB is best to update directly files in <code>ayon-docer/addons/sitesync/X.Y.Z</code>. The server must be restarted (via UI) to changes to be taken in.</p> <p>Front end could be debugged by:</p> <pre><code>cd frontend\nyarn dev\n</code></pre> <p>This will create standalone front end containing only page meant for SiteSync. (Installed <code>yarn</code> is required.) (Click on a link in <code>Local:</code> line that should show up after <code>yarn dev</code> command)</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_sitesync<ul> <li>addon</li> <li>launch_hooks<ul> <li>pre_copy_last_published_workfile</li> </ul> </li> <li>plugins<ul> <li>publish<ul> <li>integrate_site_sync</li> </ul> </li> </ul> </li> <li>providers<ul> <li>abstract_provider</li> <li>dropbox</li> <li>gdrive</li> <li>lib</li> <li>local_drive</li> <li>sftp</li> </ul> </li> <li>sitesync</li> <li>utils</li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>models</li> <li>providers<ul> <li>dropbox</li> <li>gdrive</li> <li>local_drive</li> <li>sftp</li> </ul> </li> <li>settings</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_sitesync/index.html","title":"ayon_sitesync","text":""},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon","title":"<code>SiteSyncAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>ITrayAddon</code>, <code>IPluginPaths</code></p> <p>Addon handling sync of representation files between sites.</p> <p>Synchronization server that is syncing published files from local to any of implemented providers (like GDrive, S3 etc.) Runs in the background and checks all representations, looks for files that are marked to be in different location than 'studio' (temporary), checks if 'created_dt' field is present denoting successful sync with provider destination. Sites structure is created during publish OR by calling 'add_site' method.</p> <p>State of synchronization is being persisted on the server in <code>sitesync_files_status</code> table.</p> <p>By default it will always contain 1 record with \"name\" ==  self.presets[\"active_site\"] per representation_id with state of all its files</p> <p>Each Tray app has assigned its own  self.presets[\"local_id\"] used in sites as a name. Tray is searching only for records where name matches its self.presets[\"active_site\"] + self.presets[\"remote_site\"]. \"active_site\" could be storage in studio ('studio'), or specific \"local_id\" when user is working disconnected from home. If the local record has its \"created_dt\" filled, it is a source and process will try to upload the file to all defined remote sites.</p> <p>Remote files \"id\" is real id that could be used in appropriate API. Local files have \"id\" too, for conformity, contains just file name. It is expected that multiple providers will be implemented in separate classes and registered in 'providers.py'.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>class SiteSyncAddon(AYONAddon, ITrayAddon, IPluginPaths):\n    \"\"\"Addon handling sync of representation files between sites.\n\n    Synchronization server that is syncing published files from local to\n    any of implemented providers (like GDrive, S3 etc.)\n    Runs in the background and checks all representations, looks for files\n    that are marked to be in different location than 'studio' (temporary),\n    checks if 'created_dt' field is present denoting successful sync\n    with provider destination.\n    Sites structure is created during publish OR by calling 'add_site'\n    method.\n\n    State of synchronization is being persisted on the server\n    in `sitesync_files_status` table.\n\n    By default it will always contain 1 record with\n    \"name\" ==  self.presets[\"active_site\"] per representation_id with state\n    of all its files\n\n    Each Tray app has assigned its own  self.presets[\"local_id\"]\n    used in sites as a name.\n    Tray is searching only for records where name matches its\n    self.presets[\"active_site\"] + self.presets[\"remote_site\"].\n    \"active_site\" could be storage in studio ('studio'), or specific\n    \"local_id\" when user is working disconnected from home.\n    If the local record has its \"created_dt\" filled, it is a source and\n    process will try to upload the file to all defined remote sites.\n\n    Remote files \"id\" is real id that could be used in appropriate API.\n    Local files have \"id\" too, for conformity, contains just file name.\n    It is expected that multiple providers will be implemented in separate\n    classes and registered in 'providers.py'.\n\n    \"\"\"\n    # limit querying DB to look for X number of representations that should\n    # be sync, we try to run more loops with less records\n    # actual number of files synced could be lower as providers can have\n    # different limits imposed by its API\n    # set 0 to no limit\n    REPRESENTATION_LIMIT = 100\n    DEFAULT_SITE = \"studio\"\n    LOCAL_SITE = \"local\"\n    LOG_PROGRESS_SEC = 5  # how often log progress to DB\n    DEFAULT_PRIORITY = 50  # higher is better, allowed range 1 - 1000\n\n    name = \"sitesync\"\n    version = __version__\n\n    def initialize(self, addon_settings):\n        \"\"\"Called during Addon Manager creation.\n\n        Collects needed data, checks asyncio presence.\n        Sets 'enabled' according to global settings for the addon.\n        Shouldn't be doing any initialization, that's a job for 'tray_init'\n        \"\"\"\n\n        # some parts of code need to run sequentially, not in async\n        self.lock = None\n        self._sync_studio_settings = None\n        # settings for all enabled projects for sync\n        self._sync_project_settings = None\n        self.sitesync_thread = None  # asyncio requires new thread\n\n        self._paused = False\n        self._paused_projects = set()\n        self._paused_representations = set()\n        self._anatomies = {}\n\n        # list of long blocking tasks\n        self.long_running_tasks = deque()\n        # projects that long tasks are running on\n        self.projects_processed = set()\n\n    @property\n    def endpoint_prefix(self):\n        return \"addons/{}/{}\".format(self.name, self.version)\n\n    def get_plugin_paths(self):\n        return {\n            \"publish\": os.path.join(SYNC_ADDON_DIR, \"plugins\", \"publish\")\n        }\n\n    def get_site_icons(self):\n        \"\"\"Icons for sites.\n\n        Returns:\n            dict[str, str]: Path to icon by site.\n\n        \"\"\"\n        resource_path = os.path.join(\n            SYNC_ADDON_DIR, \"providers\", \"resources\"\n        )\n        icons = {}\n        for file_path in os.listdir(resource_path):\n            if not file_path.endswith(\".png\"):\n                continue\n            provider_name, _ = os.path.splitext(os.path.basename(file_path))\n            icons[provider_name] = {\n                \"type\": \"path\",\n                \"path\": os.path.join(resource_path, file_path)\n            }\n        return icons\n\n    def get_launch_hook_paths(self):\n        \"\"\"Implementation for applications launch hooks.\n\n        Returns:\n            str: full absolut path to directory with hooks for the addon\n\n        \"\"\"\n        return os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"launch_hooks\"\n        )\n\n    # --- Public API ---\n    def add_site(\n        self,\n        project_name,\n        representation_id,\n        site_name=None,\n        file_id=None,\n        force=False,\n        status=SiteSyncStatus.QUEUED\n    ):\n        \"\"\"Adds new site to representation to be synced.\n\n        'project_name' must have synchronization enabled (globally or\n        project only)\n\n        Used as a API endpoint from outside applications (Loader etc).\n\n        Use 'force' to reset existing site.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): Site name of configured site.\n            file_id (str): File id.\n            force (bool): Reset site if exists.\n            status (SiteSyncStatus): Current status,\n                default SiteSyncStatus.QUEUED\n\n        Raises:\n            SiteAlreadyPresentError: If adding already existing site and\n                not 'force'\n            ValueError: other errors (repre not found, misconfiguration)\n\n        \"\"\"\n        if not self.get_sync_project_setting(project_name):\n            raise ValueError(\"Project not configured\")\n\n        if not site_name:\n            site_name = self.DEFAULT_SITE\n\n        representation = get_representation_by_id(\n            project_name, representation_id\n        )\n\n        files = representation.get(\"files\", [])\n        if not files:\n            self.log.debug(\"No files for {}\".format(representation_id))\n            return\n\n        if not force:\n            existing = self.get_repre_sync_state(\n                project_name,\n                representation_id,\n                site_name\n            )\n            if existing:\n                failure = True\n                if file_id:\n                    file_exists = existing.get(\"files\", {}).get(file_id)\n                    if not file_exists:\n                        failure = False\n\n                if failure:\n                    msg = \"Site {} already present\".format(site_name)\n                    self.log.info(msg)\n                    raise SiteAlreadyPresentError(msg)\n\n        new_site_files = [\n            {\n                \"size\": repre_file[\"size\"],\n                \"status\": status,\n                \"timestamp\": datetime.now().timestamp(),\n                \"id\": repre_file[\"id\"],\n                \"fileHash\": repre_file[\"hash\"]\n            }\n            for repre_file in files\n        ]\n\n        payload_dict = {\"files\": new_site_files}\n        representation_id = representation_id.replace(\"-\", \"\")\n\n        self._set_state_sync_state(\n            project_name, representation_id, site_name, payload_dict\n        )\n\n    def remove_site(\n        self,\n        project_name,\n        representation_id,\n        site_name,\n        remove_local_files=False\n    ):\n        \"\"\"Removes site for particular representation in project.\n\n        Args:\n            project_name (str): project name (must match DB)\n            representation_id (str): MongoDB _id value\n            site_name (str): name of configured and active site\n            remove_local_files (bool): remove only files for 'local_id'\n                site\n\n        Raises:\n            ValueError: Throws if any issue.\n\n        \"\"\"\n        if not self.get_sync_project_setting(project_name):\n            raise ValueError(\"Project not configured\")\n\n        sync_info = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            site_name\n        )\n        if not sync_info:\n            msg = \"Site {} not found\".format(site_name)\n            self.log.warning(msg)\n            return\n\n        endpoint = \"{}/{}/state/{}/{}\".format(\n            self.endpoint_prefix,\n            project_name,\n            representation_id,\n            site_name\n        )\n\n        response = ayon_api.delete(endpoint)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\"Cannot update status\")\n\n        if remove_local_files:\n            self._remove_local_file(project_name, representation_id, site_name)\n\n    def compute_resource_sync_sites(self, project_name):\n        \"\"\"Get available resource sync sites state for publish process.\n\n        Returns dict with prepared state of sync sites for 'project_name'.\n        It checks if Site Sync is enabled, handles alternative sites.\n        Publish process stores this dictionary as a part of representation\n        document in DB.\n\n        Example:\n        [\n            {\n                'name': '42abbc09-d62a-44a4-815c-a12cd679d2d7',\n                'status': SiteSyncStatus.OK\n            },\n            {'name': 'studio', 'status': SiteSyncStatus.QUEUED},\n            {'name': 'SFTP', 'status': SiteSyncStatus.QUEUED}\n        ] -- representation is published locally, artist or Settings have set\n        remote site as 'studio'. 'SFTP' is alternate site to 'studio'. Eg.\n        whenever file is on 'studio', it is also on 'SFTP'.\n        \"\"\"\n\n        def create_metadata(name, created=True):\n            \"\"\"Create sync site metadata for site with `name`\"\"\"\n            if created:\n                status = SiteSyncStatus.OK\n            else:\n                status = SiteSyncStatus.QUEUED\n            return {\"name\": name, \"status\": status}\n\n        if (\n            not self.sync_studio_settings[\"enabled\"]\n            or not self.sync_project_settings[project_name][\"enabled\"]\n        ):\n            return [create_metadata(self.DEFAULT_SITE)]\n\n        local_site = self.get_active_site(project_name)\n        remote_site = self.get_remote_site(project_name)\n\n        # Attached sites metadata by site name\n        # That is the local site, remote site, the always accesible sites\n        # and their alternate sites (alias of sites with different protocol)\n        attached_sites = {\n            local_site: create_metadata(local_site)\n        }\n        if remote_site and remote_site not in attached_sites:\n            attached_sites[remote_site] = create_metadata(\n                remote_site, created=False\n            )\n\n        attached_sites = self._add_alternative_sites(\n            project_name, attached_sites)\n        # add skeleton for sites where it should be always synced to\n        # usually it would be a backup site which is handled by separate\n        # background process\n        for site_name in self._get_always_accessible_sites(project_name):\n            if site_name not in attached_sites:\n                attached_sites[site_name] = (\n                    create_metadata(site_name, created=False))\n        unique_sites = {\n            site[\"name\"]: site\n            for site in attached_sites.values()\n        }\n        return list(unique_sites.values())\n\n    def _get_always_accessible_sites(self, project_name):\n        \"\"\"Sites that synced to as a part of background process.\n\n        Artist machine doesn't handle those, explicit Tray with that site name\n        as a local id must be running.\n        Example is dropbox site serving as a backup solution\n\n        Returns:\n            (list[str]): list of site names\n        \"\"\"\n        sync_settings = self.get_sync_project_setting(project_name)\n        always_accessible_sites = (\n            sync_settings[\"config\"].get(\"always_accessible_on\", [])\n        )\n        return [site_name.strip() for site_name in always_accessible_sites]\n\n    def _add_alternative_sites(self, project_name, attached_sites):\n        \"\"\"Add skeleton document for alternative sites\n\n        Each new configured site in System Setting could serve as a alternative\n        site, it's a kind of alias. It means that files on 'a site' are\n        physically accessible also on 'a alternative' site.\n        Example is sftp site serving studio files via sftp protocol, physically\n        file is only in studio, sftp server has this location mounted.\n\n        Returns:\n            (dict[str, dict])\n        \"\"\"\n        sync_project_settings = self.get_sync_project_setting(project_name)\n        all_sites = sync_project_settings[\"sites\"]\n\n        alt_site_pairs = self._get_alt_site_pairs(all_sites)\n\n        for site_name in all_sites.keys():\n            # Get alternate sites (stripped names) for this site name\n            alt_sites = {\n                site.strip()\n                for site in alt_site_pairs.get(site_name)\n            }\n\n            # If no alternative sites we don't need to add\n            if not alt_sites:\n                continue\n\n            # Take a copy of data of the first alternate site that is already\n            # defined as an attached site to match the same state.\n            match_meta = next(\n                (\n                    attached_sites[site]\n                    for site in alt_sites\n                    if site in attached_sites\n                ),\n                None\n            )\n            if not match_meta:\n                continue\n\n            alt_site_meta = copy.deepcopy(match_meta)\n            alt_site_meta[\"name\"] = site_name\n\n            # Note: We change mutable `attached_site` dict in-place\n            attached_sites[site_name] = alt_site_meta\n\n        return attached_sites\n\n    def _get_alt_site_pairs(self, conf_sites):\n        \"\"\"Returns dict of site and its alternative sites.\n\n        If `site` has alternative site, it means that alt_site has 'site' as\n        alternative site\n\n        Args:\n            conf_sites (dict)\n\n        Returns:\n            dict[str, list[str]]: {'site': [alternative sites]...}\n\n        \"\"\"\n        alt_site_pairs = defaultdict(set)\n        for site_name, site_info in conf_sites.items():\n            alt_sites = set(site_info.get(\"alternative_sites\", []))\n            alt_site_pairs[site_name].update(alt_sites)\n\n            for alt_site in alt_sites:\n                alt_site_pairs[alt_site].add(site_name)\n\n        for site_name, alt_sites in alt_site_pairs.items():\n            sites_queue = deque(alt_sites)\n            while sites_queue:\n                alt_site = sites_queue.popleft()\n\n                # safety against wrong config\n                # {\"SFTP\": {\"alternative_site\": \"SFTP\"}\n                if alt_site == site_name or alt_site not in alt_site_pairs:\n                    continue\n\n                for alt_alt_site in alt_site_pairs[alt_site]:\n                    if (\n                        alt_alt_site != site_name\n                        and alt_alt_site not in alt_sites\n                    ):\n                        alt_sites.add(alt_alt_site)\n                        sites_queue.append(alt_alt_site)\n\n        return alt_site_pairs\n\n    def clear_project(self, project_name, site_name):\n        \"\"\"\n            Clear 'project_name' of 'site_name' and its local files\n\n            Works only on real local sites, not on 'studio'\n        \"\"\"\n\n        # TODO implement\n        self.log.warning(\"Method 'clear_project' is not implemented.\")\n\n        # query = {\n        #     \"type\": \"representation\",\n        #     \"files.sites.name\": site_name\n        # }\n        #\n        # # TODO currently not possible to replace with get_representations\n        # representations = list(\n        #     self.connection.database[project_name].find(query))\n        # if not representations:\n        #     self.log.debug(\"No repre found\")\n        #     return\n        #\n        # for repre in representations:\n        #     self.remove_site(project_name, repre.get(\"_id\"), site_name, True)\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def validate_project(self, project_name, site_name, reset_missing=False):\n        \"\"\"Validate 'project_name' of 'site_name' and its local files\n\n        If file present and not marked with a 'site_name' in DB, DB is\n        updated with site name and file modified date.\n\n        Args:\n            project_name (str): project name\n            site_name (str): active site name\n            reset_missing (bool): if True reset site in DB if missing\n                physically to be resynched\n        \"\"\"\n        self.log.debug(\"Validation of {} for {} started\".format(\n            project_name, site_name\n        ))\n        repre_entities = list(get_representations(project_name))\n        if not repre_entities:\n            self.log.debug(\"No repre found\")\n            return\n\n        sites_added = 0\n        sites_reset = 0\n        repre_ids = [repre[\"id\"] for repre in repre_entities]\n        repre_states = self.get_representations_sync_state(\n            project_name, repre_ids, site_name, site_name)\n\n        for repre_entity in repre_entities:\n            repre_id = repre_entity[\"id\"]\n            is_on_site = False\n            repre_state = repre_states.get(repre_id)\n            if repre_state:\n                is_on_site = repre_state[0] == SiteSyncStatus.OK\n            for repre_file in repre_entity.get(\"files\", []):\n                file_path = repre_file.get(\"path\", \"\")\n                local_file_path = self.get_local_file_path(\n                    project_name, site_name, file_path\n                )\n\n                file_exists = (\n                    local_file_path and os.path.exists(local_file_path)\n                )\n                if not is_on_site:\n                    if file_exists:\n                        self.log.debug(\n                            f\"Adding presence on site '{site_name}' for \"\n                            f\"'{repre_id}'\"\n                        )\n                        self.add_site(\n                            project_name,\n                            repre_id,\n                            site_name=site_name,\n                            file_id=repre_file[\"id\"],\n                            force=True,\n                            status=SiteSyncStatus.OK\n                        )\n                        sites_added += 1\n                else:\n                    if not file_exists and reset_missing:\n                        self.log.debug(\n                            \"Resetting site {} for {}\".format(\n                                site_name, repre_id\n                            ))\n                        self.reset_site_on_representation(\n                            project_name,\n                            repre_id,\n                            site_name=site_name,\n                            file_id=repre_file[\"_id\"]\n                        )\n                        sites_reset += 1\n\n        if sites_added % 100 == 0:\n            self.log.debug(\"Sites added {}\".format(sites_added))\n\n        self.log.debug(\"Validation of {} for {} ended\".format(\n            project_name, site_name\n        ))\n        self.log.info(\"Sites added {}, sites reset {}\".format(\n            sites_added, reset_missing\n        ))\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def pause_representation(\n        self, project_name, representation_id, site_name\n    ):\n        \"\"\"Pause sync of representation entity on site.\n\n        Sets 'representation_id' as paused, eg. no syncing should be\n            happening on it.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): Site name 'gdrive', 'studio' etc.\n\n        \"\"\"\n        self.log.info(\"Pausing SiteSync for {}\".format(representation_id))\n        self._paused_representations.add(representation_id)\n        repre_entity = get_representation_by_id(\n            project_name, representation_id\n        )\n        self.update_db(project_name, repre_entity, site_name, pause=True)\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def unpause_representation(\n        self, project_name, representation_id, site_name\n    ):\n        \"\"\"Unpause sync of representation entity on site.\n\n        Does not fail or warn if repre wasn't paused.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): Site name 'gdrive', 'studio' etc.\n        \"\"\"\n        self.log.info(\"Unpausing SiteSync for {}\".format(representation_id))\n        try:\n            self._paused_representations.remove(representation_id)\n        except KeyError:\n            pass\n        # self.paused_representations is not persistent\n        repre_entity = get_representation_by_id(\n            project_name, representation_id\n        )\n        self.update_db(project_name, repre_entity, site_name, pause=False)\n\n    def is_representation_paused(\n        self, representation_id, check_parents=False, project_name=None\n    ):\n        \"\"\"Is representation paused.\n\n        Args:\n            representation_id (str): Representation id.\n            check_parents (bool): Check if parent project or server itself\n                are not paused.\n            project_name (str): Project to check if paused.\n\n            if 'check_parents', 'project_name' should be set too\n\n        Returns:\n            bool: Is representation paused now.\n\n        \"\"\"\n        is_paused = representation_id in self._paused_representations\n        if check_parents and project_name:\n            is_paused = (\n                is_paused\n                or self.is_project_paused(project_name)\n                or self.is_paused()\n            )\n        return is_paused\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def pause_project(self, project_name):\n        \"\"\"Pause sync of whole project.\n\n        Args:\n            project_name (str): Project name.\n\n        \"\"\"\n        self.log.info(\"Pausing SiteSync for {}\".format(project_name))\n        self._paused_projects.add(project_name)\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def unpause_project(self, project_name):\n        \"\"\"Unpause sync of whole project.\n\n        Does not fail or warn if project wasn't paused.\n\n        Args:\n            project_name (str): Project name.\n\n        \"\"\"\n        self.log.info(\"Unpausing SiteSync for {}\".format(project_name))\n        try:\n            self._paused_projects.remove(project_name)\n        except KeyError:\n            pass\n\n    def is_project_paused(self, project_name, check_parents=False):\n        \"\"\"Is project sync paused.\n\n        Args:\n            project_name (str):\n            check_parents (bool): check if server itself\n                is not paused\n\n        Returns:\n            bool: Is project paused.\n\n        \"\"\"\n        is_paused = project_name in self._paused_projects\n        if check_parents:\n            is_paused = is_paused or self.is_paused()\n        return is_paused\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def pause_server(self):\n        \"\"\"Pause sync server.\n\n        It won't check anything, not uploading/downloading...\n        \"\"\"\n        self.log.info(\"Pausing SiteSync\")\n        self._paused = True\n\n    def unpause_server(self):\n        \"\"\"Unpause server sync.\"\"\"\n        self.log.info(\"Unpausing SiteSync\")\n        self._paused = False\n\n    def is_paused(self):\n        \"\"\" Is server paused \"\"\"\n        return self._paused\n\n    def get_active_site_type(self, project_name, local_settings=None):\n        \"\"\"Active site which is defined by artist.\n\n        Unlike 'get_active_site' is this method also checking local settings\n        where might be different active site set by user. The output is limited\n        to \"studio\" and \"local\".\n\n        This method is used by Anatomy.\n\n        Todos:\n            Check if sync server is enabled for the project.\n            - To be able to do that the sync settings MUST NOT be cached for\n                all projects at once. The sync settings preparation for all\n                projects is reasonable only in sync server loop.\n            `local_settings` is probably obsolete in AYON\n\n        Args:\n            project_name (str): Name of project where to look for active site.\n            local_settings (Optional[dict[str, Any]]): Prepared local settings.\n\n        Returns:\n            Literal[\"studio\", \"local\"]: Active site.\n        \"\"\"\n        if not self.enabled:\n            return \"studio\"\n\n        sync_project_settings = self.get_sync_project_setting(project_name)\n\n        if not sync_project_settings[\"enabled\"]:\n            return \"studio\"\n\n        return (\n            sync_project_settings[\"local_setting\"].get(\"active_site\")\n            or sync_project_settings[\"config\"][\"active_site\"]\n        )\n\n    def get_active_site(self, project_name):\n        \"\"\"Returns active (mine) site for project from settings.\n\n        Output logic:\n            - 'studio' if Site Sync is disabled\n            - value from 'get_local_site_id' if active site is 'local'\n            - any other site name from local settings\n                or project settings (site could be forced from PS)\n\n        Returns:\n            str: Site name.\n\n        \"\"\"\n        active_site_type = self.get_active_site_type(project_name)\n        if active_site_type == self.LOCAL_SITE:\n            return get_local_site_id()\n        return active_site_type\n\n    # remote site\n    def get_remote_site(self, project_name):\n        \"\"\"Remote (theirs) site for project from settings.\"\"\"\n        sync_project_settings = self.get_sync_project_setting(project_name)\n        remote_site = (\n            sync_project_settings[\"local_setting\"].get(\"remote_site\")\n            or sync_project_settings[\"config\"][\"remote_site\"]\n        )\n        if remote_site == self.LOCAL_SITE:\n            return get_local_site_id()\n\n        return remote_site\n\n    def get_site_root_overrides(\n        self, project_name, site_name, local_settings=None\n    ):\n        \"\"\"Get root overrides for project on a site.\n\n        Implemented to be used in 'Anatomy' for other than 'studio' site.\n\n        Args:\n            project_name (str): Project for which root overrides should be\n                received.\n            site_name (str): Name of site for which should be received roots.\n            local_settings (Optional[dict[str, Any]]): Prepare local settigns\n                values.\n\n        Returns:\n            Union[dict[str, Any], None]: Root overrides for this machine.\n\n            {\"work\": \"c:/projects_local\"}\n        \"\"\"\n\n        # Validate that site name is valid\n        if site_name not in (\"studio\", \"local\"):\n            # Consider local site id as 'local'\n            if site_name != get_local_site_id():\n                raise ValueError((\n                    \"Root overrides are available only for\"\n                    \" default sites not for \\\"{}\\\"\"\n                ).format(site_name))\n            site_name = \"local\"\n\n        sitesync_settings = self.get_sync_project_setting(project_name)\n\n        roots = {}\n        if not sitesync_settings[\"enabled\"]:\n            return roots\n        local_project_settings = sitesync_settings[\"local_setting\"]\n        if site_name == \"local\":\n            for root_info in local_project_settings[\"local_roots\"]:\n                roots[root_info[\"name\"]] = root_info[\"path\"]\n\n        return roots\n\n    def get_local_normalized_site(self, site_name):\n        \"\"\"Normlize local site name.\n\n         Return 'local' if 'site_name' is local id.\n\n        In some places Settings or Local Settings require 'local' instead\n        of real site name.\n\n        Returns:\n            str: Normalized site name.\n\n        \"\"\"\n        if site_name == get_local_site_id():\n            site_name = self.LOCAL_SITE\n\n        return site_name\n\n    def is_representation_on_site(\n        self, project_name, representation_id, site_name, max_retries=None\n    ):\n        \"\"\"Check if representation has all files available on site.\n\n        Args:\n            project_name (str)\n            representation_id (str)\n            site_name (str)\n            max_retries (int) (optional) - provide only if method used in while\n                loop to bail out\n\n        Returns:\n            bool: True if representation has all files correctly on the site.\n\n        Raises:\n              ValueError  Only If 'max_retries' provided if upload/download\n                failed too many times to limit infinite loop check.\n\n        \"\"\"\n        representation_status = self.get_repre_sync_state(\n            project_name, representation_id, site_name)\n        if not representation_status:\n            return False\n\n        if site_name == get_local_site_id():\n            status = representation_status[\"localStatus\"]\n        else:\n            status = representation_status[\"remoteStatus\"]\n\n        if max_retries:\n            tries = status.get(\"retries\", 0)\n            if tries &gt;= max_retries:\n                raise ValueError(\"Failed too many times\")\n\n        return status[\"status\"] == SiteSyncStatus.OK\n\n    def _reset_timer_with_rest_api(self):\n        # POST to webserver sites to add to representations\n        webserver_url = os.environ.get(\"AYON_WEBSERVER_URL\")\n        if not webserver_url:\n            self.log.warning(\"Couldn't find webserver url\")\n            return\n\n        rest_api_url = \"{}/sitesync/reset_timer\".format(\n            webserver_url\n        )\n\n        try:\n            import requests\n        except Exception:\n            self.log.warning(\n                \"Couldn't add sites to representations \"\n                \"('requests' is not available)\"\n            )\n            return\n\n        requests.post(rest_api_url)\n\n    def get_enabled_projects(self):\n        \"\"\"Returns list of projects which have SiteSync enabled.\"\"\"\n        enabled_projects = []\n\n        if self.enabled:\n            for project_name in get_project_names():\n                if self.is_project_enabled(project_name):\n                    enabled_projects.append(project_name)\n\n        return enabled_projects\n\n    def is_project_enabled(self, project_name, single=False):\n        \"\"\"Checks if 'project_name' is enabled for syncing.\n        'get_sync_project_setting' is potentially expensive operation (pulls\n        settings for all projects if cached version is not available), using\n        project_settings for specific project should be faster.\n        Args:\n            project_name (str)\n            single (bool): use 'get_addon_project_settings' method\n        \"\"\"\n        if self.enabled:\n            if single:\n                project_settings = get_addon_project_settings(\n                    self.name, self.version, project_name\n                )\n            else:\n                project_settings = self.get_sync_project_setting(project_name)\n            if project_settings and project_settings.get(\"enabled\"):\n                return True\n        return False\n\n    def handle_alternate_site(\n        self, project_name, representation_id, processed_site, file_id\n    ):\n        \"\"\"\n        For special use cases where one site vendors another.\n\n        Current use case is sftp site vendoring (exposing) same data as\n        regular site (studio). Each site is accessible for different\n        audience. 'studio' for artists in a studio, 'sftp' for externals.\n\n        Change of file status on one site actually means same change on\n        'alternate' site. (eg. artists publish to 'studio', 'sftp' is using\n        same location &gt;&gt; file is accessible on 'sftp' site right away.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            processed_site (str): Real site_name of published/uploaded file\n            file_id (str): File id of file handled.\n\n        \"\"\"\n        sites = self._transform_sites_from_settings(self.sync_studio_settings)\n        sites[self.DEFAULT_SITE] = {\n            \"provider\": \"local_drive\",\n            \"alternative_sites\": []\n        }\n\n        alternate_sites = []\n        for site_name, site_info in sites.items():\n            conf_alternative_sites = site_info.get(\"alternative_sites\", [])\n            if processed_site in conf_alternative_sites:\n                alternate_sites.append(site_name)\n                continue\n            if processed_site == site_name and conf_alternative_sites:\n                alternate_sites.extend(conf_alternative_sites)\n                continue\n\n        if not alternate_sites:\n            return\n\n        sync_state = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            processed_site\n        )\n        # not yet available on processed_site, wont update alternate site yet\n        if not sync_state:\n            return\n        for file_info in sync_state[\"files\"]:\n            # expose status of remote site, it is expected on the server\n            file_info[\"status\"] = file_info[\"remoteStatus\"][\"status\"]\n\n        payload_dict = {\"files\": sync_state[\"files\"]}\n\n        alternate_sites = set(alternate_sites)\n        for alt_site in alternate_sites:\n            self.log.debug(\"Adding alternate {} to {}\".format(\n                alt_site, representation_id))\n\n            self._set_state_sync_state(\n                project_name,\n                representation_id,\n                alt_site,\n                payload_dict\n            )\n\n    # TODO - for Loaders\n    def get_repre_info_for_versions(\n        self, project_name, version_ids, active_site, remote_site\n    ):\n        \"\"\"Returns representation for versions and sites combi\n\n        Args:\n            project_name (str): Project name\n            version_ids (Iterable[str]): Version ids.\n            active_site (str): 'local', 'studio' etc\n            remote_site (str): dtto\n\n        Returns:\n\n        \"\"\"\n        version_ids = set(version_ids)\n        endpoint = \"{}/projects/{}/sitesync/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        # get to upload\n        kwargs = {\n            \"localSite\": active_site,\n            \"remoteSite\": remote_site,\n            \"versionIdFilter\": list(version_ids)\n        }\n\n        # kwargs[\"representationId\"] = \"94dca33a-7705-11ed-8c0a-34e12d91d510\"\n\n        response = ayon_api.get(endpoint, **kwargs)\n        repre_states = response.data.get(\"representations\", [])\n        repre_info_by_version_id = {\n            version_id: {\n                \"id\": version_id,\n                \"repre_count\": 0,\n                \"avail_repre_local\": 0,\n                \"avail_repre_remote\": 0,\n            }\n            for version_id in version_ids\n        }\n        repre_states_by_version_id = defaultdict(list)\n        for repre_state in repre_states:\n            version_id = repre_state[\"versionId\"]\n            repre_states_by_version_id[version_id].append(repre_state)\n\n        for version_id, repre_states in repre_states_by_version_id.items():\n            repre_info = repre_info_by_version_id[version_id]\n            repre_info[\"repre_count\"] = len(repre_states)\n            repre_info[\"avail_repre_local\"] = sum(\n                self._is_available(repre_state, \"localStatus\")\n                for repre_state in repre_states\n            )\n            repre_info[\"avail_repre_remote\"] = sum(\n                self._is_available(repre_state, \"remoteStatus\")\n                for repre_state in repre_states\n            )\n\n        return list(repre_info_by_version_id.values())\n    # --- End of Public API ---\n\n    def _is_available(self, repre, status):\n        \"\"\"Helper to decide if repre is download/uploaded on site.\n\n        Returns:\n            int: 1 if available, 0 if not.\n\n        \"\"\"\n        return int(repre[status][\"status\"] == SiteSyncStatus.OK)\n\n    def get_local_file_path(self, project_name, site_name, file_path):\n        \"\"\"Externalized for app.\n\n        Args:\n            project_name (str): Project name.\n            site_name (str): Site name.\n            file_path (str): File path from other site.\n\n        Returns:\n            str: Resolved local path.\n\n        \"\"\"\n        handler = LocalDriveHandler(project_name, site_name)\n        local_file_path = handler.resolve_path(file_path)\n\n        return local_file_path\n\n    def tray_init(self):\n        \"\"\"Initialization of Site Sync Server for Tray.\n\n        Called when tray is initialized, it checks if addon should be\n        enabled. If not, no initialization necessary.\n        \"\"\"\n        self.server_init()\n\n    def server_init(self):\n        \"\"\"Actual initialization of Sync Server.\"\"\"\n        # import only in tray or Python3, because of Python2 hosts\n        if not self.enabled:\n            return\n\n        from .sitesync import SiteSyncThread\n\n        self.lock = threading.Lock()\n\n        self.sitesync_thread = SiteSyncThread(self)\n\n    def tray_start(self):\n        \"\"\"Triggered when Tray is started.\n\n        Checks if configuration presets are available and if there is\n        any provider ('gdrive', 'S3') that is activated\n        (eg. has valid credentials).\n        \"\"\"\n        self.server_start()\n\n    def server_start(self):\n        if self.enabled:\n            self.sitesync_thread.start()\n        else:\n            self.log.info(\n                \"SiteSync is not enabled. Site Sync server was not started.\"\n            )\n\n    def tray_exit(self):\n        \"\"\"Stops sync thread if running.\n\n        Called from Addon Manager\n        \"\"\"\n        self.server_exit()\n\n    def server_exit(self):\n        if not self.sitesync_thread:\n            return\n\n        if not self.is_running:\n            return\n        try:\n            self.log.info(\"Stopping sync server server\")\n            self.sitesync_thread.is_running = False\n            self.sitesync_thread.stop()\n            self.log.info(\"Sync server stopped\")\n        except Exception:\n            self.log.warning(\n                \"Error has happened during Killing sync server\",\n                exc_info=True\n            )\n\n    def tray_menu(self, parent_menu):\n        pass\n\n    @property\n    def is_running(self):\n        return self.sitesync_thread.is_running\n\n    def get_anatomy(self, project_name):\n        \"\"\"Get already created or newly created anatomy for project\n\n        Args:\n            project_name (str): Project name.\n\n        Return:\n            Anatomy: Project anatomy object.\n        \"\"\"\n        from ayon_core.pipeline import Anatomy\n\n        return self._anatomies.get(project_name) or Anatomy(project_name)\n\n    @property\n    def sync_studio_settings(self):\n        if self._sync_studio_settings is None:\n            self._sync_studio_settings = (\n                get_studio_settings().get(self.name)\n            )\n\n        return self._sync_studio_settings\n\n    @property\n    def sync_project_settings(self):\n        if self._sync_project_settings is None:\n            self.set_sync_project_settings()\n\n        return self._sync_project_settings\n\n    def set_sync_project_settings(self, exclude_locals=False):\n        \"\"\"\n            Set sync_project_settings for all projects (caching)\n            Args:\n                exclude_locals (bool): ignore overrides from Local Settings\n            For performance\n        \"\"\"\n        sync_project_settings = self._prepare_sync_project_settings(\n            exclude_locals)\n\n        self._sync_project_settings = sync_project_settings\n\n    def _prepare_sync_project_settings(self, exclude_locals):\n        sync_project_settings = {}\n\n        sites = self._transform_sites_from_settings(\n            self.sync_studio_settings)\n\n        project_names = get_project_names()\n        for project_name in project_names:\n            project_sites = copy.deepcopy(sites)\n            project_settings = get_addon_project_settings(\n                self.name, self.version, project_name)\n\n            project_sites.update(self._get_default_site_configs(\n                project_settings[\"enabled\"], project_name, project_settings\n            ))\n\n            project_sites.update(\n                self._transform_sites_from_settings(project_settings))\n\n            project_settings[\"sites\"] = project_sites\n\n            sync_project_settings[project_name] = project_settings\n\n        if not sync_project_settings:\n            self.log.info(\"No enabled and configured projects for sync.\")\n        return sync_project_settings\n\n    def get_sync_project_setting(\n        self, project_name, exclude_locals=False, cached=True\n    ):\n        \"\"\" Handles pulling sitesync's settings for enabled 'project_name'\n\n        Args:\n            project_name (str): used in project settings\n            exclude_locals (bool): ignore overrides from Local Settings\n            cached (bool): use pre-cached values, or return fresh ones\n                cached values needed for single loop (with all overrides)\n                fresh values needed for Local settings (without overrides)\n\n        Returns:\n            dict: settings dictionary for the enabled project,\n                empty if no settings or sync is disabled\n\n        \"\"\"\n        # presets set already, do not call again and again\n        # self.log.debug(\"project preset {}\".format(self.presets))\n        if not cached:\n            return self._prepare_sync_project_settings(exclude_locals)\\\n                [project_name]\n\n        if (\n            not self.sync_project_settings\n            or not self.sync_project_settings.get(project_name)\n        ):\n            self.set_sync_project_settings(exclude_locals)\n        return self.sync_project_settings.get(project_name)\n\n    def _transform_sites_from_settings(self, settings):\n        \"\"\"Transforms list of 'sites' from Setting to dict.\n\n        It processes both System and Project Settings as they have same format.\n        \"\"\"\n        sites = {}\n        if not self.enabled:\n            return sites\n\n        for whole_site_info in settings.get(\"sites\", []):\n            site_name = whole_site_info[\"name\"]\n            provider_specific = copy.deepcopy(\n                whole_site_info[whole_site_info[\"provider\"]]\n            )\n            configured_site = {\n                \"enabled\": True,\n                \"alternative_sites\": whole_site_info[\"alternative_sites\"],\n                \"root\": provider_specific.pop(\"roots\", None)\n            }\n            configured_site.update(provider_specific)\n\n            sites[site_name] = configured_site\n        return sites\n\n    def _get_project_roots_for_site(self, project_name, site_name=None):\n        \"\"\"Returns projects roots and their overrides.\"\"\"\n        # overrides for Studio site for particular user\n        # TODO temporary to get roots without overrides\n        # ayon_api.get_project_roots_by_site returns only overrides.\n        # Should be replaced when ayon_api implements `siteRoots` method\n        if not site_name:\n            site_name = get_local_site_id()\n        platform_name = platform.system().lower()\n        roots = ayon_api.get(\n            f\"projects/{project_name}/siteRoots\",\n            platform=platform_name\n        ).data\n        root_overrides = get_project_roots_for_site(project_name, site_name)\n        for key, value in roots.items():\n            override = root_overrides.get(key)\n            if override:\n                roots[key] = override\n\n        return roots\n\n    def _get_default_site_configs(\n        self, sync_enabled=True, project_name=None, project_settings=None\n    ):\n        \"\"\"Settings for 'studio' and user's local site\n\n        Returns base values from setting, not overridden by Local Settings,\n        eg. value used to push TO LS not to get actual value for syncing.\n\n        Args:\n            sync_enabled (Optional[bool]): Is sync enabled.\n            project_name (Optional[str]): Project name.\n            project_settings (Optional[dict]): Project settings.\n\n        \"\"\"\n        local_site_id = get_local_site_id()\n        roots = self._get_project_roots_for_site(project_name, local_site_id)\n        studio_config = {\n            \"enabled\": True,\n            \"provider\": \"local_drive\",\n            \"root\": roots\n        }\n        all_sites = {self.DEFAULT_SITE: studio_config}\n        if sync_enabled:\n            roots = project_settings[\"local_setting\"][\"local_roots\"]\n            local_site_dict = {\n                \"enabled\": True,\n                \"provider\": \"local_drive\",\n                \"root\": roots\n            }\n            all_sites[local_site_id] = local_site_dict\n            # duplicate values for normalized local name\n            all_sites[\"local\"] = local_site_dict\n        return all_sites\n\n    def get_provider_for_site(self, project_name=None, site=None):\n        \"\"\"Get provider name for site (unique name across all projects).\"\"\"\n        sites = {\n            self.DEFAULT_SITE: \"local_drive\",\n            self.LOCAL_SITE: \"local_drive\",\n            get_local_site_id(): \"local_drive\"\n        }\n\n        if site in sites.keys():\n            return sites[site]\n\n        # backward compatibility\n        if project_name:\n            proj_settings = self.get_sync_project_setting(project_name)\n            provider = (\n                proj_settings\n                .get(\"sites\", {})\n                .get(site, {})\n                .get(\"provider\")\n            )\n            if provider:\n                return provider\n\n        sync_sett = self.sync_studio_settings\n        for site_config in sync_sett.get(\"sites\"):\n            sites[site_config[\"name\"]] = site_config[\"provider\"]\n\n        return sites.get(site, \"N/A\")\n\n    @time_function\n    def get_sync_representations(\n        self, project_name, active_site, remote_site, limit=10\n    ):\n        \"\"\"\n            Get representations that should be synced, these could be\n            recognised by presence of document in 'files.sites', where key is\n            a provider (GDrive, S3) and value is empty document or document\n            without 'created_dt' field. (Don't put null to 'created_dt'!).\n\n            Querying of 'to-be-synched' files is offloaded to Mongod for\n            better performance. Goal is to get as few representations as\n            possible.\n        Args:\n            project_name (str):\n            active_site (str): identifier of current active site (could be\n                'local_0' when working from home, 'studio' when working in the\n                studio (default)\n            remote_site (str): identifier of remote site I want to sync to\n\n        Returns:\n            list[dict]: Representation states.\n\n        \"\"\"\n        self.log.debug(\"Check representations for: {}-{}\".format(\n            active_site, remote_site\n        ))\n\n        endpoint = \"{}/{}/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        # get to upload\n        kwargs = {\n            \"localSite\": active_site,\n            \"remoteSite\": remote_site,\n            \"localStatusFilter\": [SiteSyncStatus.OK],\n            \"remoteStatusFilter\": [SiteSyncStatus.QUEUED],\n        }\n\n        response = ayon_api.get(endpoint, **kwargs)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\n                \"Cannot get representations for sync with code {}\".format(\n                    response.status_code\n                )\n            )\n\n        repre_states = response.data[\"representations\"]\n\n        # get to download\n        if len(repre_states) &lt; limit:\n            kwargs[\"localStatusFilter\"] = [SiteSyncStatus.QUEUED]\n            kwargs[\"remoteStatusFilter\"] = [SiteSyncStatus.OK]\n\n            response = ayon_api.get(endpoint, **kwargs)\n            repre_states.extend(response.data[\"representations\"])\n\n        return repre_states\n\n    def check_status(self, file_state, local_site, remote_site, config_preset):\n        \"\"\"Check synchronization status of a file.\n\n        The file is on representation status is checked for single 'provider'.\n            (Eg. check if 'scene.ma' of lookdev.v10 should be synced to GDrive\n\n        Always is comparing local record, eg. site with\n            'name' == self.presets[PROJECT_NAME][\"config\"][\"active_site\"]\n\n        This leads to trigger actual upload or download, there is\n            a use case 'studio' &lt;&gt; 'remote' where user should publish\n            to 'studio', see progress in Tray GUI, but do not do\n            physical upload/download\n            (as multiple user would be doing that).\n\n            Do physical U/D only when any of the sites is user's local, in that\n            case only user has the data and must U/D.\n\n        Args:\n            file_state (dict): File info from site sync database.\n            local_site (str): Local site of compare (usually 'studio').\n            remote_site (str): Remote site (gdrive etc).\n            config_preset (dict): Config about active site, retries.\n\n        Returns:\n            int: Sync status value of representation.\n\n        \"\"\"\n        if get_local_site_id() not in (local_site, remote_site):\n            # don't do upload/download for studio sites\n            self.log.debug(\n                \"No local site {} - {}\".format(local_site, remote_site)\n            )\n            return SyncStatus.DO_NOTHING\n\n        local_status = file_state[\"localStatus\"][\"status\"]\n        remote_status = file_state[\"remoteStatus\"][\"status\"]\n\n        if (\n            local_status != SiteSyncStatus.OK\n            and remote_status == SiteSyncStatus.OK\n        ):\n            retries = file_state[\"localStatus\"][\"retries\"]\n            if retries &lt; int(config_preset[\"retry_cnt\"]):\n                return SyncStatus.DO_DOWNLOAD\n\n        if (\n            remote_status != SiteSyncStatus.OK\n            and local_status == SiteSyncStatus.OK\n        ):\n            retries = file_state[\"remoteStatus\"][\"retries\"]\n            if retries &lt; int(config_preset[\"retry_cnt\"]):\n                return SyncStatus.DO_UPLOAD\n\n        return SyncStatus.DO_NOTHING\n\n    def update_db(\n        self,\n        project_name,\n        repre_status,\n        site_name,\n        new_file_id=None,\n        file=None,\n        side=None,\n        error=None,\n        progress=None,\n        priority=None,\n        pause=None\n    ):\n        \"\"\"Update 'provider' portion of records in DB.\n\n        Args:\n            project_name (str): Project name. Force to db connection as\n                each file might come from different collection.\n            repre_status (dict): Representation status from sitesync database.\n            site_name (str): Site name.\n            new_file_id (Optional[str]): File id of new file.\n            file (dict[str, Any]): info about processed file (pulled from DB)\n            side (str): 'local' | 'remote'\n            error (str): exception message\n            progress (float): 0-1 of progress of upload/download\n            priority (int): 0-100 set priority\n            pause (bool): stop synchronizing (only before starting of download,\n                upload)\n\n        Returns:\n            None\n        \"\"\"\n        files_status = []\n        for file_status in repre_status[\"files\"]:\n            status_entity = copy.deepcopy(\n                file_status[\"{}Status\".format(side)]\n            )\n            status_entity[\"fileHash\"] = file_status[\"fileHash\"]\n            status_entity[\"id\"] = file_status[\"id\"]\n            if file_status[\"fileHash\"] == file[\"fileHash\"]:\n                if new_file_id:\n                    status_entity[\"status\"] = SiteSyncStatus.OK\n                    status_entity.pop(\"message\")\n                    status_entity.pop(\"retries\")\n                elif progress is not None:\n                    status_entity[\"status\"] = SiteSyncStatus.IN_PROGRESS\n                    status_entity[\"progress\"] = progress\n                elif error:\n                    max_retries = int(\n                        self.sync_project_settings\n                        [project_name]\n                        [\"config\"]\n                        [\"retry_cnt\"]\n                    )\n                    tries = status_entity.get(\"retries\", 0)\n                    tries += 1\n                    status_entity[\"retries\"] = tries\n                    status_entity[\"message\"] = error\n                    if tries &gt;= max_retries:\n                        status_entity[\"status\"] = SiteSyncStatus.FAILED\n                elif pause is not None:\n                    if pause:\n                        status_entity[\"pause\"] = True\n                    else:\n                        status_entity.remove(\"pause\")\n                files_status.append(status_entity)\n\n        representation_id = repre_status[\"representationId\"]\n\n        endpoint = \"{}/{}/state/{}/{}\".format(\n            self.endpoint_prefix,\n            project_name,\n            representation_id,\n            site_name)\n\n        # get to upload\n        kwargs = {\n            \"files\": files_status\n        }\n\n        if priority:\n            kwargs[\"priority\"] = priority\n\n        response = ayon_api.post(endpoint, **kwargs)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\"Cannot update status\")\n\n        if progress is not None or priority is not None:\n            return\n\n        status = \"failed\"\n        error_str = \"with error {}\".format(error)\n        if new_file_id:\n            status = \"succeeded with id {}\".format(new_file_id)\n            error_str = \"\"\n\n        source_file = file.get(\"path\", \"\")\n\n        self.log.debug(\n            \"File for {} - {source_file} process {status} {error_str}\".format(\n                representation_id,\n                status=status,\n                source_file=source_file,\n                error_str=error_str\n            )\n        )\n\n    def reset_site_on_representation(\n        self,\n        project_name,\n        representation_id,\n        side=None,\n        file_id=None,\n        site_name=None\n    ):\n        \"\"\"\n            Reset information about synchronization for particular 'file_id'\n            and provider.\n            Useful for testing or forcing file to be reuploaded.\n\n            'side' and 'site_name' are disjunctive.\n\n            'side' is used for resetting local or remote side for\n            current user for repre.\n\n            'site_name' is used to set synchronization for particular site.\n            Should be used when repre should be synced to new site.\n\n        Args:\n            project_name (str): name of project (eg. collection) in DB\n            representation_id (str): Representation id.\n            file_id (str): File id in representation.\n            side (str): Local or remote side.\n            site_name (str): for adding new site\n\n        Raises:\n            SiteAlreadyPresentError - if adding already existing site and\n                not 'force'\n            ValueError - other errors (repre not found, misconfiguration)\n        \"\"\"\n        representation = get_representation_by_id(\n            project_name, representation_id\n        )\n        if not representation:\n            raise ValueError(\n                \"Representation {} not found in {}\".format(\n                    representation_id, project_name\n                )\n            )\n\n        if side and site_name:\n            raise ValueError(\n                \"Misconfiguration, only one of side and\"\n                \" site_name arguments should be passed.\"\n            )\n\n        if side:\n            if side == \"local\":\n                site_name = self.get_active_site(project_name)\n            else:\n                site_name = self.get_remote_site(project_name)\n\n        self.add_site(\n            project_name, representation_id, site_name, file_id, force=True\n        )\n\n    def _get_progress_for_repre_new(\n        self,\n        project_name,\n        representation,\n        local_site_name,\n        remote_site_name=None\n    ):\n        representation_id = representation[\"id\"]\n        sync_status = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            local_site_name,\n            remote_site_name\n        )\n\n        progress = {\n            local_site_name: -1,\n            remote_site_name: -1\n        }\n        if not sync_status:\n            return progress\n\n        mapping = {\n            \"localStatus\": local_site_name,\n            \"remoteStatus\": remote_site_name\n        }\n        files = {local_site_name: 0, remote_site_name: 0}\n        file_states = sync_status.get(\"files\") or []\n        for file_state in file_states:\n            for status in mapping.keys():\n                status_info = file_state[status]\n                site_name = mapping[status]\n                files[site_name] += 1\n                norm_progress = max(progress[site_name], 0)\n                if status_info[\"status\"] == SiteSyncStatus.OK:\n                    progress[site_name] = norm_progress + 1\n                elif status_info.get(\"progress\"):\n                    progress[site_name] = norm_progress + status_info[\n                        \"progress\"]\n                else:  # site exists, might be failed, do not add again\n                    progress[site_name] = 0\n\n        # for example 13 fully avail. files out of 26 &gt;&gt; 13/26 = 0.5\n        return {\n            local_site_name: (\n                progress[local_site_name] / max(files[local_site_name], 1)\n            ),\n            remote_site_name: (\n                progress[remote_site_name] / max(files[remote_site_name], 1)\n            )\n        }\n\n    def _get_progress_for_repre_old(\n        self,\n        representation,\n        local_site_name,\n        remote_site_name=None\n    ):\n        return self._get_progress_for_repre_new(\n            representation[\"context\"][\"project\"][\"name\"],\n            representation,\n            local_site_name,\n            remote_site_name\n        )\n\n    def get_progress_for_repre(self, *args, **kwargs):\n        \"\"\"Calculates average progress for representation.\n\n        If site has created_dt &gt;&gt; fully available &gt;&gt; progress == 1\n\n        Could be calculated in aggregate if it would be too slow\n\n        Returns:\n            (dict) with active and remote sites progress\n            {'studio': 1.0, 'gdrive': -1} - gdrive site is not present\n                -1 is used to highlight the site should be added\n            {'studio': 1.0, 'gdrive': 0.0} - gdrive site is present, not\n                uploaded yet\n\n        \"\"\"\n        sig_new = inspect.signature(self._get_progress_for_repre_new)\n        sig_old = inspect.signature(self._get_progress_for_repre_old)\n        try:\n            sig_new.bind(*args, **kwargs)\n            return self._get_progress_for_repre_new(*args, **kwargs)\n        except TypeError:\n            pass\n\n        try:\n            sig_old.bind(*args, **kwargs)\n            print(\n                \"Using old signature of 'get_progress_for_repre'\"\n                \" please add project name as first argument.\"\n            )\n            return self._get_progress_for_repre_old(*args, **kwargs)\n        except TypeError:\n            pass\n\n        return self._get_progress_for_repre_new(*args, **kwargs)\n\n    def _set_state_sync_state(\n        self, project_name, representation_id, site_name, payload_dict\n    ):\n        \"\"\"Calls server endpoint to store sync info for 'representation_id'.\"\"\"\n        endpoint = \"{}/{}/state/{}/{}\".format(\n            self.endpoint_prefix,\n            project_name,\n            representation_id,\n            site_name\n        )\n\n        response = ayon_api.post(endpoint, **payload_dict)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\"Cannot update status\")\n\n    def get_repre_sync_state(\n        self,\n        project_name,\n        representation_id,\n        local_site_name,\n        remote_site_name=None,\n        **kwargs\n    ):\n        \"\"\"Use server endpoint to get synchronization info for representation.\n\n        Warning:\n            Logic of this\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            local_site_name (str)\n            remote_site_name (str)\n            all other parameters for `Get Site Sync State` endpoint if\n                necessary\n\n        \"\"\"\n        repre_states = self._get_repres_state(\n            project_name,\n            {representation_id},\n            local_site_name,\n            remote_site_name,\n            **kwargs\n        )\n        if repre_states:\n            repre_state = repre_states[0]\n            if repre_state[\"localStatus\"][\"status\"] != -1:\n                return repre_state\n\n    def get_representations_sync_state(\n        self,\n        project_name,\n        representation_ids,\n        local_site_name,\n        remote_site_name=None,\n        **kwargs\n    ):\n        \"\"\"Use server endpoint to get synchronization info for representations.\n\n        Calculates float progress based on progress of all files for repre.\n        If repre is fully synchronized it returns 1, 0 for any other state.\n\n        Args:\n            project_name (str):\n            representation_ids (list): even single repre should be in []\n            local_site_name (str)\n            remote_site_name (str)\n            all other parameters for `Get Site Sync State` endpoint if\n                necessary.\n\n        Returns:\n            dict[str, tuple[float, float]]: Progress by representation id.\n\n        \"\"\"\n        repre_states = self._get_repres_state(\n            project_name,\n            representation_ids,\n            local_site_name,\n            remote_site_name,\n            **kwargs\n        )\n        states = {}\n        for repre_state in repre_states:\n            repre_files_count = len(repre_state[\"files\"])\n\n            repre_local_status = repre_state[\"localStatus\"][\"status\"]\n            repre_local_progress = 0\n            if repre_local_status == SiteSyncStatus.OK:\n                repre_local_progress = 1\n            elif repre_local_status == SiteSyncStatus.IN_PROGRESS:\n                local_sum = sum(\n                    file_info[\"localStatus\"].get(\"progress\", 0)\n                    for file_info in repre_state[\"files\"]\n                )\n                repre_local_progress = local_sum / repre_files_count\n\n            repre_remote_status = repre_state[\"remoteStatus\"][\"status\"]\n            repre_remote_progress = 0\n            if repre_remote_status == SiteSyncStatus.OK:\n                repre_remote_progress = 1\n            elif repre_remote_status == SiteSyncStatus.IN_PROGRESS:\n                remote_sum = sum(\n                    file_info[\"remoteStatus\"].get(\"progress\", 0)\n                    for file_info in repre_state[\"files\"]\n                )\n                repre_remote_progress = remote_sum / repre_files_count\n\n            states[repre_state[\"representationId\"]] = (\n                repre_local_progress,\n                repre_remote_progress\n            )\n\n        return states\n\n    def _get_repres_state(\n        self,\n        project_name,\n        representation_ids,\n        local_site_name,\n        remote_site_name=None,\n        **kwargs\n    ):\n        \"\"\"Use server endpoint to get sync info for representations.\n\n        Args:\n            project_name (str): Project name.\n            representation_ids (Iterable[str]): Representation ids.\n            local_site_name (str): Local site name.\n            remote_site_name (str): Remote site name.\n            kwargs: All other parameters for `Get Site Sync State` endpoint if\n                necessary\n\n        \"\"\"\n        if not remote_site_name:\n            remote_site_name = local_site_name\n        payload_dict = {\n            \"localSite\": local_site_name,\n            \"remoteSite\": remote_site_name,\n            \"representationIds\": representation_ids\n        }\n        if kwargs:\n            payload_dict.update(kwargs)\n\n        endpoint = \"{}/{}/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        response = ayon_api.get(endpoint, **payload_dict)\n        if response.status_code != 200:\n            raise RuntimeError(\n                \"Cannot get sync state for representations {}\".format(\n                    representation_ids\n                )\n            )\n\n        return response.data[\"representations\"]\n\n    def get_version_availability(\n        self,\n        project_name,\n        version_ids,\n        local_site_name,\n        remote_site_name,\n        **kwargs\n    ):\n        \"\"\"Returns aggregated state for version ids.\n\n        Args:\n            project_name (str): Project name.\n            version_ids (Iterable[str]): Version ids.\n            local_site_name (str): Local site name.\n            remote_site_name (str): Remote site name.\n            kwargs: All other parameters for `Get Site Sync State` endpoint if\n                necessary.\n\n        Returns:\n            dict[str, tuple[float, float]]: Status by version id.\n                Example: {version_id: (local_status, remote_status)}\n\n        \"\"\"\n        version_ids = list(version_ids)\n        payload_dict = {\n            \"localSite\": local_site_name,\n            \"remoteSite\": remote_site_name,\n            \"versionIdsFilter\": version_ids\n        }\n        payload_dict.update(kwargs)\n\n        endpoint = \"{}/{}/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        response = ayon_api.get(endpoint, **payload_dict)\n        if response.status_code != 200:\n            raise RuntimeError(\n                \"Cannot get sync state for versions {}\".format(\n                    version_ids\n                )\n            )\n\n        version_statuses = {\n            version_id: (0, 0)\n            for version_id in version_ids\n        }\n\n        repre_avail_by_version_id = defaultdict(list)\n        for repre_avail in response.data[\"representations\"]:\n            version_id = repre_avail[\"versionId\"]\n            repre_avail_by_version_id[version_id].append(repre_avail)\n\n        for version_id, repre_avails in repre_avail_by_version_id.items():\n            avail_local = sum(\n                int(\n                    repre_avail[\"localStatus\"][\"status\"] == SiteSyncStatus.OK\n                )\n                for repre_avail in repre_avails\n            )\n            avail_remote = sum(\n                int(\n                    repre_avail[\"remoteStatus\"][\"status\"] == SiteSyncStatus.OK\n                )\n                for repre_avail in repre_avails\n            )\n            version_statuses[version_id] = (avail_local, avail_remote)\n\n        return version_statuses\n\n    def _remove_local_file(self, project_name, representation_id, site_name):\n        \"\"\"Removes all local files for 'site_name' of 'representation_id'\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): name of configured and active site\n\n        \"\"\"\n        my_local_site = get_local_site_id()\n        if my_local_site != site_name:\n            self.log.warning(\n                \"Cannot remove non local file for {}\".format(site_name)\n            )\n            return\n\n        provider_name = self.get_provider_for_site(site=site_name)\n\n        if provider_name != \"local_drive\":\n            return\n\n        representation = get_representation_by_id(\n            project_name, representation_id\n        )\n        if not representation:\n            self.log.debug(\n                \"Representation with id {} was not found\".format(\n                    representation_id\n                )\n            )\n            return\n\n        for file in representation[\"files\"]:\n            local_file_path = self.get_local_file_path(\n                project_name,\n                site_name,\n                file.get(\"path\")\n            )\n            if local_file_path is None:\n                raise ValueError(\"Missing local file path\")\n\n            try:\n                self.log.debug(\"Removing {}\".format(local_file_path))\n                os.remove(local_file_path)\n            except IndexError:\n                msg = \"No file set for {}\".format(representation_id)\n                self.log.debug(msg)\n                raise ValueError(msg)\n            except OSError:\n                msg = \"File {} cannot be removed\".format(file[\"path\"])\n                self.log.warning(msg)\n                raise ValueError(msg)\n\n            folder = os.path.dirname(local_file_path)\n            if os.listdir(folder):  # folder is not empty\n                continue\n\n            try:\n                os.rmdir(folder)\n            except OSError:\n                msg = \"folder {} cannot be removed\".format(folder)\n                self.log.warning(msg)\n                raise ValueError(msg)\n\n    def reset_timer(self):\n        \"\"\"\n            Called when waiting for next loop should be skipped.\n\n            In case of user's involvement (reset site), start that right away.\n        \"\"\"\n\n        if not self.enabled:\n            return\n\n        if self.sitesync_thread is None:\n            self._reset_timer_with_rest_api()\n        else:\n            self.sitesync_thread.reset_timer()\n\n    def get_loop_delay(self, project_name):\n        \"\"\"\n            Return count of seconds before next synchronization loop starts\n            after finish of previous loop.\n\n        Returns:\n            (int): in seconds\n        \"\"\"\n        if not project_name:\n            return 60\n\n        # TODO this is used in global loop it should not be based on\n        #   project settings.\n        ld = self.sync_project_settings[project_name][\"config\"][\"loop_delay\"]\n        return int(ld)\n\n    def cli(self, click_group):\n        main = click_wrap.group(\n            self._cli_main,\n            name=self.name,\n            help=\"SiteSync addon related commands.\"\n        )\n\n        main.command(\n            self._cli_command_syncservice,\n            name=\"syncservice\",\n            help=\"Launch Site Sync under entered site.\"\n        ).option(\n            \"-a\",\n            \"--active_site\",\n            help=\"Name of active site\",\n            required=True\n        )\n        click_group.add_command(main.to_click_obj())\n\n    def _cli_main(self):\n        pass\n\n    def _cli_command_syncservice(self, active_site):\n        \"\"\"Launch sync server under entered site.\n\n        This should be ideally used by system service (such us systemd or upstart\n        on linux and window service).\n        \"\"\"\n\n        os.environ[\"AYON_SITE_ID\"] = active_site\n\n        def signal_handler(sig, frame):\n            print(\"You pressed Ctrl+C. Process ended.\")\n            self.server_exit()\n            sys.exit(0)\n\n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n\n        self.server_init()\n        self.server_start()\n\n        while True:\n            time.sleep(1.0)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.add_site","title":"<code>add_site(project_name, representation_id, site_name=None, file_id=None, force=False, status=SiteSyncStatus.QUEUED)</code>","text":"<p>Adds new site to representation to be synced.</p> <p>'project_name' must have synchronization enabled (globally or project only)</p> <p>Used as a API endpoint from outside applications (Loader etc).</p> <p>Use 'force' to reset existing site.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>site_name</code> <code>str</code> <p>Site name of configured site.</p> <code>None</code> <code>file_id</code> <code>str</code> <p>File id.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Reset site if exists.</p> <code>False</code> <code>status</code> <code>SiteSyncStatus</code> <p>Current status, default SiteSyncStatus.QUEUED</p> <code>QUEUED</code> <p>Raises:</p> Type Description <code>SiteAlreadyPresentError</code> <p>If adding already existing site and not 'force'</p> <code>ValueError</code> <p>other errors (repre not found, misconfiguration)</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def add_site(\n    self,\n    project_name,\n    representation_id,\n    site_name=None,\n    file_id=None,\n    force=False,\n    status=SiteSyncStatus.QUEUED\n):\n    \"\"\"Adds new site to representation to be synced.\n\n    'project_name' must have synchronization enabled (globally or\n    project only)\n\n    Used as a API endpoint from outside applications (Loader etc).\n\n    Use 'force' to reset existing site.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        site_name (str): Site name of configured site.\n        file_id (str): File id.\n        force (bool): Reset site if exists.\n        status (SiteSyncStatus): Current status,\n            default SiteSyncStatus.QUEUED\n\n    Raises:\n        SiteAlreadyPresentError: If adding already existing site and\n            not 'force'\n        ValueError: other errors (repre not found, misconfiguration)\n\n    \"\"\"\n    if not self.get_sync_project_setting(project_name):\n        raise ValueError(\"Project not configured\")\n\n    if not site_name:\n        site_name = self.DEFAULT_SITE\n\n    representation = get_representation_by_id(\n        project_name, representation_id\n    )\n\n    files = representation.get(\"files\", [])\n    if not files:\n        self.log.debug(\"No files for {}\".format(representation_id))\n        return\n\n    if not force:\n        existing = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            site_name\n        )\n        if existing:\n            failure = True\n            if file_id:\n                file_exists = existing.get(\"files\", {}).get(file_id)\n                if not file_exists:\n                    failure = False\n\n            if failure:\n                msg = \"Site {} already present\".format(site_name)\n                self.log.info(msg)\n                raise SiteAlreadyPresentError(msg)\n\n    new_site_files = [\n        {\n            \"size\": repre_file[\"size\"],\n            \"status\": status,\n            \"timestamp\": datetime.now().timestamp(),\n            \"id\": repre_file[\"id\"],\n            \"fileHash\": repre_file[\"hash\"]\n        }\n        for repre_file in files\n    ]\n\n    payload_dict = {\"files\": new_site_files}\n    representation_id = representation_id.replace(\"-\", \"\")\n\n    self._set_state_sync_state(\n        project_name, representation_id, site_name, payload_dict\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.check_status","title":"<code>check_status(file_state, local_site, remote_site, config_preset)</code>","text":"<p>Check synchronization status of a file.</p> <p>The file is on representation status is checked for single 'provider'.     (Eg. check if 'scene.ma' of lookdev.v10 should be synced to GDrive</p> <p>Always is comparing local record, eg. site with     'name' == self.presets[PROJECT_NAME][\"config\"][\"active_site\"]</p> <p>This leads to trigger actual upload or download, there is     a use case 'studio' &lt;&gt; 'remote' where user should publish     to 'studio', see progress in Tray GUI, but do not do     physical upload/download     (as multiple user would be doing that).</p> <pre><code>Do physical U/D only when any of the sites is user's local, in that\ncase only user has the data and must U/D.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_state</code> <code>dict</code> <p>File info from site sync database.</p> required <code>local_site</code> <code>str</code> <p>Local site of compare (usually 'studio').</p> required <code>remote_site</code> <code>str</code> <p>Remote site (gdrive etc).</p> required <code>config_preset</code> <code>dict</code> <p>Config about active site, retries.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Sync status value of representation.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def check_status(self, file_state, local_site, remote_site, config_preset):\n    \"\"\"Check synchronization status of a file.\n\n    The file is on representation status is checked for single 'provider'.\n        (Eg. check if 'scene.ma' of lookdev.v10 should be synced to GDrive\n\n    Always is comparing local record, eg. site with\n        'name' == self.presets[PROJECT_NAME][\"config\"][\"active_site\"]\n\n    This leads to trigger actual upload or download, there is\n        a use case 'studio' &lt;&gt; 'remote' where user should publish\n        to 'studio', see progress in Tray GUI, but do not do\n        physical upload/download\n        (as multiple user would be doing that).\n\n        Do physical U/D only when any of the sites is user's local, in that\n        case only user has the data and must U/D.\n\n    Args:\n        file_state (dict): File info from site sync database.\n        local_site (str): Local site of compare (usually 'studio').\n        remote_site (str): Remote site (gdrive etc).\n        config_preset (dict): Config about active site, retries.\n\n    Returns:\n        int: Sync status value of representation.\n\n    \"\"\"\n    if get_local_site_id() not in (local_site, remote_site):\n        # don't do upload/download for studio sites\n        self.log.debug(\n            \"No local site {} - {}\".format(local_site, remote_site)\n        )\n        return SyncStatus.DO_NOTHING\n\n    local_status = file_state[\"localStatus\"][\"status\"]\n    remote_status = file_state[\"remoteStatus\"][\"status\"]\n\n    if (\n        local_status != SiteSyncStatus.OK\n        and remote_status == SiteSyncStatus.OK\n    ):\n        retries = file_state[\"localStatus\"][\"retries\"]\n        if retries &lt; int(config_preset[\"retry_cnt\"]):\n            return SyncStatus.DO_DOWNLOAD\n\n    if (\n        remote_status != SiteSyncStatus.OK\n        and local_status == SiteSyncStatus.OK\n    ):\n        retries = file_state[\"remoteStatus\"][\"retries\"]\n        if retries &lt; int(config_preset[\"retry_cnt\"]):\n            return SyncStatus.DO_UPLOAD\n\n    return SyncStatus.DO_NOTHING\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.clear_project","title":"<code>clear_project(project_name, site_name)</code>","text":"<p>Clear 'project_name' of 'site_name' and its local files</p> <p>Works only on real local sites, not on 'studio'</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def clear_project(self, project_name, site_name):\n    \"\"\"\n        Clear 'project_name' of 'site_name' and its local files\n\n        Works only on real local sites, not on 'studio'\n    \"\"\"\n\n    # TODO implement\n    self.log.warning(\"Method 'clear_project' is not implemented.\")\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.compute_resource_sync_sites","title":"<code>compute_resource_sync_sites(project_name)</code>","text":"<p>Get available resource sync sites state for publish process.</p> <p>Returns dict with prepared state of sync sites for 'project_name'. It checks if Site Sync is enabled, handles alternative sites. Publish process stores this dictionary as a part of representation document in DB.</p> <p>Example: [     {         'name': '42abbc09-d62a-44a4-815c-a12cd679d2d7',         'status': SiteSyncStatus.OK     },     {'name': 'studio', 'status': SiteSyncStatus.QUEUED},     {'name': 'SFTP', 'status': SiteSyncStatus.QUEUED} ] -- representation is published locally, artist or Settings have set remote site as 'studio'. 'SFTP' is alternate site to 'studio'. Eg. whenever file is on 'studio', it is also on 'SFTP'.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def compute_resource_sync_sites(self, project_name):\n    \"\"\"Get available resource sync sites state for publish process.\n\n    Returns dict with prepared state of sync sites for 'project_name'.\n    It checks if Site Sync is enabled, handles alternative sites.\n    Publish process stores this dictionary as a part of representation\n    document in DB.\n\n    Example:\n    [\n        {\n            'name': '42abbc09-d62a-44a4-815c-a12cd679d2d7',\n            'status': SiteSyncStatus.OK\n        },\n        {'name': 'studio', 'status': SiteSyncStatus.QUEUED},\n        {'name': 'SFTP', 'status': SiteSyncStatus.QUEUED}\n    ] -- representation is published locally, artist or Settings have set\n    remote site as 'studio'. 'SFTP' is alternate site to 'studio'. Eg.\n    whenever file is on 'studio', it is also on 'SFTP'.\n    \"\"\"\n\n    def create_metadata(name, created=True):\n        \"\"\"Create sync site metadata for site with `name`\"\"\"\n        if created:\n            status = SiteSyncStatus.OK\n        else:\n            status = SiteSyncStatus.QUEUED\n        return {\"name\": name, \"status\": status}\n\n    if (\n        not self.sync_studio_settings[\"enabled\"]\n        or not self.sync_project_settings[project_name][\"enabled\"]\n    ):\n        return [create_metadata(self.DEFAULT_SITE)]\n\n    local_site = self.get_active_site(project_name)\n    remote_site = self.get_remote_site(project_name)\n\n    # Attached sites metadata by site name\n    # That is the local site, remote site, the always accesible sites\n    # and their alternate sites (alias of sites with different protocol)\n    attached_sites = {\n        local_site: create_metadata(local_site)\n    }\n    if remote_site and remote_site not in attached_sites:\n        attached_sites[remote_site] = create_metadata(\n            remote_site, created=False\n        )\n\n    attached_sites = self._add_alternative_sites(\n        project_name, attached_sites)\n    # add skeleton for sites where it should be always synced to\n    # usually it would be a backup site which is handled by separate\n    # background process\n    for site_name in self._get_always_accessible_sites(project_name):\n        if site_name not in attached_sites:\n            attached_sites[site_name] = (\n                create_metadata(site_name, created=False))\n    unique_sites = {\n        site[\"name\"]: site\n        for site in attached_sites.values()\n    }\n    return list(unique_sites.values())\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_active_site","title":"<code>get_active_site(project_name)</code>","text":"<p>Returns active (mine) site for project from settings.</p> Output logic <ul> <li>'studio' if Site Sync is disabled</li> <li>value from 'get_local_site_id' if active site is 'local'</li> <li>any other site name from local settings     or project settings (site could be forced from PS)</li> </ul> <p>Returns:</p> Name Type Description <code>str</code> <p>Site name.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_active_site(self, project_name):\n    \"\"\"Returns active (mine) site for project from settings.\n\n    Output logic:\n        - 'studio' if Site Sync is disabled\n        - value from 'get_local_site_id' if active site is 'local'\n        - any other site name from local settings\n            or project settings (site could be forced from PS)\n\n    Returns:\n        str: Site name.\n\n    \"\"\"\n    active_site_type = self.get_active_site_type(project_name)\n    if active_site_type == self.LOCAL_SITE:\n        return get_local_site_id()\n    return active_site_type\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_active_site_type","title":"<code>get_active_site_type(project_name, local_settings=None)</code>","text":"<p>Active site which is defined by artist.</p> <p>Unlike 'get_active_site' is this method also checking local settings where might be different active site set by user. The output is limited to \"studio\" and \"local\".</p> <p>This method is used by Anatomy.</p> Todos <p>Check if sync server is enabled for the project. - To be able to do that the sync settings MUST NOT be cached for     all projects at once. The sync settings preparation for all     projects is reasonable only in sync server loop. <code>local_settings</code> is probably obsolete in AYON</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project where to look for active site.</p> required <code>local_settings</code> <code>Optional[dict[str, Any]]</code> <p>Prepared local settings.</p> <code>None</code> <p>Returns:</p> Type Description <p>Literal[\"studio\", \"local\"]: Active site.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_active_site_type(self, project_name, local_settings=None):\n    \"\"\"Active site which is defined by artist.\n\n    Unlike 'get_active_site' is this method also checking local settings\n    where might be different active site set by user. The output is limited\n    to \"studio\" and \"local\".\n\n    This method is used by Anatomy.\n\n    Todos:\n        Check if sync server is enabled for the project.\n        - To be able to do that the sync settings MUST NOT be cached for\n            all projects at once. The sync settings preparation for all\n            projects is reasonable only in sync server loop.\n        `local_settings` is probably obsolete in AYON\n\n    Args:\n        project_name (str): Name of project where to look for active site.\n        local_settings (Optional[dict[str, Any]]): Prepared local settings.\n\n    Returns:\n        Literal[\"studio\", \"local\"]: Active site.\n    \"\"\"\n    if not self.enabled:\n        return \"studio\"\n\n    sync_project_settings = self.get_sync_project_setting(project_name)\n\n    if not sync_project_settings[\"enabled\"]:\n        return \"studio\"\n\n    return (\n        sync_project_settings[\"local_setting\"].get(\"active_site\")\n        or sync_project_settings[\"config\"][\"active_site\"]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_anatomy","title":"<code>get_anatomy(project_name)</code>","text":"<p>Get already created or newly created anatomy for project</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required Return <p>Anatomy: Project anatomy object.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_anatomy(self, project_name):\n    \"\"\"Get already created or newly created anatomy for project\n\n    Args:\n        project_name (str): Project name.\n\n    Return:\n        Anatomy: Project anatomy object.\n    \"\"\"\n    from ayon_core.pipeline import Anatomy\n\n    return self._anatomies.get(project_name) or Anatomy(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_enabled_projects","title":"<code>get_enabled_projects()</code>","text":"<p>Returns list of projects which have SiteSync enabled.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_enabled_projects(self):\n    \"\"\"Returns list of projects which have SiteSync enabled.\"\"\"\n    enabled_projects = []\n\n    if self.enabled:\n        for project_name in get_project_names():\n            if self.is_project_enabled(project_name):\n                enabled_projects.append(project_name)\n\n    return enabled_projects\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_launch_hook_paths","title":"<code>get_launch_hook_paths()</code>","text":"<p>Implementation for applications launch hooks.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>full absolut path to directory with hooks for the addon</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_launch_hook_paths(self):\n    \"\"\"Implementation for applications launch hooks.\n\n    Returns:\n        str: full absolut path to directory with hooks for the addon\n\n    \"\"\"\n    return os.path.join(\n        os.path.dirname(os.path.abspath(__file__)),\n        \"launch_hooks\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_local_file_path","title":"<code>get_local_file_path(project_name, site_name, file_path)</code>","text":"<p>Externalized for app.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>site_name</code> <code>str</code> <p>Site name.</p> required <code>file_path</code> <code>str</code> <p>File path from other site.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Resolved local path.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_local_file_path(self, project_name, site_name, file_path):\n    \"\"\"Externalized for app.\n\n    Args:\n        project_name (str): Project name.\n        site_name (str): Site name.\n        file_path (str): File path from other site.\n\n    Returns:\n        str: Resolved local path.\n\n    \"\"\"\n    handler = LocalDriveHandler(project_name, site_name)\n    local_file_path = handler.resolve_path(file_path)\n\n    return local_file_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_local_normalized_site","title":"<code>get_local_normalized_site(site_name)</code>","text":"<p>Normlize local site name.</p> <p>Return 'local' if 'site_name' is local id.</p> <p>In some places Settings or Local Settings require 'local' instead of real site name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Normalized site name.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_local_normalized_site(self, site_name):\n    \"\"\"Normlize local site name.\n\n     Return 'local' if 'site_name' is local id.\n\n    In some places Settings or Local Settings require 'local' instead\n    of real site name.\n\n    Returns:\n        str: Normalized site name.\n\n    \"\"\"\n    if site_name == get_local_site_id():\n        site_name = self.LOCAL_SITE\n\n    return site_name\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_loop_delay","title":"<code>get_loop_delay(project_name)</code>","text":"<pre><code>Return count of seconds before next synchronization loop starts\nafter finish of previous loop.\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>in seconds</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_loop_delay(self, project_name):\n    \"\"\"\n        Return count of seconds before next synchronization loop starts\n        after finish of previous loop.\n\n    Returns:\n        (int): in seconds\n    \"\"\"\n    if not project_name:\n        return 60\n\n    # TODO this is used in global loop it should not be based on\n    #   project settings.\n    ld = self.sync_project_settings[project_name][\"config\"][\"loop_delay\"]\n    return int(ld)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_progress_for_repre","title":"<code>get_progress_for_repre(*args, **kwargs)</code>","text":"<p>Calculates average progress for representation.</p> <p>If site has created_dt &gt;&gt; fully available &gt;&gt; progress == 1</p> <p>Could be calculated in aggregate if it would be too slow</p> <p>Returns:</p> Type Description <p>(dict) with active and remote sites progress</p> <p>{'studio': 1.0, 'gdrive': -1} - gdrive site is not present -1 is used to highlight the site should be added</p> <p>{'studio': 1.0, 'gdrive': 0.0} - gdrive site is present, not uploaded yet</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_progress_for_repre(self, *args, **kwargs):\n    \"\"\"Calculates average progress for representation.\n\n    If site has created_dt &gt;&gt; fully available &gt;&gt; progress == 1\n\n    Could be calculated in aggregate if it would be too slow\n\n    Returns:\n        (dict) with active and remote sites progress\n        {'studio': 1.0, 'gdrive': -1} - gdrive site is not present\n            -1 is used to highlight the site should be added\n        {'studio': 1.0, 'gdrive': 0.0} - gdrive site is present, not\n            uploaded yet\n\n    \"\"\"\n    sig_new = inspect.signature(self._get_progress_for_repre_new)\n    sig_old = inspect.signature(self._get_progress_for_repre_old)\n    try:\n        sig_new.bind(*args, **kwargs)\n        return self._get_progress_for_repre_new(*args, **kwargs)\n    except TypeError:\n        pass\n\n    try:\n        sig_old.bind(*args, **kwargs)\n        print(\n            \"Using old signature of 'get_progress_for_repre'\"\n            \" please add project name as first argument.\"\n        )\n        return self._get_progress_for_repre_old(*args, **kwargs)\n    except TypeError:\n        pass\n\n    return self._get_progress_for_repre_new(*args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_provider_for_site","title":"<code>get_provider_for_site(project_name=None, site=None)</code>","text":"<p>Get provider name for site (unique name across all projects).</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_provider_for_site(self, project_name=None, site=None):\n    \"\"\"Get provider name for site (unique name across all projects).\"\"\"\n    sites = {\n        self.DEFAULT_SITE: \"local_drive\",\n        self.LOCAL_SITE: \"local_drive\",\n        get_local_site_id(): \"local_drive\"\n    }\n\n    if site in sites.keys():\n        return sites[site]\n\n    # backward compatibility\n    if project_name:\n        proj_settings = self.get_sync_project_setting(project_name)\n        provider = (\n            proj_settings\n            .get(\"sites\", {})\n            .get(site, {})\n            .get(\"provider\")\n        )\n        if provider:\n            return provider\n\n    sync_sett = self.sync_studio_settings\n    for site_config in sync_sett.get(\"sites\"):\n        sites[site_config[\"name\"]] = site_config[\"provider\"]\n\n    return sites.get(site, \"N/A\")\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_remote_site","title":"<code>get_remote_site(project_name)</code>","text":"<p>Remote (theirs) site for project from settings.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_remote_site(self, project_name):\n    \"\"\"Remote (theirs) site for project from settings.\"\"\"\n    sync_project_settings = self.get_sync_project_setting(project_name)\n    remote_site = (\n        sync_project_settings[\"local_setting\"].get(\"remote_site\")\n        or sync_project_settings[\"config\"][\"remote_site\"]\n    )\n    if remote_site == self.LOCAL_SITE:\n        return get_local_site_id()\n\n    return remote_site\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_repre_info_for_versions","title":"<code>get_repre_info_for_versions(project_name, version_ids, active_site, remote_site)</code>","text":"<p>Returns representation for versions and sites combi</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name</p> required <code>version_ids</code> <code>Iterable[str]</code> <p>Version ids.</p> required <code>active_site</code> <code>str</code> <p>'local', 'studio' etc</p> required <code>remote_site</code> <code>str</code> <p>dtto</p> required <p>Returns:</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_repre_info_for_versions(\n    self, project_name, version_ids, active_site, remote_site\n):\n    \"\"\"Returns representation for versions and sites combi\n\n    Args:\n        project_name (str): Project name\n        version_ids (Iterable[str]): Version ids.\n        active_site (str): 'local', 'studio' etc\n        remote_site (str): dtto\n\n    Returns:\n\n    \"\"\"\n    version_ids = set(version_ids)\n    endpoint = \"{}/projects/{}/sitesync/state\".format(\n        self.endpoint_prefix, project_name\n    )\n\n    # get to upload\n    kwargs = {\n        \"localSite\": active_site,\n        \"remoteSite\": remote_site,\n        \"versionIdFilter\": list(version_ids)\n    }\n\n    # kwargs[\"representationId\"] = \"94dca33a-7705-11ed-8c0a-34e12d91d510\"\n\n    response = ayon_api.get(endpoint, **kwargs)\n    repre_states = response.data.get(\"representations\", [])\n    repre_info_by_version_id = {\n        version_id: {\n            \"id\": version_id,\n            \"repre_count\": 0,\n            \"avail_repre_local\": 0,\n            \"avail_repre_remote\": 0,\n        }\n        for version_id in version_ids\n    }\n    repre_states_by_version_id = defaultdict(list)\n    for repre_state in repre_states:\n        version_id = repre_state[\"versionId\"]\n        repre_states_by_version_id[version_id].append(repre_state)\n\n    for version_id, repre_states in repre_states_by_version_id.items():\n        repre_info = repre_info_by_version_id[version_id]\n        repre_info[\"repre_count\"] = len(repre_states)\n        repre_info[\"avail_repre_local\"] = sum(\n            self._is_available(repre_state, \"localStatus\")\n            for repre_state in repre_states\n        )\n        repre_info[\"avail_repre_remote\"] = sum(\n            self._is_available(repre_state, \"remoteStatus\")\n            for repre_state in repre_states\n        )\n\n    return list(repre_info_by_version_id.values())\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_repre_sync_state","title":"<code>get_repre_sync_state(project_name, representation_id, local_site_name, remote_site_name=None, **kwargs)</code>","text":"<p>Use server endpoint to get synchronization info for representation.</p> Warning <p>Logic of this</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_repre_sync_state(\n    self,\n    project_name,\n    representation_id,\n    local_site_name,\n    remote_site_name=None,\n    **kwargs\n):\n    \"\"\"Use server endpoint to get synchronization info for representation.\n\n    Warning:\n        Logic of this\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        local_site_name (str)\n        remote_site_name (str)\n        all other parameters for `Get Site Sync State` endpoint if\n            necessary\n\n    \"\"\"\n    repre_states = self._get_repres_state(\n        project_name,\n        {representation_id},\n        local_site_name,\n        remote_site_name,\n        **kwargs\n    )\n    if repre_states:\n        repre_state = repre_states[0]\n        if repre_state[\"localStatus\"][\"status\"] != -1:\n            return repre_state\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_representations_sync_state","title":"<code>get_representations_sync_state(project_name, representation_ids, local_site_name, remote_site_name=None, **kwargs)</code>","text":"<p>Use server endpoint to get synchronization info for representations.</p> <p>Calculates float progress based on progress of all files for repre. If repre is fully synchronized it returns 1, 0 for any other state.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> required <code>representation_ids</code> <code>list</code> <p>even single repre should be in []</p> required <p>Returns:</p> Type Description <p>dict[str, tuple[float, float]]: Progress by representation id.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_representations_sync_state(\n    self,\n    project_name,\n    representation_ids,\n    local_site_name,\n    remote_site_name=None,\n    **kwargs\n):\n    \"\"\"Use server endpoint to get synchronization info for representations.\n\n    Calculates float progress based on progress of all files for repre.\n    If repre is fully synchronized it returns 1, 0 for any other state.\n\n    Args:\n        project_name (str):\n        representation_ids (list): even single repre should be in []\n        local_site_name (str)\n        remote_site_name (str)\n        all other parameters for `Get Site Sync State` endpoint if\n            necessary.\n\n    Returns:\n        dict[str, tuple[float, float]]: Progress by representation id.\n\n    \"\"\"\n    repre_states = self._get_repres_state(\n        project_name,\n        representation_ids,\n        local_site_name,\n        remote_site_name,\n        **kwargs\n    )\n    states = {}\n    for repre_state in repre_states:\n        repre_files_count = len(repre_state[\"files\"])\n\n        repre_local_status = repre_state[\"localStatus\"][\"status\"]\n        repre_local_progress = 0\n        if repre_local_status == SiteSyncStatus.OK:\n            repre_local_progress = 1\n        elif repre_local_status == SiteSyncStatus.IN_PROGRESS:\n            local_sum = sum(\n                file_info[\"localStatus\"].get(\"progress\", 0)\n                for file_info in repre_state[\"files\"]\n            )\n            repre_local_progress = local_sum / repre_files_count\n\n        repre_remote_status = repre_state[\"remoteStatus\"][\"status\"]\n        repre_remote_progress = 0\n        if repre_remote_status == SiteSyncStatus.OK:\n            repre_remote_progress = 1\n        elif repre_remote_status == SiteSyncStatus.IN_PROGRESS:\n            remote_sum = sum(\n                file_info[\"remoteStatus\"].get(\"progress\", 0)\n                for file_info in repre_state[\"files\"]\n            )\n            repre_remote_progress = remote_sum / repre_files_count\n\n        states[repre_state[\"representationId\"]] = (\n            repre_local_progress,\n            repre_remote_progress\n        )\n\n    return states\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_site_icons","title":"<code>get_site_icons()</code>","text":"<p>Icons for sites.</p> <p>Returns:</p> Type Description <p>dict[str, str]: Path to icon by site.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_site_icons(self):\n    \"\"\"Icons for sites.\n\n    Returns:\n        dict[str, str]: Path to icon by site.\n\n    \"\"\"\n    resource_path = os.path.join(\n        SYNC_ADDON_DIR, \"providers\", \"resources\"\n    )\n    icons = {}\n    for file_path in os.listdir(resource_path):\n        if not file_path.endswith(\".png\"):\n            continue\n        provider_name, _ = os.path.splitext(os.path.basename(file_path))\n        icons[provider_name] = {\n            \"type\": \"path\",\n            \"path\": os.path.join(resource_path, file_path)\n        }\n    return icons\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_site_root_overrides","title":"<code>get_site_root_overrides(project_name, site_name, local_settings=None)</code>","text":"<p>Get root overrides for project on a site.</p> <p>Implemented to be used in 'Anatomy' for other than 'studio' site.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project for which root overrides should be received.</p> required <code>site_name</code> <code>str</code> <p>Name of site for which should be received roots.</p> required <code>local_settings</code> <code>Optional[dict[str, Any]]</code> <p>Prepare local settigns values.</p> <code>None</code> <p>Returns:</p> Type Description <p>Union[dict[str, Any], None]: Root overrides for this machine.</p> <p>{\"work\": \"c:/projects_local\"}</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_site_root_overrides(\n    self, project_name, site_name, local_settings=None\n):\n    \"\"\"Get root overrides for project on a site.\n\n    Implemented to be used in 'Anatomy' for other than 'studio' site.\n\n    Args:\n        project_name (str): Project for which root overrides should be\n            received.\n        site_name (str): Name of site for which should be received roots.\n        local_settings (Optional[dict[str, Any]]): Prepare local settigns\n            values.\n\n    Returns:\n        Union[dict[str, Any], None]: Root overrides for this machine.\n\n        {\"work\": \"c:/projects_local\"}\n    \"\"\"\n\n    # Validate that site name is valid\n    if site_name not in (\"studio\", \"local\"):\n        # Consider local site id as 'local'\n        if site_name != get_local_site_id():\n            raise ValueError((\n                \"Root overrides are available only for\"\n                \" default sites not for \\\"{}\\\"\"\n            ).format(site_name))\n        site_name = \"local\"\n\n    sitesync_settings = self.get_sync_project_setting(project_name)\n\n    roots = {}\n    if not sitesync_settings[\"enabled\"]:\n        return roots\n    local_project_settings = sitesync_settings[\"local_setting\"]\n    if site_name == \"local\":\n        for root_info in local_project_settings[\"local_roots\"]:\n            roots[root_info[\"name\"]] = root_info[\"path\"]\n\n    return roots\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_sync_project_setting","title":"<code>get_sync_project_setting(project_name, exclude_locals=False, cached=True)</code>","text":"<p>Handles pulling sitesync's settings for enabled 'project_name'</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>used in project settings</p> required <code>exclude_locals</code> <code>bool</code> <p>ignore overrides from Local Settings</p> <code>False</code> <code>cached</code> <code>bool</code> <p>use pre-cached values, or return fresh ones cached values needed for single loop (with all overrides) fresh values needed for Local settings (without overrides)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>settings dictionary for the enabled project, empty if no settings or sync is disabled</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_sync_project_setting(\n    self, project_name, exclude_locals=False, cached=True\n):\n    \"\"\" Handles pulling sitesync's settings for enabled 'project_name'\n\n    Args:\n        project_name (str): used in project settings\n        exclude_locals (bool): ignore overrides from Local Settings\n        cached (bool): use pre-cached values, or return fresh ones\n            cached values needed for single loop (with all overrides)\n            fresh values needed for Local settings (without overrides)\n\n    Returns:\n        dict: settings dictionary for the enabled project,\n            empty if no settings or sync is disabled\n\n    \"\"\"\n    # presets set already, do not call again and again\n    # self.log.debug(\"project preset {}\".format(self.presets))\n    if not cached:\n        return self._prepare_sync_project_settings(exclude_locals)\\\n            [project_name]\n\n    if (\n        not self.sync_project_settings\n        or not self.sync_project_settings.get(project_name)\n    ):\n        self.set_sync_project_settings(exclude_locals)\n    return self.sync_project_settings.get(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_sync_representations","title":"<code>get_sync_representations(project_name, active_site, remote_site, limit=10)</code>","text":"<pre><code>Get representations that should be synced, these could be\nrecognised by presence of document in 'files.sites', where key is\na provider (GDrive, S3) and value is empty document or document\nwithout 'created_dt' field. (Don't put null to 'created_dt'!).\n\nQuerying of 'to-be-synched' files is offloaded to Mongod for\nbetter performance. Goal is to get as few representations as\npossible.\n</code></pre> <p>Args:     project_name (str):     active_site (str): identifier of current active site (could be         'local_0' when working from home, 'studio' when working in the         studio (default)     remote_site (str): identifier of remote site I want to sync to</p> <p>Returns:</p> Type Description <p>list[dict]: Representation states.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>@time_function\ndef get_sync_representations(\n    self, project_name, active_site, remote_site, limit=10\n):\n    \"\"\"\n        Get representations that should be synced, these could be\n        recognised by presence of document in 'files.sites', where key is\n        a provider (GDrive, S3) and value is empty document or document\n        without 'created_dt' field. (Don't put null to 'created_dt'!).\n\n        Querying of 'to-be-synched' files is offloaded to Mongod for\n        better performance. Goal is to get as few representations as\n        possible.\n    Args:\n        project_name (str):\n        active_site (str): identifier of current active site (could be\n            'local_0' when working from home, 'studio' when working in the\n            studio (default)\n        remote_site (str): identifier of remote site I want to sync to\n\n    Returns:\n        list[dict]: Representation states.\n\n    \"\"\"\n    self.log.debug(\"Check representations for: {}-{}\".format(\n        active_site, remote_site\n    ))\n\n    endpoint = \"{}/{}/state\".format(\n        self.endpoint_prefix, project_name\n    )\n\n    # get to upload\n    kwargs = {\n        \"localSite\": active_site,\n        \"remoteSite\": remote_site,\n        \"localStatusFilter\": [SiteSyncStatus.OK],\n        \"remoteStatusFilter\": [SiteSyncStatus.QUEUED],\n    }\n\n    response = ayon_api.get(endpoint, **kwargs)\n    if response.status_code not in [200, 204]:\n        raise RuntimeError(\n            \"Cannot get representations for sync with code {}\".format(\n                response.status_code\n            )\n        )\n\n    repre_states = response.data[\"representations\"]\n\n    # get to download\n    if len(repre_states) &lt; limit:\n        kwargs[\"localStatusFilter\"] = [SiteSyncStatus.QUEUED]\n        kwargs[\"remoteStatusFilter\"] = [SiteSyncStatus.OK]\n\n        response = ayon_api.get(endpoint, **kwargs)\n        repre_states.extend(response.data[\"representations\"])\n\n    return repre_states\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.get_version_availability","title":"<code>get_version_availability(project_name, version_ids, local_site_name, remote_site_name, **kwargs)</code>","text":"<p>Returns aggregated state for version ids.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>version_ids</code> <code>Iterable[str]</code> <p>Version ids.</p> required <code>local_site_name</code> <code>str</code> <p>Local site name.</p> required <code>remote_site_name</code> <code>str</code> <p>Remote site name.</p> required <code>kwargs</code> <p>All other parameters for <code>Get Site Sync State</code> endpoint if necessary.</p> <code>{}</code> <p>Returns:</p> Type Description <p>dict[str, tuple[float, float]]: Status by version id. Example: {version_id: (local_status, remote_status)}</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_version_availability(\n    self,\n    project_name,\n    version_ids,\n    local_site_name,\n    remote_site_name,\n    **kwargs\n):\n    \"\"\"Returns aggregated state for version ids.\n\n    Args:\n        project_name (str): Project name.\n        version_ids (Iterable[str]): Version ids.\n        local_site_name (str): Local site name.\n        remote_site_name (str): Remote site name.\n        kwargs: All other parameters for `Get Site Sync State` endpoint if\n            necessary.\n\n    Returns:\n        dict[str, tuple[float, float]]: Status by version id.\n            Example: {version_id: (local_status, remote_status)}\n\n    \"\"\"\n    version_ids = list(version_ids)\n    payload_dict = {\n        \"localSite\": local_site_name,\n        \"remoteSite\": remote_site_name,\n        \"versionIdsFilter\": version_ids\n    }\n    payload_dict.update(kwargs)\n\n    endpoint = \"{}/{}/state\".format(\n        self.endpoint_prefix, project_name\n    )\n\n    response = ayon_api.get(endpoint, **payload_dict)\n    if response.status_code != 200:\n        raise RuntimeError(\n            \"Cannot get sync state for versions {}\".format(\n                version_ids\n            )\n        )\n\n    version_statuses = {\n        version_id: (0, 0)\n        for version_id in version_ids\n    }\n\n    repre_avail_by_version_id = defaultdict(list)\n    for repre_avail in response.data[\"representations\"]:\n        version_id = repre_avail[\"versionId\"]\n        repre_avail_by_version_id[version_id].append(repre_avail)\n\n    for version_id, repre_avails in repre_avail_by_version_id.items():\n        avail_local = sum(\n            int(\n                repre_avail[\"localStatus\"][\"status\"] == SiteSyncStatus.OK\n            )\n            for repre_avail in repre_avails\n        )\n        avail_remote = sum(\n            int(\n                repre_avail[\"remoteStatus\"][\"status\"] == SiteSyncStatus.OK\n            )\n            for repre_avail in repre_avails\n        )\n        version_statuses[version_id] = (avail_local, avail_remote)\n\n    return version_statuses\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.handle_alternate_site","title":"<code>handle_alternate_site(project_name, representation_id, processed_site, file_id)</code>","text":"<p>For special use cases where one site vendors another.</p> <p>Current use case is sftp site vendoring (exposing) same data as regular site (studio). Each site is accessible for different audience. 'studio' for artists in a studio, 'sftp' for externals.</p> <p>Change of file status on one site actually means same change on 'alternate' site. (eg. artists publish to 'studio', 'sftp' is using same location &gt;&gt; file is accessible on 'sftp' site right away.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>processed_site</code> <code>str</code> <p>Real site_name of published/uploaded file</p> required <code>file_id</code> <code>str</code> <p>File id of file handled.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def handle_alternate_site(\n    self, project_name, representation_id, processed_site, file_id\n):\n    \"\"\"\n    For special use cases where one site vendors another.\n\n    Current use case is sftp site vendoring (exposing) same data as\n    regular site (studio). Each site is accessible for different\n    audience. 'studio' for artists in a studio, 'sftp' for externals.\n\n    Change of file status on one site actually means same change on\n    'alternate' site. (eg. artists publish to 'studio', 'sftp' is using\n    same location &gt;&gt; file is accessible on 'sftp' site right away.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        processed_site (str): Real site_name of published/uploaded file\n        file_id (str): File id of file handled.\n\n    \"\"\"\n    sites = self._transform_sites_from_settings(self.sync_studio_settings)\n    sites[self.DEFAULT_SITE] = {\n        \"provider\": \"local_drive\",\n        \"alternative_sites\": []\n    }\n\n    alternate_sites = []\n    for site_name, site_info in sites.items():\n        conf_alternative_sites = site_info.get(\"alternative_sites\", [])\n        if processed_site in conf_alternative_sites:\n            alternate_sites.append(site_name)\n            continue\n        if processed_site == site_name and conf_alternative_sites:\n            alternate_sites.extend(conf_alternative_sites)\n            continue\n\n    if not alternate_sites:\n        return\n\n    sync_state = self.get_repre_sync_state(\n        project_name,\n        representation_id,\n        processed_site\n    )\n    # not yet available on processed_site, wont update alternate site yet\n    if not sync_state:\n        return\n    for file_info in sync_state[\"files\"]:\n        # expose status of remote site, it is expected on the server\n        file_info[\"status\"] = file_info[\"remoteStatus\"][\"status\"]\n\n    payload_dict = {\"files\": sync_state[\"files\"]}\n\n    alternate_sites = set(alternate_sites)\n    for alt_site in alternate_sites:\n        self.log.debug(\"Adding alternate {} to {}\".format(\n            alt_site, representation_id))\n\n        self._set_state_sync_state(\n            project_name,\n            representation_id,\n            alt_site,\n            payload_dict\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.initialize","title":"<code>initialize(addon_settings)</code>","text":"<p>Called during Addon Manager creation.</p> <p>Collects needed data, checks asyncio presence. Sets 'enabled' according to global settings for the addon. Shouldn't be doing any initialization, that's a job for 'tray_init'</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def initialize(self, addon_settings):\n    \"\"\"Called during Addon Manager creation.\n\n    Collects needed data, checks asyncio presence.\n    Sets 'enabled' according to global settings for the addon.\n    Shouldn't be doing any initialization, that's a job for 'tray_init'\n    \"\"\"\n\n    # some parts of code need to run sequentially, not in async\n    self.lock = None\n    self._sync_studio_settings = None\n    # settings for all enabled projects for sync\n    self._sync_project_settings = None\n    self.sitesync_thread = None  # asyncio requires new thread\n\n    self._paused = False\n    self._paused_projects = set()\n    self._paused_representations = set()\n    self._anatomies = {}\n\n    # list of long blocking tasks\n    self.long_running_tasks = deque()\n    # projects that long tasks are running on\n    self.projects_processed = set()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.is_paused","title":"<code>is_paused()</code>","text":"<p>Is server paused</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_paused(self):\n    \"\"\" Is server paused \"\"\"\n    return self._paused\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.is_project_enabled","title":"<code>is_project_enabled(project_name, single=False)</code>","text":"<p>Checks if 'project_name' is enabled for syncing. 'get_sync_project_setting' is potentially expensive operation (pulls settings for all projects if cached version is not available), using project_settings for specific project should be faster. Args:     project_name (str)     single (bool): use 'get_addon_project_settings' method</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_project_enabled(self, project_name, single=False):\n    \"\"\"Checks if 'project_name' is enabled for syncing.\n    'get_sync_project_setting' is potentially expensive operation (pulls\n    settings for all projects if cached version is not available), using\n    project_settings for specific project should be faster.\n    Args:\n        project_name (str)\n        single (bool): use 'get_addon_project_settings' method\n    \"\"\"\n    if self.enabled:\n        if single:\n            project_settings = get_addon_project_settings(\n                self.name, self.version, project_name\n            )\n        else:\n            project_settings = self.get_sync_project_setting(project_name)\n        if project_settings and project_settings.get(\"enabled\"):\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.is_project_paused","title":"<code>is_project_paused(project_name, check_parents=False)</code>","text":"<p>Is project sync paused.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> required <code>check_parents</code> <code>bool</code> <p>check if server itself is not paused</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is project paused.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_project_paused(self, project_name, check_parents=False):\n    \"\"\"Is project sync paused.\n\n    Args:\n        project_name (str):\n        check_parents (bool): check if server itself\n            is not paused\n\n    Returns:\n        bool: Is project paused.\n\n    \"\"\"\n    is_paused = project_name in self._paused_projects\n    if check_parents:\n        is_paused = is_paused or self.is_paused()\n    return is_paused\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.is_representation_on_site","title":"<code>is_representation_on_site(project_name, representation_id, site_name, max_retries=None)</code>","text":"<p>Check if representation has all files available on site.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if representation has all files correctly on the site.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_representation_on_site(\n    self, project_name, representation_id, site_name, max_retries=None\n):\n    \"\"\"Check if representation has all files available on site.\n\n    Args:\n        project_name (str)\n        representation_id (str)\n        site_name (str)\n        max_retries (int) (optional) - provide only if method used in while\n            loop to bail out\n\n    Returns:\n        bool: True if representation has all files correctly on the site.\n\n    Raises:\n          ValueError  Only If 'max_retries' provided if upload/download\n            failed too many times to limit infinite loop check.\n\n    \"\"\"\n    representation_status = self.get_repre_sync_state(\n        project_name, representation_id, site_name)\n    if not representation_status:\n        return False\n\n    if site_name == get_local_site_id():\n        status = representation_status[\"localStatus\"]\n    else:\n        status = representation_status[\"remoteStatus\"]\n\n    if max_retries:\n        tries = status.get(\"retries\", 0)\n        if tries &gt;= max_retries:\n            raise ValueError(\"Failed too many times\")\n\n    return status[\"status\"] == SiteSyncStatus.OK\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.is_representation_paused","title":"<code>is_representation_paused(representation_id, check_parents=False, project_name=None)</code>","text":"<p>Is representation paused.</p> <p>Parameters:</p> Name Type Description Default <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>check_parents</code> <code>bool</code> <p>Check if parent project or server itself are not paused.</p> <code>False</code> <code>project_name</code> <code>str</code> <p>Project to check if paused.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is representation paused now.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_representation_paused(\n    self, representation_id, check_parents=False, project_name=None\n):\n    \"\"\"Is representation paused.\n\n    Args:\n        representation_id (str): Representation id.\n        check_parents (bool): Check if parent project or server itself\n            are not paused.\n        project_name (str): Project to check if paused.\n\n        if 'check_parents', 'project_name' should be set too\n\n    Returns:\n        bool: Is representation paused now.\n\n    \"\"\"\n    is_paused = representation_id in self._paused_representations\n    if check_parents and project_name:\n        is_paused = (\n            is_paused\n            or self.is_project_paused(project_name)\n            or self.is_paused()\n        )\n    return is_paused\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.pause_project","title":"<code>pause_project(project_name)</code>","text":"<p>Pause sync of whole project.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def pause_project(self, project_name):\n    \"\"\"Pause sync of whole project.\n\n    Args:\n        project_name (str): Project name.\n\n    \"\"\"\n    self.log.info(\"Pausing SiteSync for {}\".format(project_name))\n    self._paused_projects.add(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.pause_representation","title":"<code>pause_representation(project_name, representation_id, site_name)</code>","text":"<p>Pause sync of representation entity on site.</p> <p>Sets 'representation_id' as paused, eg. no syncing should be     happening on it.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>site_name</code> <code>str</code> <p>Site name 'gdrive', 'studio' etc.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def pause_representation(\n    self, project_name, representation_id, site_name\n):\n    \"\"\"Pause sync of representation entity on site.\n\n    Sets 'representation_id' as paused, eg. no syncing should be\n        happening on it.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        site_name (str): Site name 'gdrive', 'studio' etc.\n\n    \"\"\"\n    self.log.info(\"Pausing SiteSync for {}\".format(representation_id))\n    self._paused_representations.add(representation_id)\n    repre_entity = get_representation_by_id(\n        project_name, representation_id\n    )\n    self.update_db(project_name, repre_entity, site_name, pause=True)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.pause_server","title":"<code>pause_server()</code>","text":"<p>Pause sync server.</p> <p>It won't check anything, not uploading/downloading...</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def pause_server(self):\n    \"\"\"Pause sync server.\n\n    It won't check anything, not uploading/downloading...\n    \"\"\"\n    self.log.info(\"Pausing SiteSync\")\n    self._paused = True\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.remove_site","title":"<code>remove_site(project_name, representation_id, site_name, remove_local_files=False)</code>","text":"<p>Removes site for particular representation in project.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>project name (must match DB)</p> required <code>representation_id</code> <code>str</code> <p>MongoDB _id value</p> required <code>site_name</code> <code>str</code> <p>name of configured and active site</p> required <code>remove_local_files</code> <code>bool</code> <p>remove only files for 'local_id' site</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Throws if any issue.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def remove_site(\n    self,\n    project_name,\n    representation_id,\n    site_name,\n    remove_local_files=False\n):\n    \"\"\"Removes site for particular representation in project.\n\n    Args:\n        project_name (str): project name (must match DB)\n        representation_id (str): MongoDB _id value\n        site_name (str): name of configured and active site\n        remove_local_files (bool): remove only files for 'local_id'\n            site\n\n    Raises:\n        ValueError: Throws if any issue.\n\n    \"\"\"\n    if not self.get_sync_project_setting(project_name):\n        raise ValueError(\"Project not configured\")\n\n    sync_info = self.get_repre_sync_state(\n        project_name,\n        representation_id,\n        site_name\n    )\n    if not sync_info:\n        msg = \"Site {} not found\".format(site_name)\n        self.log.warning(msg)\n        return\n\n    endpoint = \"{}/{}/state/{}/{}\".format(\n        self.endpoint_prefix,\n        project_name,\n        representation_id,\n        site_name\n    )\n\n    response = ayon_api.delete(endpoint)\n    if response.status_code not in [200, 204]:\n        raise RuntimeError(\"Cannot update status\")\n\n    if remove_local_files:\n        self._remove_local_file(project_name, representation_id, site_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.reset_site_on_representation","title":"<code>reset_site_on_representation(project_name, representation_id, side=None, file_id=None, site_name=None)</code>","text":"<pre><code>Reset information about synchronization for particular 'file_id'\nand provider.\nUseful for testing or forcing file to be reuploaded.\n\n'side' and 'site_name' are disjunctive.\n\n'side' is used for resetting local or remote side for\ncurrent user for repre.\n\n'site_name' is used to set synchronization for particular site.\nShould be used when repre should be synced to new site.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of project (eg. collection) in DB</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>file_id</code> <code>str</code> <p>File id in representation.</p> <code>None</code> <code>side</code> <code>str</code> <p>Local or remote side.</p> <code>None</code> <code>site_name</code> <code>str</code> <p>for adding new site</p> <code>None</code> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def reset_site_on_representation(\n    self,\n    project_name,\n    representation_id,\n    side=None,\n    file_id=None,\n    site_name=None\n):\n    \"\"\"\n        Reset information about synchronization for particular 'file_id'\n        and provider.\n        Useful for testing or forcing file to be reuploaded.\n\n        'side' and 'site_name' are disjunctive.\n\n        'side' is used for resetting local or remote side for\n        current user for repre.\n\n        'site_name' is used to set synchronization for particular site.\n        Should be used when repre should be synced to new site.\n\n    Args:\n        project_name (str): name of project (eg. collection) in DB\n        representation_id (str): Representation id.\n        file_id (str): File id in representation.\n        side (str): Local or remote side.\n        site_name (str): for adding new site\n\n    Raises:\n        SiteAlreadyPresentError - if adding already existing site and\n            not 'force'\n        ValueError - other errors (repre not found, misconfiguration)\n    \"\"\"\n    representation = get_representation_by_id(\n        project_name, representation_id\n    )\n    if not representation:\n        raise ValueError(\n            \"Representation {} not found in {}\".format(\n                representation_id, project_name\n            )\n        )\n\n    if side and site_name:\n        raise ValueError(\n            \"Misconfiguration, only one of side and\"\n            \" site_name arguments should be passed.\"\n        )\n\n    if side:\n        if side == \"local\":\n            site_name = self.get_active_site(project_name)\n        else:\n            site_name = self.get_remote_site(project_name)\n\n    self.add_site(\n        project_name, representation_id, site_name, file_id, force=True\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.reset_timer","title":"<code>reset_timer()</code>","text":"<p>Called when waiting for next loop should be skipped.</p> <p>In case of user's involvement (reset site), start that right away.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def reset_timer(self):\n    \"\"\"\n        Called when waiting for next loop should be skipped.\n\n        In case of user's involvement (reset site), start that right away.\n    \"\"\"\n\n    if not self.enabled:\n        return\n\n    if self.sitesync_thread is None:\n        self._reset_timer_with_rest_api()\n    else:\n        self.sitesync_thread.reset_timer()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.server_init","title":"<code>server_init()</code>","text":"<p>Actual initialization of Sync Server.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def server_init(self):\n    \"\"\"Actual initialization of Sync Server.\"\"\"\n    # import only in tray or Python3, because of Python2 hosts\n    if not self.enabled:\n        return\n\n    from .sitesync import SiteSyncThread\n\n    self.lock = threading.Lock()\n\n    self.sitesync_thread = SiteSyncThread(self)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.set_sync_project_settings","title":"<code>set_sync_project_settings(exclude_locals=False)</code>","text":"<p>Set sync_project_settings for all projects (caching) Args:     exclude_locals (bool): ignore overrides from Local Settings For performance</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def set_sync_project_settings(self, exclude_locals=False):\n    \"\"\"\n        Set sync_project_settings for all projects (caching)\n        Args:\n            exclude_locals (bool): ignore overrides from Local Settings\n        For performance\n    \"\"\"\n    sync_project_settings = self._prepare_sync_project_settings(\n        exclude_locals)\n\n    self._sync_project_settings = sync_project_settings\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.tray_exit","title":"<code>tray_exit()</code>","text":"<p>Stops sync thread if running.</p> <p>Called from Addon Manager</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def tray_exit(self):\n    \"\"\"Stops sync thread if running.\n\n    Called from Addon Manager\n    \"\"\"\n    self.server_exit()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.tray_init","title":"<code>tray_init()</code>","text":"<p>Initialization of Site Sync Server for Tray.</p> <p>Called when tray is initialized, it checks if addon should be enabled. If not, no initialization necessary.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def tray_init(self):\n    \"\"\"Initialization of Site Sync Server for Tray.\n\n    Called when tray is initialized, it checks if addon should be\n    enabled. If not, no initialization necessary.\n    \"\"\"\n    self.server_init()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.tray_start","title":"<code>tray_start()</code>","text":"<p>Triggered when Tray is started.</p> <p>Checks if configuration presets are available and if there is any provider ('gdrive', 'S3') that is activated (eg. has valid credentials).</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def tray_start(self):\n    \"\"\"Triggered when Tray is started.\n\n    Checks if configuration presets are available and if there is\n    any provider ('gdrive', 'S3') that is activated\n    (eg. has valid credentials).\n    \"\"\"\n    self.server_start()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.unpause_project","title":"<code>unpause_project(project_name)</code>","text":"<p>Unpause sync of whole project.</p> <p>Does not fail or warn if project wasn't paused.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def unpause_project(self, project_name):\n    \"\"\"Unpause sync of whole project.\n\n    Does not fail or warn if project wasn't paused.\n\n    Args:\n        project_name (str): Project name.\n\n    \"\"\"\n    self.log.info(\"Unpausing SiteSync for {}\".format(project_name))\n    try:\n        self._paused_projects.remove(project_name)\n    except KeyError:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.unpause_representation","title":"<code>unpause_representation(project_name, representation_id, site_name)</code>","text":"<p>Unpause sync of representation entity on site.</p> <p>Does not fail or warn if repre wasn't paused.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>site_name</code> <code>str</code> <p>Site name 'gdrive', 'studio' etc.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def unpause_representation(\n    self, project_name, representation_id, site_name\n):\n    \"\"\"Unpause sync of representation entity on site.\n\n    Does not fail or warn if repre wasn't paused.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        site_name (str): Site name 'gdrive', 'studio' etc.\n    \"\"\"\n    self.log.info(\"Unpausing SiteSync for {}\".format(representation_id))\n    try:\n        self._paused_representations.remove(representation_id)\n    except KeyError:\n        pass\n    # self.paused_representations is not persistent\n    repre_entity = get_representation_by_id(\n        project_name, representation_id\n    )\n    self.update_db(project_name, repre_entity, site_name, pause=False)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.unpause_server","title":"<code>unpause_server()</code>","text":"<p>Unpause server sync.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def unpause_server(self):\n    \"\"\"Unpause server sync.\"\"\"\n    self.log.info(\"Unpausing SiteSync\")\n    self._paused = False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.update_db","title":"<code>update_db(project_name, repre_status, site_name, new_file_id=None, file=None, side=None, error=None, progress=None, priority=None, pause=None)</code>","text":"<p>Update 'provider' portion of records in DB.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name. Force to db connection as each file might come from different collection.</p> required <code>repre_status</code> <code>dict</code> <p>Representation status from sitesync database.</p> required <code>site_name</code> <code>str</code> <p>Site name.</p> required <code>new_file_id</code> <code>Optional[str]</code> <p>File id of new file.</p> <code>None</code> <code>file</code> <code>dict[str, Any]</code> <p>info about processed file (pulled from DB)</p> <code>None</code> <code>side</code> <code>str</code> <p>'local' | 'remote'</p> <code>None</code> <code>error</code> <code>str</code> <p>exception message</p> <code>None</code> <code>progress</code> <code>float</code> <p>0-1 of progress of upload/download</p> <code>None</code> <code>priority</code> <code>int</code> <p>0-100 set priority</p> <code>None</code> <code>pause</code> <code>bool</code> <p>stop synchronizing (only before starting of download, upload)</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def update_db(\n    self,\n    project_name,\n    repre_status,\n    site_name,\n    new_file_id=None,\n    file=None,\n    side=None,\n    error=None,\n    progress=None,\n    priority=None,\n    pause=None\n):\n    \"\"\"Update 'provider' portion of records in DB.\n\n    Args:\n        project_name (str): Project name. Force to db connection as\n            each file might come from different collection.\n        repre_status (dict): Representation status from sitesync database.\n        site_name (str): Site name.\n        new_file_id (Optional[str]): File id of new file.\n        file (dict[str, Any]): info about processed file (pulled from DB)\n        side (str): 'local' | 'remote'\n        error (str): exception message\n        progress (float): 0-1 of progress of upload/download\n        priority (int): 0-100 set priority\n        pause (bool): stop synchronizing (only before starting of download,\n            upload)\n\n    Returns:\n        None\n    \"\"\"\n    files_status = []\n    for file_status in repre_status[\"files\"]:\n        status_entity = copy.deepcopy(\n            file_status[\"{}Status\".format(side)]\n        )\n        status_entity[\"fileHash\"] = file_status[\"fileHash\"]\n        status_entity[\"id\"] = file_status[\"id\"]\n        if file_status[\"fileHash\"] == file[\"fileHash\"]:\n            if new_file_id:\n                status_entity[\"status\"] = SiteSyncStatus.OK\n                status_entity.pop(\"message\")\n                status_entity.pop(\"retries\")\n            elif progress is not None:\n                status_entity[\"status\"] = SiteSyncStatus.IN_PROGRESS\n                status_entity[\"progress\"] = progress\n            elif error:\n                max_retries = int(\n                    self.sync_project_settings\n                    [project_name]\n                    [\"config\"]\n                    [\"retry_cnt\"]\n                )\n                tries = status_entity.get(\"retries\", 0)\n                tries += 1\n                status_entity[\"retries\"] = tries\n                status_entity[\"message\"] = error\n                if tries &gt;= max_retries:\n                    status_entity[\"status\"] = SiteSyncStatus.FAILED\n            elif pause is not None:\n                if pause:\n                    status_entity[\"pause\"] = True\n                else:\n                    status_entity.remove(\"pause\")\n            files_status.append(status_entity)\n\n    representation_id = repre_status[\"representationId\"]\n\n    endpoint = \"{}/{}/state/{}/{}\".format(\n        self.endpoint_prefix,\n        project_name,\n        representation_id,\n        site_name)\n\n    # get to upload\n    kwargs = {\n        \"files\": files_status\n    }\n\n    if priority:\n        kwargs[\"priority\"] = priority\n\n    response = ayon_api.post(endpoint, **kwargs)\n    if response.status_code not in [200, 204]:\n        raise RuntimeError(\"Cannot update status\")\n\n    if progress is not None or priority is not None:\n        return\n\n    status = \"failed\"\n    error_str = \"with error {}\".format(error)\n    if new_file_id:\n        status = \"succeeded with id {}\".format(new_file_id)\n        error_str = \"\"\n\n    source_file = file.get(\"path\", \"\")\n\n    self.log.debug(\n        \"File for {} - {source_file} process {status} {error_str}\".format(\n            representation_id,\n            status=status,\n            source_file=source_file,\n            error_str=error_str\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/index.html#client.ayon_sitesync.SiteSyncAddon.validate_project","title":"<code>validate_project(project_name, site_name, reset_missing=False)</code>","text":"<p>Validate 'project_name' of 'site_name' and its local files</p> <p>If file present and not marked with a 'site_name' in DB, DB is updated with site name and file modified date.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>project name</p> required <code>site_name</code> <code>str</code> <p>active site name</p> required <code>reset_missing</code> <code>bool</code> <p>if True reset site in DB if missing physically to be resynched</p> <code>False</code> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def validate_project(self, project_name, site_name, reset_missing=False):\n    \"\"\"Validate 'project_name' of 'site_name' and its local files\n\n    If file present and not marked with a 'site_name' in DB, DB is\n    updated with site name and file modified date.\n\n    Args:\n        project_name (str): project name\n        site_name (str): active site name\n        reset_missing (bool): if True reset site in DB if missing\n            physically to be resynched\n    \"\"\"\n    self.log.debug(\"Validation of {} for {} started\".format(\n        project_name, site_name\n    ))\n    repre_entities = list(get_representations(project_name))\n    if not repre_entities:\n        self.log.debug(\"No repre found\")\n        return\n\n    sites_added = 0\n    sites_reset = 0\n    repre_ids = [repre[\"id\"] for repre in repre_entities]\n    repre_states = self.get_representations_sync_state(\n        project_name, repre_ids, site_name, site_name)\n\n    for repre_entity in repre_entities:\n        repre_id = repre_entity[\"id\"]\n        is_on_site = False\n        repre_state = repre_states.get(repre_id)\n        if repre_state:\n            is_on_site = repre_state[0] == SiteSyncStatus.OK\n        for repre_file in repre_entity.get(\"files\", []):\n            file_path = repre_file.get(\"path\", \"\")\n            local_file_path = self.get_local_file_path(\n                project_name, site_name, file_path\n            )\n\n            file_exists = (\n                local_file_path and os.path.exists(local_file_path)\n            )\n            if not is_on_site:\n                if file_exists:\n                    self.log.debug(\n                        f\"Adding presence on site '{site_name}' for \"\n                        f\"'{repre_id}'\"\n                    )\n                    self.add_site(\n                        project_name,\n                        repre_id,\n                        site_name=site_name,\n                        file_id=repre_file[\"id\"],\n                        force=True,\n                        status=SiteSyncStatus.OK\n                    )\n                    sites_added += 1\n            else:\n                if not file_exists and reset_missing:\n                    self.log.debug(\n                        \"Resetting site {} for {}\".format(\n                            site_name, repre_id\n                        ))\n                    self.reset_site_on_representation(\n                        project_name,\n                        repre_id,\n                        site_name=site_name,\n                        file_id=repre_file[\"_id\"]\n                    )\n                    sites_reset += 1\n\n    if sites_added % 100 == 0:\n        self.log.debug(\"Sites added {}\".format(sites_added))\n\n    self.log.debug(\"Validation of {} for {} ended\".format(\n        project_name, site_name\n    ))\n    self.log.info(\"Sites added {}, sites reset {}\".format(\n        sites_added, reset_missing\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon","title":"<code>SiteSyncAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>ITrayAddon</code>, <code>IPluginPaths</code></p> <p>Addon handling sync of representation files between sites.</p> <p>Synchronization server that is syncing published files from local to any of implemented providers (like GDrive, S3 etc.) Runs in the background and checks all representations, looks for files that are marked to be in different location than 'studio' (temporary), checks if 'created_dt' field is present denoting successful sync with provider destination. Sites structure is created during publish OR by calling 'add_site' method.</p> <p>State of synchronization is being persisted on the server in <code>sitesync_files_status</code> table.</p> <p>By default it will always contain 1 record with \"name\" ==  self.presets[\"active_site\"] per representation_id with state of all its files</p> <p>Each Tray app has assigned its own  self.presets[\"local_id\"] used in sites as a name. Tray is searching only for records where name matches its self.presets[\"active_site\"] + self.presets[\"remote_site\"]. \"active_site\" could be storage in studio ('studio'), or specific \"local_id\" when user is working disconnected from home. If the local record has its \"created_dt\" filled, it is a source and process will try to upload the file to all defined remote sites.</p> <p>Remote files \"id\" is real id that could be used in appropriate API. Local files have \"id\" too, for conformity, contains just file name. It is expected that multiple providers will be implemented in separate classes and registered in 'providers.py'.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>class SiteSyncAddon(AYONAddon, ITrayAddon, IPluginPaths):\n    \"\"\"Addon handling sync of representation files between sites.\n\n    Synchronization server that is syncing published files from local to\n    any of implemented providers (like GDrive, S3 etc.)\n    Runs in the background and checks all representations, looks for files\n    that are marked to be in different location than 'studio' (temporary),\n    checks if 'created_dt' field is present denoting successful sync\n    with provider destination.\n    Sites structure is created during publish OR by calling 'add_site'\n    method.\n\n    State of synchronization is being persisted on the server\n    in `sitesync_files_status` table.\n\n    By default it will always contain 1 record with\n    \"name\" ==  self.presets[\"active_site\"] per representation_id with state\n    of all its files\n\n    Each Tray app has assigned its own  self.presets[\"local_id\"]\n    used in sites as a name.\n    Tray is searching only for records where name matches its\n    self.presets[\"active_site\"] + self.presets[\"remote_site\"].\n    \"active_site\" could be storage in studio ('studio'), or specific\n    \"local_id\" when user is working disconnected from home.\n    If the local record has its \"created_dt\" filled, it is a source and\n    process will try to upload the file to all defined remote sites.\n\n    Remote files \"id\" is real id that could be used in appropriate API.\n    Local files have \"id\" too, for conformity, contains just file name.\n    It is expected that multiple providers will be implemented in separate\n    classes and registered in 'providers.py'.\n\n    \"\"\"\n    # limit querying DB to look for X number of representations that should\n    # be sync, we try to run more loops with less records\n    # actual number of files synced could be lower as providers can have\n    # different limits imposed by its API\n    # set 0 to no limit\n    REPRESENTATION_LIMIT = 100\n    DEFAULT_SITE = \"studio\"\n    LOCAL_SITE = \"local\"\n    LOG_PROGRESS_SEC = 5  # how often log progress to DB\n    DEFAULT_PRIORITY = 50  # higher is better, allowed range 1 - 1000\n\n    name = \"sitesync\"\n    version = __version__\n\n    def initialize(self, addon_settings):\n        \"\"\"Called during Addon Manager creation.\n\n        Collects needed data, checks asyncio presence.\n        Sets 'enabled' according to global settings for the addon.\n        Shouldn't be doing any initialization, that's a job for 'tray_init'\n        \"\"\"\n\n        # some parts of code need to run sequentially, not in async\n        self.lock = None\n        self._sync_studio_settings = None\n        # settings for all enabled projects for sync\n        self._sync_project_settings = None\n        self.sitesync_thread = None  # asyncio requires new thread\n\n        self._paused = False\n        self._paused_projects = set()\n        self._paused_representations = set()\n        self._anatomies = {}\n\n        # list of long blocking tasks\n        self.long_running_tasks = deque()\n        # projects that long tasks are running on\n        self.projects_processed = set()\n\n    @property\n    def endpoint_prefix(self):\n        return \"addons/{}/{}\".format(self.name, self.version)\n\n    def get_plugin_paths(self):\n        return {\n            \"publish\": os.path.join(SYNC_ADDON_DIR, \"plugins\", \"publish\")\n        }\n\n    def get_site_icons(self):\n        \"\"\"Icons for sites.\n\n        Returns:\n            dict[str, str]: Path to icon by site.\n\n        \"\"\"\n        resource_path = os.path.join(\n            SYNC_ADDON_DIR, \"providers\", \"resources\"\n        )\n        icons = {}\n        for file_path in os.listdir(resource_path):\n            if not file_path.endswith(\".png\"):\n                continue\n            provider_name, _ = os.path.splitext(os.path.basename(file_path))\n            icons[provider_name] = {\n                \"type\": \"path\",\n                \"path\": os.path.join(resource_path, file_path)\n            }\n        return icons\n\n    def get_launch_hook_paths(self):\n        \"\"\"Implementation for applications launch hooks.\n\n        Returns:\n            str: full absolut path to directory with hooks for the addon\n\n        \"\"\"\n        return os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"launch_hooks\"\n        )\n\n    # --- Public API ---\n    def add_site(\n        self,\n        project_name,\n        representation_id,\n        site_name=None,\n        file_id=None,\n        force=False,\n        status=SiteSyncStatus.QUEUED\n    ):\n        \"\"\"Adds new site to representation to be synced.\n\n        'project_name' must have synchronization enabled (globally or\n        project only)\n\n        Used as a API endpoint from outside applications (Loader etc).\n\n        Use 'force' to reset existing site.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): Site name of configured site.\n            file_id (str): File id.\n            force (bool): Reset site if exists.\n            status (SiteSyncStatus): Current status,\n                default SiteSyncStatus.QUEUED\n\n        Raises:\n            SiteAlreadyPresentError: If adding already existing site and\n                not 'force'\n            ValueError: other errors (repre not found, misconfiguration)\n\n        \"\"\"\n        if not self.get_sync_project_setting(project_name):\n            raise ValueError(\"Project not configured\")\n\n        if not site_name:\n            site_name = self.DEFAULT_SITE\n\n        representation = get_representation_by_id(\n            project_name, representation_id\n        )\n\n        files = representation.get(\"files\", [])\n        if not files:\n            self.log.debug(\"No files for {}\".format(representation_id))\n            return\n\n        if not force:\n            existing = self.get_repre_sync_state(\n                project_name,\n                representation_id,\n                site_name\n            )\n            if existing:\n                failure = True\n                if file_id:\n                    file_exists = existing.get(\"files\", {}).get(file_id)\n                    if not file_exists:\n                        failure = False\n\n                if failure:\n                    msg = \"Site {} already present\".format(site_name)\n                    self.log.info(msg)\n                    raise SiteAlreadyPresentError(msg)\n\n        new_site_files = [\n            {\n                \"size\": repre_file[\"size\"],\n                \"status\": status,\n                \"timestamp\": datetime.now().timestamp(),\n                \"id\": repre_file[\"id\"],\n                \"fileHash\": repre_file[\"hash\"]\n            }\n            for repre_file in files\n        ]\n\n        payload_dict = {\"files\": new_site_files}\n        representation_id = representation_id.replace(\"-\", \"\")\n\n        self._set_state_sync_state(\n            project_name, representation_id, site_name, payload_dict\n        )\n\n    def remove_site(\n        self,\n        project_name,\n        representation_id,\n        site_name,\n        remove_local_files=False\n    ):\n        \"\"\"Removes site for particular representation in project.\n\n        Args:\n            project_name (str): project name (must match DB)\n            representation_id (str): MongoDB _id value\n            site_name (str): name of configured and active site\n            remove_local_files (bool): remove only files for 'local_id'\n                site\n\n        Raises:\n            ValueError: Throws if any issue.\n\n        \"\"\"\n        if not self.get_sync_project_setting(project_name):\n            raise ValueError(\"Project not configured\")\n\n        sync_info = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            site_name\n        )\n        if not sync_info:\n            msg = \"Site {} not found\".format(site_name)\n            self.log.warning(msg)\n            return\n\n        endpoint = \"{}/{}/state/{}/{}\".format(\n            self.endpoint_prefix,\n            project_name,\n            representation_id,\n            site_name\n        )\n\n        response = ayon_api.delete(endpoint)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\"Cannot update status\")\n\n        if remove_local_files:\n            self._remove_local_file(project_name, representation_id, site_name)\n\n    def compute_resource_sync_sites(self, project_name):\n        \"\"\"Get available resource sync sites state for publish process.\n\n        Returns dict with prepared state of sync sites for 'project_name'.\n        It checks if Site Sync is enabled, handles alternative sites.\n        Publish process stores this dictionary as a part of representation\n        document in DB.\n\n        Example:\n        [\n            {\n                'name': '42abbc09-d62a-44a4-815c-a12cd679d2d7',\n                'status': SiteSyncStatus.OK\n            },\n            {'name': 'studio', 'status': SiteSyncStatus.QUEUED},\n            {'name': 'SFTP', 'status': SiteSyncStatus.QUEUED}\n        ] -- representation is published locally, artist or Settings have set\n        remote site as 'studio'. 'SFTP' is alternate site to 'studio'. Eg.\n        whenever file is on 'studio', it is also on 'SFTP'.\n        \"\"\"\n\n        def create_metadata(name, created=True):\n            \"\"\"Create sync site metadata for site with `name`\"\"\"\n            if created:\n                status = SiteSyncStatus.OK\n            else:\n                status = SiteSyncStatus.QUEUED\n            return {\"name\": name, \"status\": status}\n\n        if (\n            not self.sync_studio_settings[\"enabled\"]\n            or not self.sync_project_settings[project_name][\"enabled\"]\n        ):\n            return [create_metadata(self.DEFAULT_SITE)]\n\n        local_site = self.get_active_site(project_name)\n        remote_site = self.get_remote_site(project_name)\n\n        # Attached sites metadata by site name\n        # That is the local site, remote site, the always accesible sites\n        # and their alternate sites (alias of sites with different protocol)\n        attached_sites = {\n            local_site: create_metadata(local_site)\n        }\n        if remote_site and remote_site not in attached_sites:\n            attached_sites[remote_site] = create_metadata(\n                remote_site, created=False\n            )\n\n        attached_sites = self._add_alternative_sites(\n            project_name, attached_sites)\n        # add skeleton for sites where it should be always synced to\n        # usually it would be a backup site which is handled by separate\n        # background process\n        for site_name in self._get_always_accessible_sites(project_name):\n            if site_name not in attached_sites:\n                attached_sites[site_name] = (\n                    create_metadata(site_name, created=False))\n        unique_sites = {\n            site[\"name\"]: site\n            for site in attached_sites.values()\n        }\n        return list(unique_sites.values())\n\n    def _get_always_accessible_sites(self, project_name):\n        \"\"\"Sites that synced to as a part of background process.\n\n        Artist machine doesn't handle those, explicit Tray with that site name\n        as a local id must be running.\n        Example is dropbox site serving as a backup solution\n\n        Returns:\n            (list[str]): list of site names\n        \"\"\"\n        sync_settings = self.get_sync_project_setting(project_name)\n        always_accessible_sites = (\n            sync_settings[\"config\"].get(\"always_accessible_on\", [])\n        )\n        return [site_name.strip() for site_name in always_accessible_sites]\n\n    def _add_alternative_sites(self, project_name, attached_sites):\n        \"\"\"Add skeleton document for alternative sites\n\n        Each new configured site in System Setting could serve as a alternative\n        site, it's a kind of alias. It means that files on 'a site' are\n        physically accessible also on 'a alternative' site.\n        Example is sftp site serving studio files via sftp protocol, physically\n        file is only in studio, sftp server has this location mounted.\n\n        Returns:\n            (dict[str, dict])\n        \"\"\"\n        sync_project_settings = self.get_sync_project_setting(project_name)\n        all_sites = sync_project_settings[\"sites\"]\n\n        alt_site_pairs = self._get_alt_site_pairs(all_sites)\n\n        for site_name in all_sites.keys():\n            # Get alternate sites (stripped names) for this site name\n            alt_sites = {\n                site.strip()\n                for site in alt_site_pairs.get(site_name)\n            }\n\n            # If no alternative sites we don't need to add\n            if not alt_sites:\n                continue\n\n            # Take a copy of data of the first alternate site that is already\n            # defined as an attached site to match the same state.\n            match_meta = next(\n                (\n                    attached_sites[site]\n                    for site in alt_sites\n                    if site in attached_sites\n                ),\n                None\n            )\n            if not match_meta:\n                continue\n\n            alt_site_meta = copy.deepcopy(match_meta)\n            alt_site_meta[\"name\"] = site_name\n\n            # Note: We change mutable `attached_site` dict in-place\n            attached_sites[site_name] = alt_site_meta\n\n        return attached_sites\n\n    def _get_alt_site_pairs(self, conf_sites):\n        \"\"\"Returns dict of site and its alternative sites.\n\n        If `site` has alternative site, it means that alt_site has 'site' as\n        alternative site\n\n        Args:\n            conf_sites (dict)\n\n        Returns:\n            dict[str, list[str]]: {'site': [alternative sites]...}\n\n        \"\"\"\n        alt_site_pairs = defaultdict(set)\n        for site_name, site_info in conf_sites.items():\n            alt_sites = set(site_info.get(\"alternative_sites\", []))\n            alt_site_pairs[site_name].update(alt_sites)\n\n            for alt_site in alt_sites:\n                alt_site_pairs[alt_site].add(site_name)\n\n        for site_name, alt_sites in alt_site_pairs.items():\n            sites_queue = deque(alt_sites)\n            while sites_queue:\n                alt_site = sites_queue.popleft()\n\n                # safety against wrong config\n                # {\"SFTP\": {\"alternative_site\": \"SFTP\"}\n                if alt_site == site_name or alt_site not in alt_site_pairs:\n                    continue\n\n                for alt_alt_site in alt_site_pairs[alt_site]:\n                    if (\n                        alt_alt_site != site_name\n                        and alt_alt_site not in alt_sites\n                    ):\n                        alt_sites.add(alt_alt_site)\n                        sites_queue.append(alt_alt_site)\n\n        return alt_site_pairs\n\n    def clear_project(self, project_name, site_name):\n        \"\"\"\n            Clear 'project_name' of 'site_name' and its local files\n\n            Works only on real local sites, not on 'studio'\n        \"\"\"\n\n        # TODO implement\n        self.log.warning(\"Method 'clear_project' is not implemented.\")\n\n        # query = {\n        #     \"type\": \"representation\",\n        #     \"files.sites.name\": site_name\n        # }\n        #\n        # # TODO currently not possible to replace with get_representations\n        # representations = list(\n        #     self.connection.database[project_name].find(query))\n        # if not representations:\n        #     self.log.debug(\"No repre found\")\n        #     return\n        #\n        # for repre in representations:\n        #     self.remove_site(project_name, repre.get(\"_id\"), site_name, True)\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def validate_project(self, project_name, site_name, reset_missing=False):\n        \"\"\"Validate 'project_name' of 'site_name' and its local files\n\n        If file present and not marked with a 'site_name' in DB, DB is\n        updated with site name and file modified date.\n\n        Args:\n            project_name (str): project name\n            site_name (str): active site name\n            reset_missing (bool): if True reset site in DB if missing\n                physically to be resynched\n        \"\"\"\n        self.log.debug(\"Validation of {} for {} started\".format(\n            project_name, site_name\n        ))\n        repre_entities = list(get_representations(project_name))\n        if not repre_entities:\n            self.log.debug(\"No repre found\")\n            return\n\n        sites_added = 0\n        sites_reset = 0\n        repre_ids = [repre[\"id\"] for repre in repre_entities]\n        repre_states = self.get_representations_sync_state(\n            project_name, repre_ids, site_name, site_name)\n\n        for repre_entity in repre_entities:\n            repre_id = repre_entity[\"id\"]\n            is_on_site = False\n            repre_state = repre_states.get(repre_id)\n            if repre_state:\n                is_on_site = repre_state[0] == SiteSyncStatus.OK\n            for repre_file in repre_entity.get(\"files\", []):\n                file_path = repre_file.get(\"path\", \"\")\n                local_file_path = self.get_local_file_path(\n                    project_name, site_name, file_path\n                )\n\n                file_exists = (\n                    local_file_path and os.path.exists(local_file_path)\n                )\n                if not is_on_site:\n                    if file_exists:\n                        self.log.debug(\n                            f\"Adding presence on site '{site_name}' for \"\n                            f\"'{repre_id}'\"\n                        )\n                        self.add_site(\n                            project_name,\n                            repre_id,\n                            site_name=site_name,\n                            file_id=repre_file[\"id\"],\n                            force=True,\n                            status=SiteSyncStatus.OK\n                        )\n                        sites_added += 1\n                else:\n                    if not file_exists and reset_missing:\n                        self.log.debug(\n                            \"Resetting site {} for {}\".format(\n                                site_name, repre_id\n                            ))\n                        self.reset_site_on_representation(\n                            project_name,\n                            repre_id,\n                            site_name=site_name,\n                            file_id=repre_file[\"_id\"]\n                        )\n                        sites_reset += 1\n\n        if sites_added % 100 == 0:\n            self.log.debug(\"Sites added {}\".format(sites_added))\n\n        self.log.debug(\"Validation of {} for {} ended\".format(\n            project_name, site_name\n        ))\n        self.log.info(\"Sites added {}, sites reset {}\".format(\n            sites_added, reset_missing\n        ))\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def pause_representation(\n        self, project_name, representation_id, site_name\n    ):\n        \"\"\"Pause sync of representation entity on site.\n\n        Sets 'representation_id' as paused, eg. no syncing should be\n            happening on it.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): Site name 'gdrive', 'studio' etc.\n\n        \"\"\"\n        self.log.info(\"Pausing SiteSync for {}\".format(representation_id))\n        self._paused_representations.add(representation_id)\n        repre_entity = get_representation_by_id(\n            project_name, representation_id\n        )\n        self.update_db(project_name, repre_entity, site_name, pause=True)\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def unpause_representation(\n        self, project_name, representation_id, site_name\n    ):\n        \"\"\"Unpause sync of representation entity on site.\n\n        Does not fail or warn if repre wasn't paused.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): Site name 'gdrive', 'studio' etc.\n        \"\"\"\n        self.log.info(\"Unpausing SiteSync for {}\".format(representation_id))\n        try:\n            self._paused_representations.remove(representation_id)\n        except KeyError:\n            pass\n        # self.paused_representations is not persistent\n        repre_entity = get_representation_by_id(\n            project_name, representation_id\n        )\n        self.update_db(project_name, repre_entity, site_name, pause=False)\n\n    def is_representation_paused(\n        self, representation_id, check_parents=False, project_name=None\n    ):\n        \"\"\"Is representation paused.\n\n        Args:\n            representation_id (str): Representation id.\n            check_parents (bool): Check if parent project or server itself\n                are not paused.\n            project_name (str): Project to check if paused.\n\n            if 'check_parents', 'project_name' should be set too\n\n        Returns:\n            bool: Is representation paused now.\n\n        \"\"\"\n        is_paused = representation_id in self._paused_representations\n        if check_parents and project_name:\n            is_paused = (\n                is_paused\n                or self.is_project_paused(project_name)\n                or self.is_paused()\n            )\n        return is_paused\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def pause_project(self, project_name):\n        \"\"\"Pause sync of whole project.\n\n        Args:\n            project_name (str): Project name.\n\n        \"\"\"\n        self.log.info(\"Pausing SiteSync for {}\".format(project_name))\n        self._paused_projects.add(project_name)\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def unpause_project(self, project_name):\n        \"\"\"Unpause sync of whole project.\n\n        Does not fail or warn if project wasn't paused.\n\n        Args:\n            project_name (str): Project name.\n\n        \"\"\"\n        self.log.info(\"Unpausing SiteSync for {}\".format(project_name))\n        try:\n            self._paused_projects.remove(project_name)\n        except KeyError:\n            pass\n\n    def is_project_paused(self, project_name, check_parents=False):\n        \"\"\"Is project sync paused.\n\n        Args:\n            project_name (str):\n            check_parents (bool): check if server itself\n                is not paused\n\n        Returns:\n            bool: Is project paused.\n\n        \"\"\"\n        is_paused = project_name in self._paused_projects\n        if check_parents:\n            is_paused = is_paused or self.is_paused()\n        return is_paused\n\n    # TODO hook to some trigger - no Sync Queue anymore\n    def pause_server(self):\n        \"\"\"Pause sync server.\n\n        It won't check anything, not uploading/downloading...\n        \"\"\"\n        self.log.info(\"Pausing SiteSync\")\n        self._paused = True\n\n    def unpause_server(self):\n        \"\"\"Unpause server sync.\"\"\"\n        self.log.info(\"Unpausing SiteSync\")\n        self._paused = False\n\n    def is_paused(self):\n        \"\"\" Is server paused \"\"\"\n        return self._paused\n\n    def get_active_site_type(self, project_name, local_settings=None):\n        \"\"\"Active site which is defined by artist.\n\n        Unlike 'get_active_site' is this method also checking local settings\n        where might be different active site set by user. The output is limited\n        to \"studio\" and \"local\".\n\n        This method is used by Anatomy.\n\n        Todos:\n            Check if sync server is enabled for the project.\n            - To be able to do that the sync settings MUST NOT be cached for\n                all projects at once. The sync settings preparation for all\n                projects is reasonable only in sync server loop.\n            `local_settings` is probably obsolete in AYON\n\n        Args:\n            project_name (str): Name of project where to look for active site.\n            local_settings (Optional[dict[str, Any]]): Prepared local settings.\n\n        Returns:\n            Literal[\"studio\", \"local\"]: Active site.\n        \"\"\"\n        if not self.enabled:\n            return \"studio\"\n\n        sync_project_settings = self.get_sync_project_setting(project_name)\n\n        if not sync_project_settings[\"enabled\"]:\n            return \"studio\"\n\n        return (\n            sync_project_settings[\"local_setting\"].get(\"active_site\")\n            or sync_project_settings[\"config\"][\"active_site\"]\n        )\n\n    def get_active_site(self, project_name):\n        \"\"\"Returns active (mine) site for project from settings.\n\n        Output logic:\n            - 'studio' if Site Sync is disabled\n            - value from 'get_local_site_id' if active site is 'local'\n            - any other site name from local settings\n                or project settings (site could be forced from PS)\n\n        Returns:\n            str: Site name.\n\n        \"\"\"\n        active_site_type = self.get_active_site_type(project_name)\n        if active_site_type == self.LOCAL_SITE:\n            return get_local_site_id()\n        return active_site_type\n\n    # remote site\n    def get_remote_site(self, project_name):\n        \"\"\"Remote (theirs) site for project from settings.\"\"\"\n        sync_project_settings = self.get_sync_project_setting(project_name)\n        remote_site = (\n            sync_project_settings[\"local_setting\"].get(\"remote_site\")\n            or sync_project_settings[\"config\"][\"remote_site\"]\n        )\n        if remote_site == self.LOCAL_SITE:\n            return get_local_site_id()\n\n        return remote_site\n\n    def get_site_root_overrides(\n        self, project_name, site_name, local_settings=None\n    ):\n        \"\"\"Get root overrides for project on a site.\n\n        Implemented to be used in 'Anatomy' for other than 'studio' site.\n\n        Args:\n            project_name (str): Project for which root overrides should be\n                received.\n            site_name (str): Name of site for which should be received roots.\n            local_settings (Optional[dict[str, Any]]): Prepare local settigns\n                values.\n\n        Returns:\n            Union[dict[str, Any], None]: Root overrides for this machine.\n\n            {\"work\": \"c:/projects_local\"}\n        \"\"\"\n\n        # Validate that site name is valid\n        if site_name not in (\"studio\", \"local\"):\n            # Consider local site id as 'local'\n            if site_name != get_local_site_id():\n                raise ValueError((\n                    \"Root overrides are available only for\"\n                    \" default sites not for \\\"{}\\\"\"\n                ).format(site_name))\n            site_name = \"local\"\n\n        sitesync_settings = self.get_sync_project_setting(project_name)\n\n        roots = {}\n        if not sitesync_settings[\"enabled\"]:\n            return roots\n        local_project_settings = sitesync_settings[\"local_setting\"]\n        if site_name == \"local\":\n            for root_info in local_project_settings[\"local_roots\"]:\n                roots[root_info[\"name\"]] = root_info[\"path\"]\n\n        return roots\n\n    def get_local_normalized_site(self, site_name):\n        \"\"\"Normlize local site name.\n\n         Return 'local' if 'site_name' is local id.\n\n        In some places Settings or Local Settings require 'local' instead\n        of real site name.\n\n        Returns:\n            str: Normalized site name.\n\n        \"\"\"\n        if site_name == get_local_site_id():\n            site_name = self.LOCAL_SITE\n\n        return site_name\n\n    def is_representation_on_site(\n        self, project_name, representation_id, site_name, max_retries=None\n    ):\n        \"\"\"Check if representation has all files available on site.\n\n        Args:\n            project_name (str)\n            representation_id (str)\n            site_name (str)\n            max_retries (int) (optional) - provide only if method used in while\n                loop to bail out\n\n        Returns:\n            bool: True if representation has all files correctly on the site.\n\n        Raises:\n              ValueError  Only If 'max_retries' provided if upload/download\n                failed too many times to limit infinite loop check.\n\n        \"\"\"\n        representation_status = self.get_repre_sync_state(\n            project_name, representation_id, site_name)\n        if not representation_status:\n            return False\n\n        if site_name == get_local_site_id():\n            status = representation_status[\"localStatus\"]\n        else:\n            status = representation_status[\"remoteStatus\"]\n\n        if max_retries:\n            tries = status.get(\"retries\", 0)\n            if tries &gt;= max_retries:\n                raise ValueError(\"Failed too many times\")\n\n        return status[\"status\"] == SiteSyncStatus.OK\n\n    def _reset_timer_with_rest_api(self):\n        # POST to webserver sites to add to representations\n        webserver_url = os.environ.get(\"AYON_WEBSERVER_URL\")\n        if not webserver_url:\n            self.log.warning(\"Couldn't find webserver url\")\n            return\n\n        rest_api_url = \"{}/sitesync/reset_timer\".format(\n            webserver_url\n        )\n\n        try:\n            import requests\n        except Exception:\n            self.log.warning(\n                \"Couldn't add sites to representations \"\n                \"('requests' is not available)\"\n            )\n            return\n\n        requests.post(rest_api_url)\n\n    def get_enabled_projects(self):\n        \"\"\"Returns list of projects which have SiteSync enabled.\"\"\"\n        enabled_projects = []\n\n        if self.enabled:\n            for project_name in get_project_names():\n                if self.is_project_enabled(project_name):\n                    enabled_projects.append(project_name)\n\n        return enabled_projects\n\n    def is_project_enabled(self, project_name, single=False):\n        \"\"\"Checks if 'project_name' is enabled for syncing.\n        'get_sync_project_setting' is potentially expensive operation (pulls\n        settings for all projects if cached version is not available), using\n        project_settings for specific project should be faster.\n        Args:\n            project_name (str)\n            single (bool): use 'get_addon_project_settings' method\n        \"\"\"\n        if self.enabled:\n            if single:\n                project_settings = get_addon_project_settings(\n                    self.name, self.version, project_name\n                )\n            else:\n                project_settings = self.get_sync_project_setting(project_name)\n            if project_settings and project_settings.get(\"enabled\"):\n                return True\n        return False\n\n    def handle_alternate_site(\n        self, project_name, representation_id, processed_site, file_id\n    ):\n        \"\"\"\n        For special use cases where one site vendors another.\n\n        Current use case is sftp site vendoring (exposing) same data as\n        regular site (studio). Each site is accessible for different\n        audience. 'studio' for artists in a studio, 'sftp' for externals.\n\n        Change of file status on one site actually means same change on\n        'alternate' site. (eg. artists publish to 'studio', 'sftp' is using\n        same location &gt;&gt; file is accessible on 'sftp' site right away.\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            processed_site (str): Real site_name of published/uploaded file\n            file_id (str): File id of file handled.\n\n        \"\"\"\n        sites = self._transform_sites_from_settings(self.sync_studio_settings)\n        sites[self.DEFAULT_SITE] = {\n            \"provider\": \"local_drive\",\n            \"alternative_sites\": []\n        }\n\n        alternate_sites = []\n        for site_name, site_info in sites.items():\n            conf_alternative_sites = site_info.get(\"alternative_sites\", [])\n            if processed_site in conf_alternative_sites:\n                alternate_sites.append(site_name)\n                continue\n            if processed_site == site_name and conf_alternative_sites:\n                alternate_sites.extend(conf_alternative_sites)\n                continue\n\n        if not alternate_sites:\n            return\n\n        sync_state = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            processed_site\n        )\n        # not yet available on processed_site, wont update alternate site yet\n        if not sync_state:\n            return\n        for file_info in sync_state[\"files\"]:\n            # expose status of remote site, it is expected on the server\n            file_info[\"status\"] = file_info[\"remoteStatus\"][\"status\"]\n\n        payload_dict = {\"files\": sync_state[\"files\"]}\n\n        alternate_sites = set(alternate_sites)\n        for alt_site in alternate_sites:\n            self.log.debug(\"Adding alternate {} to {}\".format(\n                alt_site, representation_id))\n\n            self._set_state_sync_state(\n                project_name,\n                representation_id,\n                alt_site,\n                payload_dict\n            )\n\n    # TODO - for Loaders\n    def get_repre_info_for_versions(\n        self, project_name, version_ids, active_site, remote_site\n    ):\n        \"\"\"Returns representation for versions and sites combi\n\n        Args:\n            project_name (str): Project name\n            version_ids (Iterable[str]): Version ids.\n            active_site (str): 'local', 'studio' etc\n            remote_site (str): dtto\n\n        Returns:\n\n        \"\"\"\n        version_ids = set(version_ids)\n        endpoint = \"{}/projects/{}/sitesync/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        # get to upload\n        kwargs = {\n            \"localSite\": active_site,\n            \"remoteSite\": remote_site,\n            \"versionIdFilter\": list(version_ids)\n        }\n\n        # kwargs[\"representationId\"] = \"94dca33a-7705-11ed-8c0a-34e12d91d510\"\n\n        response = ayon_api.get(endpoint, **kwargs)\n        repre_states = response.data.get(\"representations\", [])\n        repre_info_by_version_id = {\n            version_id: {\n                \"id\": version_id,\n                \"repre_count\": 0,\n                \"avail_repre_local\": 0,\n                \"avail_repre_remote\": 0,\n            }\n            for version_id in version_ids\n        }\n        repre_states_by_version_id = defaultdict(list)\n        for repre_state in repre_states:\n            version_id = repre_state[\"versionId\"]\n            repre_states_by_version_id[version_id].append(repre_state)\n\n        for version_id, repre_states in repre_states_by_version_id.items():\n            repre_info = repre_info_by_version_id[version_id]\n            repre_info[\"repre_count\"] = len(repre_states)\n            repre_info[\"avail_repre_local\"] = sum(\n                self._is_available(repre_state, \"localStatus\")\n                for repre_state in repre_states\n            )\n            repre_info[\"avail_repre_remote\"] = sum(\n                self._is_available(repre_state, \"remoteStatus\")\n                for repre_state in repre_states\n            )\n\n        return list(repre_info_by_version_id.values())\n    # --- End of Public API ---\n\n    def _is_available(self, repre, status):\n        \"\"\"Helper to decide if repre is download/uploaded on site.\n\n        Returns:\n            int: 1 if available, 0 if not.\n\n        \"\"\"\n        return int(repre[status][\"status\"] == SiteSyncStatus.OK)\n\n    def get_local_file_path(self, project_name, site_name, file_path):\n        \"\"\"Externalized for app.\n\n        Args:\n            project_name (str): Project name.\n            site_name (str): Site name.\n            file_path (str): File path from other site.\n\n        Returns:\n            str: Resolved local path.\n\n        \"\"\"\n        handler = LocalDriveHandler(project_name, site_name)\n        local_file_path = handler.resolve_path(file_path)\n\n        return local_file_path\n\n    def tray_init(self):\n        \"\"\"Initialization of Site Sync Server for Tray.\n\n        Called when tray is initialized, it checks if addon should be\n        enabled. If not, no initialization necessary.\n        \"\"\"\n        self.server_init()\n\n    def server_init(self):\n        \"\"\"Actual initialization of Sync Server.\"\"\"\n        # import only in tray or Python3, because of Python2 hosts\n        if not self.enabled:\n            return\n\n        from .sitesync import SiteSyncThread\n\n        self.lock = threading.Lock()\n\n        self.sitesync_thread = SiteSyncThread(self)\n\n    def tray_start(self):\n        \"\"\"Triggered when Tray is started.\n\n        Checks if configuration presets are available and if there is\n        any provider ('gdrive', 'S3') that is activated\n        (eg. has valid credentials).\n        \"\"\"\n        self.server_start()\n\n    def server_start(self):\n        if self.enabled:\n            self.sitesync_thread.start()\n        else:\n            self.log.info(\n                \"SiteSync is not enabled. Site Sync server was not started.\"\n            )\n\n    def tray_exit(self):\n        \"\"\"Stops sync thread if running.\n\n        Called from Addon Manager\n        \"\"\"\n        self.server_exit()\n\n    def server_exit(self):\n        if not self.sitesync_thread:\n            return\n\n        if not self.is_running:\n            return\n        try:\n            self.log.info(\"Stopping sync server server\")\n            self.sitesync_thread.is_running = False\n            self.sitesync_thread.stop()\n            self.log.info(\"Sync server stopped\")\n        except Exception:\n            self.log.warning(\n                \"Error has happened during Killing sync server\",\n                exc_info=True\n            )\n\n    def tray_menu(self, parent_menu):\n        pass\n\n    @property\n    def is_running(self):\n        return self.sitesync_thread.is_running\n\n    def get_anatomy(self, project_name):\n        \"\"\"Get already created or newly created anatomy for project\n\n        Args:\n            project_name (str): Project name.\n\n        Return:\n            Anatomy: Project anatomy object.\n        \"\"\"\n        from ayon_core.pipeline import Anatomy\n\n        return self._anatomies.get(project_name) or Anatomy(project_name)\n\n    @property\n    def sync_studio_settings(self):\n        if self._sync_studio_settings is None:\n            self._sync_studio_settings = (\n                get_studio_settings().get(self.name)\n            )\n\n        return self._sync_studio_settings\n\n    @property\n    def sync_project_settings(self):\n        if self._sync_project_settings is None:\n            self.set_sync_project_settings()\n\n        return self._sync_project_settings\n\n    def set_sync_project_settings(self, exclude_locals=False):\n        \"\"\"\n            Set sync_project_settings for all projects (caching)\n            Args:\n                exclude_locals (bool): ignore overrides from Local Settings\n            For performance\n        \"\"\"\n        sync_project_settings = self._prepare_sync_project_settings(\n            exclude_locals)\n\n        self._sync_project_settings = sync_project_settings\n\n    def _prepare_sync_project_settings(self, exclude_locals):\n        sync_project_settings = {}\n\n        sites = self._transform_sites_from_settings(\n            self.sync_studio_settings)\n\n        project_names = get_project_names()\n        for project_name in project_names:\n            project_sites = copy.deepcopy(sites)\n            project_settings = get_addon_project_settings(\n                self.name, self.version, project_name)\n\n            project_sites.update(self._get_default_site_configs(\n                project_settings[\"enabled\"], project_name, project_settings\n            ))\n\n            project_sites.update(\n                self._transform_sites_from_settings(project_settings))\n\n            project_settings[\"sites\"] = project_sites\n\n            sync_project_settings[project_name] = project_settings\n\n        if not sync_project_settings:\n            self.log.info(\"No enabled and configured projects for sync.\")\n        return sync_project_settings\n\n    def get_sync_project_setting(\n        self, project_name, exclude_locals=False, cached=True\n    ):\n        \"\"\" Handles pulling sitesync's settings for enabled 'project_name'\n\n        Args:\n            project_name (str): used in project settings\n            exclude_locals (bool): ignore overrides from Local Settings\n            cached (bool): use pre-cached values, or return fresh ones\n                cached values needed for single loop (with all overrides)\n                fresh values needed for Local settings (without overrides)\n\n        Returns:\n            dict: settings dictionary for the enabled project,\n                empty if no settings or sync is disabled\n\n        \"\"\"\n        # presets set already, do not call again and again\n        # self.log.debug(\"project preset {}\".format(self.presets))\n        if not cached:\n            return self._prepare_sync_project_settings(exclude_locals)\\\n                [project_name]\n\n        if (\n            not self.sync_project_settings\n            or not self.sync_project_settings.get(project_name)\n        ):\n            self.set_sync_project_settings(exclude_locals)\n        return self.sync_project_settings.get(project_name)\n\n    def _transform_sites_from_settings(self, settings):\n        \"\"\"Transforms list of 'sites' from Setting to dict.\n\n        It processes both System and Project Settings as they have same format.\n        \"\"\"\n        sites = {}\n        if not self.enabled:\n            return sites\n\n        for whole_site_info in settings.get(\"sites\", []):\n            site_name = whole_site_info[\"name\"]\n            provider_specific = copy.deepcopy(\n                whole_site_info[whole_site_info[\"provider\"]]\n            )\n            configured_site = {\n                \"enabled\": True,\n                \"alternative_sites\": whole_site_info[\"alternative_sites\"],\n                \"root\": provider_specific.pop(\"roots\", None)\n            }\n            configured_site.update(provider_specific)\n\n            sites[site_name] = configured_site\n        return sites\n\n    def _get_project_roots_for_site(self, project_name, site_name=None):\n        \"\"\"Returns projects roots and their overrides.\"\"\"\n        # overrides for Studio site for particular user\n        # TODO temporary to get roots without overrides\n        # ayon_api.get_project_roots_by_site returns only overrides.\n        # Should be replaced when ayon_api implements `siteRoots` method\n        if not site_name:\n            site_name = get_local_site_id()\n        platform_name = platform.system().lower()\n        roots = ayon_api.get(\n            f\"projects/{project_name}/siteRoots\",\n            platform=platform_name\n        ).data\n        root_overrides = get_project_roots_for_site(project_name, site_name)\n        for key, value in roots.items():\n            override = root_overrides.get(key)\n            if override:\n                roots[key] = override\n\n        return roots\n\n    def _get_default_site_configs(\n        self, sync_enabled=True, project_name=None, project_settings=None\n    ):\n        \"\"\"Settings for 'studio' and user's local site\n\n        Returns base values from setting, not overridden by Local Settings,\n        eg. value used to push TO LS not to get actual value for syncing.\n\n        Args:\n            sync_enabled (Optional[bool]): Is sync enabled.\n            project_name (Optional[str]): Project name.\n            project_settings (Optional[dict]): Project settings.\n\n        \"\"\"\n        local_site_id = get_local_site_id()\n        roots = self._get_project_roots_for_site(project_name, local_site_id)\n        studio_config = {\n            \"enabled\": True,\n            \"provider\": \"local_drive\",\n            \"root\": roots\n        }\n        all_sites = {self.DEFAULT_SITE: studio_config}\n        if sync_enabled:\n            roots = project_settings[\"local_setting\"][\"local_roots\"]\n            local_site_dict = {\n                \"enabled\": True,\n                \"provider\": \"local_drive\",\n                \"root\": roots\n            }\n            all_sites[local_site_id] = local_site_dict\n            # duplicate values for normalized local name\n            all_sites[\"local\"] = local_site_dict\n        return all_sites\n\n    def get_provider_for_site(self, project_name=None, site=None):\n        \"\"\"Get provider name for site (unique name across all projects).\"\"\"\n        sites = {\n            self.DEFAULT_SITE: \"local_drive\",\n            self.LOCAL_SITE: \"local_drive\",\n            get_local_site_id(): \"local_drive\"\n        }\n\n        if site in sites.keys():\n            return sites[site]\n\n        # backward compatibility\n        if project_name:\n            proj_settings = self.get_sync_project_setting(project_name)\n            provider = (\n                proj_settings\n                .get(\"sites\", {})\n                .get(site, {})\n                .get(\"provider\")\n            )\n            if provider:\n                return provider\n\n        sync_sett = self.sync_studio_settings\n        for site_config in sync_sett.get(\"sites\"):\n            sites[site_config[\"name\"]] = site_config[\"provider\"]\n\n        return sites.get(site, \"N/A\")\n\n    @time_function\n    def get_sync_representations(\n        self, project_name, active_site, remote_site, limit=10\n    ):\n        \"\"\"\n            Get representations that should be synced, these could be\n            recognised by presence of document in 'files.sites', where key is\n            a provider (GDrive, S3) and value is empty document or document\n            without 'created_dt' field. (Don't put null to 'created_dt'!).\n\n            Querying of 'to-be-synched' files is offloaded to Mongod for\n            better performance. Goal is to get as few representations as\n            possible.\n        Args:\n            project_name (str):\n            active_site (str): identifier of current active site (could be\n                'local_0' when working from home, 'studio' when working in the\n                studio (default)\n            remote_site (str): identifier of remote site I want to sync to\n\n        Returns:\n            list[dict]: Representation states.\n\n        \"\"\"\n        self.log.debug(\"Check representations for: {}-{}\".format(\n            active_site, remote_site\n        ))\n\n        endpoint = \"{}/{}/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        # get to upload\n        kwargs = {\n            \"localSite\": active_site,\n            \"remoteSite\": remote_site,\n            \"localStatusFilter\": [SiteSyncStatus.OK],\n            \"remoteStatusFilter\": [SiteSyncStatus.QUEUED],\n        }\n\n        response = ayon_api.get(endpoint, **kwargs)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\n                \"Cannot get representations for sync with code {}\".format(\n                    response.status_code\n                )\n            )\n\n        repre_states = response.data[\"representations\"]\n\n        # get to download\n        if len(repre_states) &lt; limit:\n            kwargs[\"localStatusFilter\"] = [SiteSyncStatus.QUEUED]\n            kwargs[\"remoteStatusFilter\"] = [SiteSyncStatus.OK]\n\n            response = ayon_api.get(endpoint, **kwargs)\n            repre_states.extend(response.data[\"representations\"])\n\n        return repre_states\n\n    def check_status(self, file_state, local_site, remote_site, config_preset):\n        \"\"\"Check synchronization status of a file.\n\n        The file is on representation status is checked for single 'provider'.\n            (Eg. check if 'scene.ma' of lookdev.v10 should be synced to GDrive\n\n        Always is comparing local record, eg. site with\n            'name' == self.presets[PROJECT_NAME][\"config\"][\"active_site\"]\n\n        This leads to trigger actual upload or download, there is\n            a use case 'studio' &lt;&gt; 'remote' where user should publish\n            to 'studio', see progress in Tray GUI, but do not do\n            physical upload/download\n            (as multiple user would be doing that).\n\n            Do physical U/D only when any of the sites is user's local, in that\n            case only user has the data and must U/D.\n\n        Args:\n            file_state (dict): File info from site sync database.\n            local_site (str): Local site of compare (usually 'studio').\n            remote_site (str): Remote site (gdrive etc).\n            config_preset (dict): Config about active site, retries.\n\n        Returns:\n            int: Sync status value of representation.\n\n        \"\"\"\n        if get_local_site_id() not in (local_site, remote_site):\n            # don't do upload/download for studio sites\n            self.log.debug(\n                \"No local site {} - {}\".format(local_site, remote_site)\n            )\n            return SyncStatus.DO_NOTHING\n\n        local_status = file_state[\"localStatus\"][\"status\"]\n        remote_status = file_state[\"remoteStatus\"][\"status\"]\n\n        if (\n            local_status != SiteSyncStatus.OK\n            and remote_status == SiteSyncStatus.OK\n        ):\n            retries = file_state[\"localStatus\"][\"retries\"]\n            if retries &lt; int(config_preset[\"retry_cnt\"]):\n                return SyncStatus.DO_DOWNLOAD\n\n        if (\n            remote_status != SiteSyncStatus.OK\n            and local_status == SiteSyncStatus.OK\n        ):\n            retries = file_state[\"remoteStatus\"][\"retries\"]\n            if retries &lt; int(config_preset[\"retry_cnt\"]):\n                return SyncStatus.DO_UPLOAD\n\n        return SyncStatus.DO_NOTHING\n\n    def update_db(\n        self,\n        project_name,\n        repre_status,\n        site_name,\n        new_file_id=None,\n        file=None,\n        side=None,\n        error=None,\n        progress=None,\n        priority=None,\n        pause=None\n    ):\n        \"\"\"Update 'provider' portion of records in DB.\n\n        Args:\n            project_name (str): Project name. Force to db connection as\n                each file might come from different collection.\n            repre_status (dict): Representation status from sitesync database.\n            site_name (str): Site name.\n            new_file_id (Optional[str]): File id of new file.\n            file (dict[str, Any]): info about processed file (pulled from DB)\n            side (str): 'local' | 'remote'\n            error (str): exception message\n            progress (float): 0-1 of progress of upload/download\n            priority (int): 0-100 set priority\n            pause (bool): stop synchronizing (only before starting of download,\n                upload)\n\n        Returns:\n            None\n        \"\"\"\n        files_status = []\n        for file_status in repre_status[\"files\"]:\n            status_entity = copy.deepcopy(\n                file_status[\"{}Status\".format(side)]\n            )\n            status_entity[\"fileHash\"] = file_status[\"fileHash\"]\n            status_entity[\"id\"] = file_status[\"id\"]\n            if file_status[\"fileHash\"] == file[\"fileHash\"]:\n                if new_file_id:\n                    status_entity[\"status\"] = SiteSyncStatus.OK\n                    status_entity.pop(\"message\")\n                    status_entity.pop(\"retries\")\n                elif progress is not None:\n                    status_entity[\"status\"] = SiteSyncStatus.IN_PROGRESS\n                    status_entity[\"progress\"] = progress\n                elif error:\n                    max_retries = int(\n                        self.sync_project_settings\n                        [project_name]\n                        [\"config\"]\n                        [\"retry_cnt\"]\n                    )\n                    tries = status_entity.get(\"retries\", 0)\n                    tries += 1\n                    status_entity[\"retries\"] = tries\n                    status_entity[\"message\"] = error\n                    if tries &gt;= max_retries:\n                        status_entity[\"status\"] = SiteSyncStatus.FAILED\n                elif pause is not None:\n                    if pause:\n                        status_entity[\"pause\"] = True\n                    else:\n                        status_entity.remove(\"pause\")\n                files_status.append(status_entity)\n\n        representation_id = repre_status[\"representationId\"]\n\n        endpoint = \"{}/{}/state/{}/{}\".format(\n            self.endpoint_prefix,\n            project_name,\n            representation_id,\n            site_name)\n\n        # get to upload\n        kwargs = {\n            \"files\": files_status\n        }\n\n        if priority:\n            kwargs[\"priority\"] = priority\n\n        response = ayon_api.post(endpoint, **kwargs)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\"Cannot update status\")\n\n        if progress is not None or priority is not None:\n            return\n\n        status = \"failed\"\n        error_str = \"with error {}\".format(error)\n        if new_file_id:\n            status = \"succeeded with id {}\".format(new_file_id)\n            error_str = \"\"\n\n        source_file = file.get(\"path\", \"\")\n\n        self.log.debug(\n            \"File for {} - {source_file} process {status} {error_str}\".format(\n                representation_id,\n                status=status,\n                source_file=source_file,\n                error_str=error_str\n            )\n        )\n\n    def reset_site_on_representation(\n        self,\n        project_name,\n        representation_id,\n        side=None,\n        file_id=None,\n        site_name=None\n    ):\n        \"\"\"\n            Reset information about synchronization for particular 'file_id'\n            and provider.\n            Useful for testing or forcing file to be reuploaded.\n\n            'side' and 'site_name' are disjunctive.\n\n            'side' is used for resetting local or remote side for\n            current user for repre.\n\n            'site_name' is used to set synchronization for particular site.\n            Should be used when repre should be synced to new site.\n\n        Args:\n            project_name (str): name of project (eg. collection) in DB\n            representation_id (str): Representation id.\n            file_id (str): File id in representation.\n            side (str): Local or remote side.\n            site_name (str): for adding new site\n\n        Raises:\n            SiteAlreadyPresentError - if adding already existing site and\n                not 'force'\n            ValueError - other errors (repre not found, misconfiguration)\n        \"\"\"\n        representation = get_representation_by_id(\n            project_name, representation_id\n        )\n        if not representation:\n            raise ValueError(\n                \"Representation {} not found in {}\".format(\n                    representation_id, project_name\n                )\n            )\n\n        if side and site_name:\n            raise ValueError(\n                \"Misconfiguration, only one of side and\"\n                \" site_name arguments should be passed.\"\n            )\n\n        if side:\n            if side == \"local\":\n                site_name = self.get_active_site(project_name)\n            else:\n                site_name = self.get_remote_site(project_name)\n\n        self.add_site(\n            project_name, representation_id, site_name, file_id, force=True\n        )\n\n    def _get_progress_for_repre_new(\n        self,\n        project_name,\n        representation,\n        local_site_name,\n        remote_site_name=None\n    ):\n        representation_id = representation[\"id\"]\n        sync_status = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            local_site_name,\n            remote_site_name\n        )\n\n        progress = {\n            local_site_name: -1,\n            remote_site_name: -1\n        }\n        if not sync_status:\n            return progress\n\n        mapping = {\n            \"localStatus\": local_site_name,\n            \"remoteStatus\": remote_site_name\n        }\n        files = {local_site_name: 0, remote_site_name: 0}\n        file_states = sync_status.get(\"files\") or []\n        for file_state in file_states:\n            for status in mapping.keys():\n                status_info = file_state[status]\n                site_name = mapping[status]\n                files[site_name] += 1\n                norm_progress = max(progress[site_name], 0)\n                if status_info[\"status\"] == SiteSyncStatus.OK:\n                    progress[site_name] = norm_progress + 1\n                elif status_info.get(\"progress\"):\n                    progress[site_name] = norm_progress + status_info[\n                        \"progress\"]\n                else:  # site exists, might be failed, do not add again\n                    progress[site_name] = 0\n\n        # for example 13 fully avail. files out of 26 &gt;&gt; 13/26 = 0.5\n        return {\n            local_site_name: (\n                progress[local_site_name] / max(files[local_site_name], 1)\n            ),\n            remote_site_name: (\n                progress[remote_site_name] / max(files[remote_site_name], 1)\n            )\n        }\n\n    def _get_progress_for_repre_old(\n        self,\n        representation,\n        local_site_name,\n        remote_site_name=None\n    ):\n        return self._get_progress_for_repre_new(\n            representation[\"context\"][\"project\"][\"name\"],\n            representation,\n            local_site_name,\n            remote_site_name\n        )\n\n    def get_progress_for_repre(self, *args, **kwargs):\n        \"\"\"Calculates average progress for representation.\n\n        If site has created_dt &gt;&gt; fully available &gt;&gt; progress == 1\n\n        Could be calculated in aggregate if it would be too slow\n\n        Returns:\n            (dict) with active and remote sites progress\n            {'studio': 1.0, 'gdrive': -1} - gdrive site is not present\n                -1 is used to highlight the site should be added\n            {'studio': 1.0, 'gdrive': 0.0} - gdrive site is present, not\n                uploaded yet\n\n        \"\"\"\n        sig_new = inspect.signature(self._get_progress_for_repre_new)\n        sig_old = inspect.signature(self._get_progress_for_repre_old)\n        try:\n            sig_new.bind(*args, **kwargs)\n            return self._get_progress_for_repre_new(*args, **kwargs)\n        except TypeError:\n            pass\n\n        try:\n            sig_old.bind(*args, **kwargs)\n            print(\n                \"Using old signature of 'get_progress_for_repre'\"\n                \" please add project name as first argument.\"\n            )\n            return self._get_progress_for_repre_old(*args, **kwargs)\n        except TypeError:\n            pass\n\n        return self._get_progress_for_repre_new(*args, **kwargs)\n\n    def _set_state_sync_state(\n        self, project_name, representation_id, site_name, payload_dict\n    ):\n        \"\"\"Calls server endpoint to store sync info for 'representation_id'.\"\"\"\n        endpoint = \"{}/{}/state/{}/{}\".format(\n            self.endpoint_prefix,\n            project_name,\n            representation_id,\n            site_name\n        )\n\n        response = ayon_api.post(endpoint, **payload_dict)\n        if response.status_code not in [200, 204]:\n            raise RuntimeError(\"Cannot update status\")\n\n    def get_repre_sync_state(\n        self,\n        project_name,\n        representation_id,\n        local_site_name,\n        remote_site_name=None,\n        **kwargs\n    ):\n        \"\"\"Use server endpoint to get synchronization info for representation.\n\n        Warning:\n            Logic of this\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            local_site_name (str)\n            remote_site_name (str)\n            all other parameters for `Get Site Sync State` endpoint if\n                necessary\n\n        \"\"\"\n        repre_states = self._get_repres_state(\n            project_name,\n            {representation_id},\n            local_site_name,\n            remote_site_name,\n            **kwargs\n        )\n        if repre_states:\n            repre_state = repre_states[0]\n            if repre_state[\"localStatus\"][\"status\"] != -1:\n                return repre_state\n\n    def get_representations_sync_state(\n        self,\n        project_name,\n        representation_ids,\n        local_site_name,\n        remote_site_name=None,\n        **kwargs\n    ):\n        \"\"\"Use server endpoint to get synchronization info for representations.\n\n        Calculates float progress based on progress of all files for repre.\n        If repre is fully synchronized it returns 1, 0 for any other state.\n\n        Args:\n            project_name (str):\n            representation_ids (list): even single repre should be in []\n            local_site_name (str)\n            remote_site_name (str)\n            all other parameters for `Get Site Sync State` endpoint if\n                necessary.\n\n        Returns:\n            dict[str, tuple[float, float]]: Progress by representation id.\n\n        \"\"\"\n        repre_states = self._get_repres_state(\n            project_name,\n            representation_ids,\n            local_site_name,\n            remote_site_name,\n            **kwargs\n        )\n        states = {}\n        for repre_state in repre_states:\n            repre_files_count = len(repre_state[\"files\"])\n\n            repre_local_status = repre_state[\"localStatus\"][\"status\"]\n            repre_local_progress = 0\n            if repre_local_status == SiteSyncStatus.OK:\n                repre_local_progress = 1\n            elif repre_local_status == SiteSyncStatus.IN_PROGRESS:\n                local_sum = sum(\n                    file_info[\"localStatus\"].get(\"progress\", 0)\n                    for file_info in repre_state[\"files\"]\n                )\n                repre_local_progress = local_sum / repre_files_count\n\n            repre_remote_status = repre_state[\"remoteStatus\"][\"status\"]\n            repre_remote_progress = 0\n            if repre_remote_status == SiteSyncStatus.OK:\n                repre_remote_progress = 1\n            elif repre_remote_status == SiteSyncStatus.IN_PROGRESS:\n                remote_sum = sum(\n                    file_info[\"remoteStatus\"].get(\"progress\", 0)\n                    for file_info in repre_state[\"files\"]\n                )\n                repre_remote_progress = remote_sum / repre_files_count\n\n            states[repre_state[\"representationId\"]] = (\n                repre_local_progress,\n                repre_remote_progress\n            )\n\n        return states\n\n    def _get_repres_state(\n        self,\n        project_name,\n        representation_ids,\n        local_site_name,\n        remote_site_name=None,\n        **kwargs\n    ):\n        \"\"\"Use server endpoint to get sync info for representations.\n\n        Args:\n            project_name (str): Project name.\n            representation_ids (Iterable[str]): Representation ids.\n            local_site_name (str): Local site name.\n            remote_site_name (str): Remote site name.\n            kwargs: All other parameters for `Get Site Sync State` endpoint if\n                necessary\n\n        \"\"\"\n        if not remote_site_name:\n            remote_site_name = local_site_name\n        payload_dict = {\n            \"localSite\": local_site_name,\n            \"remoteSite\": remote_site_name,\n            \"representationIds\": representation_ids\n        }\n        if kwargs:\n            payload_dict.update(kwargs)\n\n        endpoint = \"{}/{}/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        response = ayon_api.get(endpoint, **payload_dict)\n        if response.status_code != 200:\n            raise RuntimeError(\n                \"Cannot get sync state for representations {}\".format(\n                    representation_ids\n                )\n            )\n\n        return response.data[\"representations\"]\n\n    def get_version_availability(\n        self,\n        project_name,\n        version_ids,\n        local_site_name,\n        remote_site_name,\n        **kwargs\n    ):\n        \"\"\"Returns aggregated state for version ids.\n\n        Args:\n            project_name (str): Project name.\n            version_ids (Iterable[str]): Version ids.\n            local_site_name (str): Local site name.\n            remote_site_name (str): Remote site name.\n            kwargs: All other parameters for `Get Site Sync State` endpoint if\n                necessary.\n\n        Returns:\n            dict[str, tuple[float, float]]: Status by version id.\n                Example: {version_id: (local_status, remote_status)}\n\n        \"\"\"\n        version_ids = list(version_ids)\n        payload_dict = {\n            \"localSite\": local_site_name,\n            \"remoteSite\": remote_site_name,\n            \"versionIdsFilter\": version_ids\n        }\n        payload_dict.update(kwargs)\n\n        endpoint = \"{}/{}/state\".format(\n            self.endpoint_prefix, project_name\n        )\n\n        response = ayon_api.get(endpoint, **payload_dict)\n        if response.status_code != 200:\n            raise RuntimeError(\n                \"Cannot get sync state for versions {}\".format(\n                    version_ids\n                )\n            )\n\n        version_statuses = {\n            version_id: (0, 0)\n            for version_id in version_ids\n        }\n\n        repre_avail_by_version_id = defaultdict(list)\n        for repre_avail in response.data[\"representations\"]:\n            version_id = repre_avail[\"versionId\"]\n            repre_avail_by_version_id[version_id].append(repre_avail)\n\n        for version_id, repre_avails in repre_avail_by_version_id.items():\n            avail_local = sum(\n                int(\n                    repre_avail[\"localStatus\"][\"status\"] == SiteSyncStatus.OK\n                )\n                for repre_avail in repre_avails\n            )\n            avail_remote = sum(\n                int(\n                    repre_avail[\"remoteStatus\"][\"status\"] == SiteSyncStatus.OK\n                )\n                for repre_avail in repre_avails\n            )\n            version_statuses[version_id] = (avail_local, avail_remote)\n\n        return version_statuses\n\n    def _remove_local_file(self, project_name, representation_id, site_name):\n        \"\"\"Removes all local files for 'site_name' of 'representation_id'\n\n        Args:\n            project_name (str): Project name.\n            representation_id (str): Representation id.\n            site_name (str): name of configured and active site\n\n        \"\"\"\n        my_local_site = get_local_site_id()\n        if my_local_site != site_name:\n            self.log.warning(\n                \"Cannot remove non local file for {}\".format(site_name)\n            )\n            return\n\n        provider_name = self.get_provider_for_site(site=site_name)\n\n        if provider_name != \"local_drive\":\n            return\n\n        representation = get_representation_by_id(\n            project_name, representation_id\n        )\n        if not representation:\n            self.log.debug(\n                \"Representation with id {} was not found\".format(\n                    representation_id\n                )\n            )\n            return\n\n        for file in representation[\"files\"]:\n            local_file_path = self.get_local_file_path(\n                project_name,\n                site_name,\n                file.get(\"path\")\n            )\n            if local_file_path is None:\n                raise ValueError(\"Missing local file path\")\n\n            try:\n                self.log.debug(\"Removing {}\".format(local_file_path))\n                os.remove(local_file_path)\n            except IndexError:\n                msg = \"No file set for {}\".format(representation_id)\n                self.log.debug(msg)\n                raise ValueError(msg)\n            except OSError:\n                msg = \"File {} cannot be removed\".format(file[\"path\"])\n                self.log.warning(msg)\n                raise ValueError(msg)\n\n            folder = os.path.dirname(local_file_path)\n            if os.listdir(folder):  # folder is not empty\n                continue\n\n            try:\n                os.rmdir(folder)\n            except OSError:\n                msg = \"folder {} cannot be removed\".format(folder)\n                self.log.warning(msg)\n                raise ValueError(msg)\n\n    def reset_timer(self):\n        \"\"\"\n            Called when waiting for next loop should be skipped.\n\n            In case of user's involvement (reset site), start that right away.\n        \"\"\"\n\n        if not self.enabled:\n            return\n\n        if self.sitesync_thread is None:\n            self._reset_timer_with_rest_api()\n        else:\n            self.sitesync_thread.reset_timer()\n\n    def get_loop_delay(self, project_name):\n        \"\"\"\n            Return count of seconds before next synchronization loop starts\n            after finish of previous loop.\n\n        Returns:\n            (int): in seconds\n        \"\"\"\n        if not project_name:\n            return 60\n\n        # TODO this is used in global loop it should not be based on\n        #   project settings.\n        ld = self.sync_project_settings[project_name][\"config\"][\"loop_delay\"]\n        return int(ld)\n\n    def cli(self, click_group):\n        main = click_wrap.group(\n            self._cli_main,\n            name=self.name,\n            help=\"SiteSync addon related commands.\"\n        )\n\n        main.command(\n            self._cli_command_syncservice,\n            name=\"syncservice\",\n            help=\"Launch Site Sync under entered site.\"\n        ).option(\n            \"-a\",\n            \"--active_site\",\n            help=\"Name of active site\",\n            required=True\n        )\n        click_group.add_command(main.to_click_obj())\n\n    def _cli_main(self):\n        pass\n\n    def _cli_command_syncservice(self, active_site):\n        \"\"\"Launch sync server under entered site.\n\n        This should be ideally used by system service (such us systemd or upstart\n        on linux and window service).\n        \"\"\"\n\n        os.environ[\"AYON_SITE_ID\"] = active_site\n\n        def signal_handler(sig, frame):\n            print(\"You pressed Ctrl+C. Process ended.\")\n            self.server_exit()\n            sys.exit(0)\n\n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n\n        self.server_init()\n        self.server_start()\n\n        while True:\n            time.sleep(1.0)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.add_site","title":"<code>add_site(project_name, representation_id, site_name=None, file_id=None, force=False, status=SiteSyncStatus.QUEUED)</code>","text":"<p>Adds new site to representation to be synced.</p> <p>'project_name' must have synchronization enabled (globally or project only)</p> <p>Used as a API endpoint from outside applications (Loader etc).</p> <p>Use 'force' to reset existing site.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>site_name</code> <code>str</code> <p>Site name of configured site.</p> <code>None</code> <code>file_id</code> <code>str</code> <p>File id.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Reset site if exists.</p> <code>False</code> <code>status</code> <code>SiteSyncStatus</code> <p>Current status, default SiteSyncStatus.QUEUED</p> <code>QUEUED</code> <p>Raises:</p> Type Description <code>SiteAlreadyPresentError</code> <p>If adding already existing site and not 'force'</p> <code>ValueError</code> <p>other errors (repre not found, misconfiguration)</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def add_site(\n    self,\n    project_name,\n    representation_id,\n    site_name=None,\n    file_id=None,\n    force=False,\n    status=SiteSyncStatus.QUEUED\n):\n    \"\"\"Adds new site to representation to be synced.\n\n    'project_name' must have synchronization enabled (globally or\n    project only)\n\n    Used as a API endpoint from outside applications (Loader etc).\n\n    Use 'force' to reset existing site.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        site_name (str): Site name of configured site.\n        file_id (str): File id.\n        force (bool): Reset site if exists.\n        status (SiteSyncStatus): Current status,\n            default SiteSyncStatus.QUEUED\n\n    Raises:\n        SiteAlreadyPresentError: If adding already existing site and\n            not 'force'\n        ValueError: other errors (repre not found, misconfiguration)\n\n    \"\"\"\n    if not self.get_sync_project_setting(project_name):\n        raise ValueError(\"Project not configured\")\n\n    if not site_name:\n        site_name = self.DEFAULT_SITE\n\n    representation = get_representation_by_id(\n        project_name, representation_id\n    )\n\n    files = representation.get(\"files\", [])\n    if not files:\n        self.log.debug(\"No files for {}\".format(representation_id))\n        return\n\n    if not force:\n        existing = self.get_repre_sync_state(\n            project_name,\n            representation_id,\n            site_name\n        )\n        if existing:\n            failure = True\n            if file_id:\n                file_exists = existing.get(\"files\", {}).get(file_id)\n                if not file_exists:\n                    failure = False\n\n            if failure:\n                msg = \"Site {} already present\".format(site_name)\n                self.log.info(msg)\n                raise SiteAlreadyPresentError(msg)\n\n    new_site_files = [\n        {\n            \"size\": repre_file[\"size\"],\n            \"status\": status,\n            \"timestamp\": datetime.now().timestamp(),\n            \"id\": repre_file[\"id\"],\n            \"fileHash\": repre_file[\"hash\"]\n        }\n        for repre_file in files\n    ]\n\n    payload_dict = {\"files\": new_site_files}\n    representation_id = representation_id.replace(\"-\", \"\")\n\n    self._set_state_sync_state(\n        project_name, representation_id, site_name, payload_dict\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.check_status","title":"<code>check_status(file_state, local_site, remote_site, config_preset)</code>","text":"<p>Check synchronization status of a file.</p> <p>The file is on representation status is checked for single 'provider'.     (Eg. check if 'scene.ma' of lookdev.v10 should be synced to GDrive</p> <p>Always is comparing local record, eg. site with     'name' == self.presets[PROJECT_NAME][\"config\"][\"active_site\"]</p> <p>This leads to trigger actual upload or download, there is     a use case 'studio' &lt;&gt; 'remote' where user should publish     to 'studio', see progress in Tray GUI, but do not do     physical upload/download     (as multiple user would be doing that).</p> <pre><code>Do physical U/D only when any of the sites is user's local, in that\ncase only user has the data and must U/D.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_state</code> <code>dict</code> <p>File info from site sync database.</p> required <code>local_site</code> <code>str</code> <p>Local site of compare (usually 'studio').</p> required <code>remote_site</code> <code>str</code> <p>Remote site (gdrive etc).</p> required <code>config_preset</code> <code>dict</code> <p>Config about active site, retries.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Sync status value of representation.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def check_status(self, file_state, local_site, remote_site, config_preset):\n    \"\"\"Check synchronization status of a file.\n\n    The file is on representation status is checked for single 'provider'.\n        (Eg. check if 'scene.ma' of lookdev.v10 should be synced to GDrive\n\n    Always is comparing local record, eg. site with\n        'name' == self.presets[PROJECT_NAME][\"config\"][\"active_site\"]\n\n    This leads to trigger actual upload or download, there is\n        a use case 'studio' &lt;&gt; 'remote' where user should publish\n        to 'studio', see progress in Tray GUI, but do not do\n        physical upload/download\n        (as multiple user would be doing that).\n\n        Do physical U/D only when any of the sites is user's local, in that\n        case only user has the data and must U/D.\n\n    Args:\n        file_state (dict): File info from site sync database.\n        local_site (str): Local site of compare (usually 'studio').\n        remote_site (str): Remote site (gdrive etc).\n        config_preset (dict): Config about active site, retries.\n\n    Returns:\n        int: Sync status value of representation.\n\n    \"\"\"\n    if get_local_site_id() not in (local_site, remote_site):\n        # don't do upload/download for studio sites\n        self.log.debug(\n            \"No local site {} - {}\".format(local_site, remote_site)\n        )\n        return SyncStatus.DO_NOTHING\n\n    local_status = file_state[\"localStatus\"][\"status\"]\n    remote_status = file_state[\"remoteStatus\"][\"status\"]\n\n    if (\n        local_status != SiteSyncStatus.OK\n        and remote_status == SiteSyncStatus.OK\n    ):\n        retries = file_state[\"localStatus\"][\"retries\"]\n        if retries &lt; int(config_preset[\"retry_cnt\"]):\n            return SyncStatus.DO_DOWNLOAD\n\n    if (\n        remote_status != SiteSyncStatus.OK\n        and local_status == SiteSyncStatus.OK\n    ):\n        retries = file_state[\"remoteStatus\"][\"retries\"]\n        if retries &lt; int(config_preset[\"retry_cnt\"]):\n            return SyncStatus.DO_UPLOAD\n\n    return SyncStatus.DO_NOTHING\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.clear_project","title":"<code>clear_project(project_name, site_name)</code>","text":"<p>Clear 'project_name' of 'site_name' and its local files</p> <p>Works only on real local sites, not on 'studio'</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def clear_project(self, project_name, site_name):\n    \"\"\"\n        Clear 'project_name' of 'site_name' and its local files\n\n        Works only on real local sites, not on 'studio'\n    \"\"\"\n\n    # TODO implement\n    self.log.warning(\"Method 'clear_project' is not implemented.\")\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.compute_resource_sync_sites","title":"<code>compute_resource_sync_sites(project_name)</code>","text":"<p>Get available resource sync sites state for publish process.</p> <p>Returns dict with prepared state of sync sites for 'project_name'. It checks if Site Sync is enabled, handles alternative sites. Publish process stores this dictionary as a part of representation document in DB.</p> <p>Example: [     {         'name': '42abbc09-d62a-44a4-815c-a12cd679d2d7',         'status': SiteSyncStatus.OK     },     {'name': 'studio', 'status': SiteSyncStatus.QUEUED},     {'name': 'SFTP', 'status': SiteSyncStatus.QUEUED} ] -- representation is published locally, artist or Settings have set remote site as 'studio'. 'SFTP' is alternate site to 'studio'. Eg. whenever file is on 'studio', it is also on 'SFTP'.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def compute_resource_sync_sites(self, project_name):\n    \"\"\"Get available resource sync sites state for publish process.\n\n    Returns dict with prepared state of sync sites for 'project_name'.\n    It checks if Site Sync is enabled, handles alternative sites.\n    Publish process stores this dictionary as a part of representation\n    document in DB.\n\n    Example:\n    [\n        {\n            'name': '42abbc09-d62a-44a4-815c-a12cd679d2d7',\n            'status': SiteSyncStatus.OK\n        },\n        {'name': 'studio', 'status': SiteSyncStatus.QUEUED},\n        {'name': 'SFTP', 'status': SiteSyncStatus.QUEUED}\n    ] -- representation is published locally, artist or Settings have set\n    remote site as 'studio'. 'SFTP' is alternate site to 'studio'. Eg.\n    whenever file is on 'studio', it is also on 'SFTP'.\n    \"\"\"\n\n    def create_metadata(name, created=True):\n        \"\"\"Create sync site metadata for site with `name`\"\"\"\n        if created:\n            status = SiteSyncStatus.OK\n        else:\n            status = SiteSyncStatus.QUEUED\n        return {\"name\": name, \"status\": status}\n\n    if (\n        not self.sync_studio_settings[\"enabled\"]\n        or not self.sync_project_settings[project_name][\"enabled\"]\n    ):\n        return [create_metadata(self.DEFAULT_SITE)]\n\n    local_site = self.get_active_site(project_name)\n    remote_site = self.get_remote_site(project_name)\n\n    # Attached sites metadata by site name\n    # That is the local site, remote site, the always accesible sites\n    # and their alternate sites (alias of sites with different protocol)\n    attached_sites = {\n        local_site: create_metadata(local_site)\n    }\n    if remote_site and remote_site not in attached_sites:\n        attached_sites[remote_site] = create_metadata(\n            remote_site, created=False\n        )\n\n    attached_sites = self._add_alternative_sites(\n        project_name, attached_sites)\n    # add skeleton for sites where it should be always synced to\n    # usually it would be a backup site which is handled by separate\n    # background process\n    for site_name in self._get_always_accessible_sites(project_name):\n        if site_name not in attached_sites:\n            attached_sites[site_name] = (\n                create_metadata(site_name, created=False))\n    unique_sites = {\n        site[\"name\"]: site\n        for site in attached_sites.values()\n    }\n    return list(unique_sites.values())\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_active_site","title":"<code>get_active_site(project_name)</code>","text":"<p>Returns active (mine) site for project from settings.</p> Output logic <ul> <li>'studio' if Site Sync is disabled</li> <li>value from 'get_local_site_id' if active site is 'local'</li> <li>any other site name from local settings     or project settings (site could be forced from PS)</li> </ul> <p>Returns:</p> Name Type Description <code>str</code> <p>Site name.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_active_site(self, project_name):\n    \"\"\"Returns active (mine) site for project from settings.\n\n    Output logic:\n        - 'studio' if Site Sync is disabled\n        - value from 'get_local_site_id' if active site is 'local'\n        - any other site name from local settings\n            or project settings (site could be forced from PS)\n\n    Returns:\n        str: Site name.\n\n    \"\"\"\n    active_site_type = self.get_active_site_type(project_name)\n    if active_site_type == self.LOCAL_SITE:\n        return get_local_site_id()\n    return active_site_type\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_active_site_type","title":"<code>get_active_site_type(project_name, local_settings=None)</code>","text":"<p>Active site which is defined by artist.</p> <p>Unlike 'get_active_site' is this method also checking local settings where might be different active site set by user. The output is limited to \"studio\" and \"local\".</p> <p>This method is used by Anatomy.</p> Todos <p>Check if sync server is enabled for the project. - To be able to do that the sync settings MUST NOT be cached for     all projects at once. The sync settings preparation for all     projects is reasonable only in sync server loop. <code>local_settings</code> is probably obsolete in AYON</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project where to look for active site.</p> required <code>local_settings</code> <code>Optional[dict[str, Any]]</code> <p>Prepared local settings.</p> <code>None</code> <p>Returns:</p> Type Description <p>Literal[\"studio\", \"local\"]: Active site.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_active_site_type(self, project_name, local_settings=None):\n    \"\"\"Active site which is defined by artist.\n\n    Unlike 'get_active_site' is this method also checking local settings\n    where might be different active site set by user. The output is limited\n    to \"studio\" and \"local\".\n\n    This method is used by Anatomy.\n\n    Todos:\n        Check if sync server is enabled for the project.\n        - To be able to do that the sync settings MUST NOT be cached for\n            all projects at once. The sync settings preparation for all\n            projects is reasonable only in sync server loop.\n        `local_settings` is probably obsolete in AYON\n\n    Args:\n        project_name (str): Name of project where to look for active site.\n        local_settings (Optional[dict[str, Any]]): Prepared local settings.\n\n    Returns:\n        Literal[\"studio\", \"local\"]: Active site.\n    \"\"\"\n    if not self.enabled:\n        return \"studio\"\n\n    sync_project_settings = self.get_sync_project_setting(project_name)\n\n    if not sync_project_settings[\"enabled\"]:\n        return \"studio\"\n\n    return (\n        sync_project_settings[\"local_setting\"].get(\"active_site\")\n        or sync_project_settings[\"config\"][\"active_site\"]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_anatomy","title":"<code>get_anatomy(project_name)</code>","text":"<p>Get already created or newly created anatomy for project</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required Return <p>Anatomy: Project anatomy object.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_anatomy(self, project_name):\n    \"\"\"Get already created or newly created anatomy for project\n\n    Args:\n        project_name (str): Project name.\n\n    Return:\n        Anatomy: Project anatomy object.\n    \"\"\"\n    from ayon_core.pipeline import Anatomy\n\n    return self._anatomies.get(project_name) or Anatomy(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_enabled_projects","title":"<code>get_enabled_projects()</code>","text":"<p>Returns list of projects which have SiteSync enabled.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_enabled_projects(self):\n    \"\"\"Returns list of projects which have SiteSync enabled.\"\"\"\n    enabled_projects = []\n\n    if self.enabled:\n        for project_name in get_project_names():\n            if self.is_project_enabled(project_name):\n                enabled_projects.append(project_name)\n\n    return enabled_projects\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_launch_hook_paths","title":"<code>get_launch_hook_paths()</code>","text":"<p>Implementation for applications launch hooks.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>full absolut path to directory with hooks for the addon</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_launch_hook_paths(self):\n    \"\"\"Implementation for applications launch hooks.\n\n    Returns:\n        str: full absolut path to directory with hooks for the addon\n\n    \"\"\"\n    return os.path.join(\n        os.path.dirname(os.path.abspath(__file__)),\n        \"launch_hooks\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_local_file_path","title":"<code>get_local_file_path(project_name, site_name, file_path)</code>","text":"<p>Externalized for app.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>site_name</code> <code>str</code> <p>Site name.</p> required <code>file_path</code> <code>str</code> <p>File path from other site.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Resolved local path.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_local_file_path(self, project_name, site_name, file_path):\n    \"\"\"Externalized for app.\n\n    Args:\n        project_name (str): Project name.\n        site_name (str): Site name.\n        file_path (str): File path from other site.\n\n    Returns:\n        str: Resolved local path.\n\n    \"\"\"\n    handler = LocalDriveHandler(project_name, site_name)\n    local_file_path = handler.resolve_path(file_path)\n\n    return local_file_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_local_normalized_site","title":"<code>get_local_normalized_site(site_name)</code>","text":"<p>Normlize local site name.</p> <p>Return 'local' if 'site_name' is local id.</p> <p>In some places Settings or Local Settings require 'local' instead of real site name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Normalized site name.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_local_normalized_site(self, site_name):\n    \"\"\"Normlize local site name.\n\n     Return 'local' if 'site_name' is local id.\n\n    In some places Settings or Local Settings require 'local' instead\n    of real site name.\n\n    Returns:\n        str: Normalized site name.\n\n    \"\"\"\n    if site_name == get_local_site_id():\n        site_name = self.LOCAL_SITE\n\n    return site_name\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_loop_delay","title":"<code>get_loop_delay(project_name)</code>","text":"<pre><code>Return count of seconds before next synchronization loop starts\nafter finish of previous loop.\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>in seconds</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_loop_delay(self, project_name):\n    \"\"\"\n        Return count of seconds before next synchronization loop starts\n        after finish of previous loop.\n\n    Returns:\n        (int): in seconds\n    \"\"\"\n    if not project_name:\n        return 60\n\n    # TODO this is used in global loop it should not be based on\n    #   project settings.\n    ld = self.sync_project_settings[project_name][\"config\"][\"loop_delay\"]\n    return int(ld)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_progress_for_repre","title":"<code>get_progress_for_repre(*args, **kwargs)</code>","text":"<p>Calculates average progress for representation.</p> <p>If site has created_dt &gt;&gt; fully available &gt;&gt; progress == 1</p> <p>Could be calculated in aggregate if it would be too slow</p> <p>Returns:</p> Type Description <p>(dict) with active and remote sites progress</p> <p>{'studio': 1.0, 'gdrive': -1} - gdrive site is not present -1 is used to highlight the site should be added</p> <p>{'studio': 1.0, 'gdrive': 0.0} - gdrive site is present, not uploaded yet</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_progress_for_repre(self, *args, **kwargs):\n    \"\"\"Calculates average progress for representation.\n\n    If site has created_dt &gt;&gt; fully available &gt;&gt; progress == 1\n\n    Could be calculated in aggregate if it would be too slow\n\n    Returns:\n        (dict) with active and remote sites progress\n        {'studio': 1.0, 'gdrive': -1} - gdrive site is not present\n            -1 is used to highlight the site should be added\n        {'studio': 1.0, 'gdrive': 0.0} - gdrive site is present, not\n            uploaded yet\n\n    \"\"\"\n    sig_new = inspect.signature(self._get_progress_for_repre_new)\n    sig_old = inspect.signature(self._get_progress_for_repre_old)\n    try:\n        sig_new.bind(*args, **kwargs)\n        return self._get_progress_for_repre_new(*args, **kwargs)\n    except TypeError:\n        pass\n\n    try:\n        sig_old.bind(*args, **kwargs)\n        print(\n            \"Using old signature of 'get_progress_for_repre'\"\n            \" please add project name as first argument.\"\n        )\n        return self._get_progress_for_repre_old(*args, **kwargs)\n    except TypeError:\n        pass\n\n    return self._get_progress_for_repre_new(*args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_provider_for_site","title":"<code>get_provider_for_site(project_name=None, site=None)</code>","text":"<p>Get provider name for site (unique name across all projects).</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_provider_for_site(self, project_name=None, site=None):\n    \"\"\"Get provider name for site (unique name across all projects).\"\"\"\n    sites = {\n        self.DEFAULT_SITE: \"local_drive\",\n        self.LOCAL_SITE: \"local_drive\",\n        get_local_site_id(): \"local_drive\"\n    }\n\n    if site in sites.keys():\n        return sites[site]\n\n    # backward compatibility\n    if project_name:\n        proj_settings = self.get_sync_project_setting(project_name)\n        provider = (\n            proj_settings\n            .get(\"sites\", {})\n            .get(site, {})\n            .get(\"provider\")\n        )\n        if provider:\n            return provider\n\n    sync_sett = self.sync_studio_settings\n    for site_config in sync_sett.get(\"sites\"):\n        sites[site_config[\"name\"]] = site_config[\"provider\"]\n\n    return sites.get(site, \"N/A\")\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_remote_site","title":"<code>get_remote_site(project_name)</code>","text":"<p>Remote (theirs) site for project from settings.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_remote_site(self, project_name):\n    \"\"\"Remote (theirs) site for project from settings.\"\"\"\n    sync_project_settings = self.get_sync_project_setting(project_name)\n    remote_site = (\n        sync_project_settings[\"local_setting\"].get(\"remote_site\")\n        or sync_project_settings[\"config\"][\"remote_site\"]\n    )\n    if remote_site == self.LOCAL_SITE:\n        return get_local_site_id()\n\n    return remote_site\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_repre_info_for_versions","title":"<code>get_repre_info_for_versions(project_name, version_ids, active_site, remote_site)</code>","text":"<p>Returns representation for versions and sites combi</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name</p> required <code>version_ids</code> <code>Iterable[str]</code> <p>Version ids.</p> required <code>active_site</code> <code>str</code> <p>'local', 'studio' etc</p> required <code>remote_site</code> <code>str</code> <p>dtto</p> required <p>Returns:</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_repre_info_for_versions(\n    self, project_name, version_ids, active_site, remote_site\n):\n    \"\"\"Returns representation for versions and sites combi\n\n    Args:\n        project_name (str): Project name\n        version_ids (Iterable[str]): Version ids.\n        active_site (str): 'local', 'studio' etc\n        remote_site (str): dtto\n\n    Returns:\n\n    \"\"\"\n    version_ids = set(version_ids)\n    endpoint = \"{}/projects/{}/sitesync/state\".format(\n        self.endpoint_prefix, project_name\n    )\n\n    # get to upload\n    kwargs = {\n        \"localSite\": active_site,\n        \"remoteSite\": remote_site,\n        \"versionIdFilter\": list(version_ids)\n    }\n\n    # kwargs[\"representationId\"] = \"94dca33a-7705-11ed-8c0a-34e12d91d510\"\n\n    response = ayon_api.get(endpoint, **kwargs)\n    repre_states = response.data.get(\"representations\", [])\n    repre_info_by_version_id = {\n        version_id: {\n            \"id\": version_id,\n            \"repre_count\": 0,\n            \"avail_repre_local\": 0,\n            \"avail_repre_remote\": 0,\n        }\n        for version_id in version_ids\n    }\n    repre_states_by_version_id = defaultdict(list)\n    for repre_state in repre_states:\n        version_id = repre_state[\"versionId\"]\n        repre_states_by_version_id[version_id].append(repre_state)\n\n    for version_id, repre_states in repre_states_by_version_id.items():\n        repre_info = repre_info_by_version_id[version_id]\n        repre_info[\"repre_count\"] = len(repre_states)\n        repre_info[\"avail_repre_local\"] = sum(\n            self._is_available(repre_state, \"localStatus\")\n            for repre_state in repre_states\n        )\n        repre_info[\"avail_repre_remote\"] = sum(\n            self._is_available(repre_state, \"remoteStatus\")\n            for repre_state in repre_states\n        )\n\n    return list(repre_info_by_version_id.values())\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_repre_sync_state","title":"<code>get_repre_sync_state(project_name, representation_id, local_site_name, remote_site_name=None, **kwargs)</code>","text":"<p>Use server endpoint to get synchronization info for representation.</p> Warning <p>Logic of this</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_repre_sync_state(\n    self,\n    project_name,\n    representation_id,\n    local_site_name,\n    remote_site_name=None,\n    **kwargs\n):\n    \"\"\"Use server endpoint to get synchronization info for representation.\n\n    Warning:\n        Logic of this\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        local_site_name (str)\n        remote_site_name (str)\n        all other parameters for `Get Site Sync State` endpoint if\n            necessary\n\n    \"\"\"\n    repre_states = self._get_repres_state(\n        project_name,\n        {representation_id},\n        local_site_name,\n        remote_site_name,\n        **kwargs\n    )\n    if repre_states:\n        repre_state = repre_states[0]\n        if repre_state[\"localStatus\"][\"status\"] != -1:\n            return repre_state\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_representations_sync_state","title":"<code>get_representations_sync_state(project_name, representation_ids, local_site_name, remote_site_name=None, **kwargs)</code>","text":"<p>Use server endpoint to get synchronization info for representations.</p> <p>Calculates float progress based on progress of all files for repre. If repre is fully synchronized it returns 1, 0 for any other state.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> required <code>representation_ids</code> <code>list</code> <p>even single repre should be in []</p> required <p>Returns:</p> Type Description <p>dict[str, tuple[float, float]]: Progress by representation id.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_representations_sync_state(\n    self,\n    project_name,\n    representation_ids,\n    local_site_name,\n    remote_site_name=None,\n    **kwargs\n):\n    \"\"\"Use server endpoint to get synchronization info for representations.\n\n    Calculates float progress based on progress of all files for repre.\n    If repre is fully synchronized it returns 1, 0 for any other state.\n\n    Args:\n        project_name (str):\n        representation_ids (list): even single repre should be in []\n        local_site_name (str)\n        remote_site_name (str)\n        all other parameters for `Get Site Sync State` endpoint if\n            necessary.\n\n    Returns:\n        dict[str, tuple[float, float]]: Progress by representation id.\n\n    \"\"\"\n    repre_states = self._get_repres_state(\n        project_name,\n        representation_ids,\n        local_site_name,\n        remote_site_name,\n        **kwargs\n    )\n    states = {}\n    for repre_state in repre_states:\n        repre_files_count = len(repre_state[\"files\"])\n\n        repre_local_status = repre_state[\"localStatus\"][\"status\"]\n        repre_local_progress = 0\n        if repre_local_status == SiteSyncStatus.OK:\n            repre_local_progress = 1\n        elif repre_local_status == SiteSyncStatus.IN_PROGRESS:\n            local_sum = sum(\n                file_info[\"localStatus\"].get(\"progress\", 0)\n                for file_info in repre_state[\"files\"]\n            )\n            repre_local_progress = local_sum / repre_files_count\n\n        repre_remote_status = repre_state[\"remoteStatus\"][\"status\"]\n        repre_remote_progress = 0\n        if repre_remote_status == SiteSyncStatus.OK:\n            repre_remote_progress = 1\n        elif repre_remote_status == SiteSyncStatus.IN_PROGRESS:\n            remote_sum = sum(\n                file_info[\"remoteStatus\"].get(\"progress\", 0)\n                for file_info in repre_state[\"files\"]\n            )\n            repre_remote_progress = remote_sum / repre_files_count\n\n        states[repre_state[\"representationId\"]] = (\n            repre_local_progress,\n            repre_remote_progress\n        )\n\n    return states\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_site_icons","title":"<code>get_site_icons()</code>","text":"<p>Icons for sites.</p> <p>Returns:</p> Type Description <p>dict[str, str]: Path to icon by site.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_site_icons(self):\n    \"\"\"Icons for sites.\n\n    Returns:\n        dict[str, str]: Path to icon by site.\n\n    \"\"\"\n    resource_path = os.path.join(\n        SYNC_ADDON_DIR, \"providers\", \"resources\"\n    )\n    icons = {}\n    for file_path in os.listdir(resource_path):\n        if not file_path.endswith(\".png\"):\n            continue\n        provider_name, _ = os.path.splitext(os.path.basename(file_path))\n        icons[provider_name] = {\n            \"type\": \"path\",\n            \"path\": os.path.join(resource_path, file_path)\n        }\n    return icons\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_site_root_overrides","title":"<code>get_site_root_overrides(project_name, site_name, local_settings=None)</code>","text":"<p>Get root overrides for project on a site.</p> <p>Implemented to be used in 'Anatomy' for other than 'studio' site.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project for which root overrides should be received.</p> required <code>site_name</code> <code>str</code> <p>Name of site for which should be received roots.</p> required <code>local_settings</code> <code>Optional[dict[str, Any]]</code> <p>Prepare local settigns values.</p> <code>None</code> <p>Returns:</p> Type Description <p>Union[dict[str, Any], None]: Root overrides for this machine.</p> <p>{\"work\": \"c:/projects_local\"}</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_site_root_overrides(\n    self, project_name, site_name, local_settings=None\n):\n    \"\"\"Get root overrides for project on a site.\n\n    Implemented to be used in 'Anatomy' for other than 'studio' site.\n\n    Args:\n        project_name (str): Project for which root overrides should be\n            received.\n        site_name (str): Name of site for which should be received roots.\n        local_settings (Optional[dict[str, Any]]): Prepare local settigns\n            values.\n\n    Returns:\n        Union[dict[str, Any], None]: Root overrides for this machine.\n\n        {\"work\": \"c:/projects_local\"}\n    \"\"\"\n\n    # Validate that site name is valid\n    if site_name not in (\"studio\", \"local\"):\n        # Consider local site id as 'local'\n        if site_name != get_local_site_id():\n            raise ValueError((\n                \"Root overrides are available only for\"\n                \" default sites not for \\\"{}\\\"\"\n            ).format(site_name))\n        site_name = \"local\"\n\n    sitesync_settings = self.get_sync_project_setting(project_name)\n\n    roots = {}\n    if not sitesync_settings[\"enabled\"]:\n        return roots\n    local_project_settings = sitesync_settings[\"local_setting\"]\n    if site_name == \"local\":\n        for root_info in local_project_settings[\"local_roots\"]:\n            roots[root_info[\"name\"]] = root_info[\"path\"]\n\n    return roots\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_sync_project_setting","title":"<code>get_sync_project_setting(project_name, exclude_locals=False, cached=True)</code>","text":"<p>Handles pulling sitesync's settings for enabled 'project_name'</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>used in project settings</p> required <code>exclude_locals</code> <code>bool</code> <p>ignore overrides from Local Settings</p> <code>False</code> <code>cached</code> <code>bool</code> <p>use pre-cached values, or return fresh ones cached values needed for single loop (with all overrides) fresh values needed for Local settings (without overrides)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>settings dictionary for the enabled project, empty if no settings or sync is disabled</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_sync_project_setting(\n    self, project_name, exclude_locals=False, cached=True\n):\n    \"\"\" Handles pulling sitesync's settings for enabled 'project_name'\n\n    Args:\n        project_name (str): used in project settings\n        exclude_locals (bool): ignore overrides from Local Settings\n        cached (bool): use pre-cached values, or return fresh ones\n            cached values needed for single loop (with all overrides)\n            fresh values needed for Local settings (without overrides)\n\n    Returns:\n        dict: settings dictionary for the enabled project,\n            empty if no settings or sync is disabled\n\n    \"\"\"\n    # presets set already, do not call again and again\n    # self.log.debug(\"project preset {}\".format(self.presets))\n    if not cached:\n        return self._prepare_sync_project_settings(exclude_locals)\\\n            [project_name]\n\n    if (\n        not self.sync_project_settings\n        or not self.sync_project_settings.get(project_name)\n    ):\n        self.set_sync_project_settings(exclude_locals)\n    return self.sync_project_settings.get(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_sync_representations","title":"<code>get_sync_representations(project_name, active_site, remote_site, limit=10)</code>","text":"<pre><code>Get representations that should be synced, these could be\nrecognised by presence of document in 'files.sites', where key is\na provider (GDrive, S3) and value is empty document or document\nwithout 'created_dt' field. (Don't put null to 'created_dt'!).\n\nQuerying of 'to-be-synched' files is offloaded to Mongod for\nbetter performance. Goal is to get as few representations as\npossible.\n</code></pre> <p>Args:     project_name (str):     active_site (str): identifier of current active site (could be         'local_0' when working from home, 'studio' when working in the         studio (default)     remote_site (str): identifier of remote site I want to sync to</p> <p>Returns:</p> Type Description <p>list[dict]: Representation states.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>@time_function\ndef get_sync_representations(\n    self, project_name, active_site, remote_site, limit=10\n):\n    \"\"\"\n        Get representations that should be synced, these could be\n        recognised by presence of document in 'files.sites', where key is\n        a provider (GDrive, S3) and value is empty document or document\n        without 'created_dt' field. (Don't put null to 'created_dt'!).\n\n        Querying of 'to-be-synched' files is offloaded to Mongod for\n        better performance. Goal is to get as few representations as\n        possible.\n    Args:\n        project_name (str):\n        active_site (str): identifier of current active site (could be\n            'local_0' when working from home, 'studio' when working in the\n            studio (default)\n        remote_site (str): identifier of remote site I want to sync to\n\n    Returns:\n        list[dict]: Representation states.\n\n    \"\"\"\n    self.log.debug(\"Check representations for: {}-{}\".format(\n        active_site, remote_site\n    ))\n\n    endpoint = \"{}/{}/state\".format(\n        self.endpoint_prefix, project_name\n    )\n\n    # get to upload\n    kwargs = {\n        \"localSite\": active_site,\n        \"remoteSite\": remote_site,\n        \"localStatusFilter\": [SiteSyncStatus.OK],\n        \"remoteStatusFilter\": [SiteSyncStatus.QUEUED],\n    }\n\n    response = ayon_api.get(endpoint, **kwargs)\n    if response.status_code not in [200, 204]:\n        raise RuntimeError(\n            \"Cannot get representations for sync with code {}\".format(\n                response.status_code\n            )\n        )\n\n    repre_states = response.data[\"representations\"]\n\n    # get to download\n    if len(repre_states) &lt; limit:\n        kwargs[\"localStatusFilter\"] = [SiteSyncStatus.QUEUED]\n        kwargs[\"remoteStatusFilter\"] = [SiteSyncStatus.OK]\n\n        response = ayon_api.get(endpoint, **kwargs)\n        repre_states.extend(response.data[\"representations\"])\n\n    return repre_states\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.get_version_availability","title":"<code>get_version_availability(project_name, version_ids, local_site_name, remote_site_name, **kwargs)</code>","text":"<p>Returns aggregated state for version ids.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>version_ids</code> <code>Iterable[str]</code> <p>Version ids.</p> required <code>local_site_name</code> <code>str</code> <p>Local site name.</p> required <code>remote_site_name</code> <code>str</code> <p>Remote site name.</p> required <code>kwargs</code> <p>All other parameters for <code>Get Site Sync State</code> endpoint if necessary.</p> <code>{}</code> <p>Returns:</p> Type Description <p>dict[str, tuple[float, float]]: Status by version id. Example: {version_id: (local_status, remote_status)}</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def get_version_availability(\n    self,\n    project_name,\n    version_ids,\n    local_site_name,\n    remote_site_name,\n    **kwargs\n):\n    \"\"\"Returns aggregated state for version ids.\n\n    Args:\n        project_name (str): Project name.\n        version_ids (Iterable[str]): Version ids.\n        local_site_name (str): Local site name.\n        remote_site_name (str): Remote site name.\n        kwargs: All other parameters for `Get Site Sync State` endpoint if\n            necessary.\n\n    Returns:\n        dict[str, tuple[float, float]]: Status by version id.\n            Example: {version_id: (local_status, remote_status)}\n\n    \"\"\"\n    version_ids = list(version_ids)\n    payload_dict = {\n        \"localSite\": local_site_name,\n        \"remoteSite\": remote_site_name,\n        \"versionIdsFilter\": version_ids\n    }\n    payload_dict.update(kwargs)\n\n    endpoint = \"{}/{}/state\".format(\n        self.endpoint_prefix, project_name\n    )\n\n    response = ayon_api.get(endpoint, **payload_dict)\n    if response.status_code != 200:\n        raise RuntimeError(\n            \"Cannot get sync state for versions {}\".format(\n                version_ids\n            )\n        )\n\n    version_statuses = {\n        version_id: (0, 0)\n        for version_id in version_ids\n    }\n\n    repre_avail_by_version_id = defaultdict(list)\n    for repre_avail in response.data[\"representations\"]:\n        version_id = repre_avail[\"versionId\"]\n        repre_avail_by_version_id[version_id].append(repre_avail)\n\n    for version_id, repre_avails in repre_avail_by_version_id.items():\n        avail_local = sum(\n            int(\n                repre_avail[\"localStatus\"][\"status\"] == SiteSyncStatus.OK\n            )\n            for repre_avail in repre_avails\n        )\n        avail_remote = sum(\n            int(\n                repre_avail[\"remoteStatus\"][\"status\"] == SiteSyncStatus.OK\n            )\n            for repre_avail in repre_avails\n        )\n        version_statuses[version_id] = (avail_local, avail_remote)\n\n    return version_statuses\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.handle_alternate_site","title":"<code>handle_alternate_site(project_name, representation_id, processed_site, file_id)</code>","text":"<p>For special use cases where one site vendors another.</p> <p>Current use case is sftp site vendoring (exposing) same data as regular site (studio). Each site is accessible for different audience. 'studio' for artists in a studio, 'sftp' for externals.</p> <p>Change of file status on one site actually means same change on 'alternate' site. (eg. artists publish to 'studio', 'sftp' is using same location &gt;&gt; file is accessible on 'sftp' site right away.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>processed_site</code> <code>str</code> <p>Real site_name of published/uploaded file</p> required <code>file_id</code> <code>str</code> <p>File id of file handled.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def handle_alternate_site(\n    self, project_name, representation_id, processed_site, file_id\n):\n    \"\"\"\n    For special use cases where one site vendors another.\n\n    Current use case is sftp site vendoring (exposing) same data as\n    regular site (studio). Each site is accessible for different\n    audience. 'studio' for artists in a studio, 'sftp' for externals.\n\n    Change of file status on one site actually means same change on\n    'alternate' site. (eg. artists publish to 'studio', 'sftp' is using\n    same location &gt;&gt; file is accessible on 'sftp' site right away.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        processed_site (str): Real site_name of published/uploaded file\n        file_id (str): File id of file handled.\n\n    \"\"\"\n    sites = self._transform_sites_from_settings(self.sync_studio_settings)\n    sites[self.DEFAULT_SITE] = {\n        \"provider\": \"local_drive\",\n        \"alternative_sites\": []\n    }\n\n    alternate_sites = []\n    for site_name, site_info in sites.items():\n        conf_alternative_sites = site_info.get(\"alternative_sites\", [])\n        if processed_site in conf_alternative_sites:\n            alternate_sites.append(site_name)\n            continue\n        if processed_site == site_name and conf_alternative_sites:\n            alternate_sites.extend(conf_alternative_sites)\n            continue\n\n    if not alternate_sites:\n        return\n\n    sync_state = self.get_repre_sync_state(\n        project_name,\n        representation_id,\n        processed_site\n    )\n    # not yet available on processed_site, wont update alternate site yet\n    if not sync_state:\n        return\n    for file_info in sync_state[\"files\"]:\n        # expose status of remote site, it is expected on the server\n        file_info[\"status\"] = file_info[\"remoteStatus\"][\"status\"]\n\n    payload_dict = {\"files\": sync_state[\"files\"]}\n\n    alternate_sites = set(alternate_sites)\n    for alt_site in alternate_sites:\n        self.log.debug(\"Adding alternate {} to {}\".format(\n            alt_site, representation_id))\n\n        self._set_state_sync_state(\n            project_name,\n            representation_id,\n            alt_site,\n            payload_dict\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.initialize","title":"<code>initialize(addon_settings)</code>","text":"<p>Called during Addon Manager creation.</p> <p>Collects needed data, checks asyncio presence. Sets 'enabled' according to global settings for the addon. Shouldn't be doing any initialization, that's a job for 'tray_init'</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def initialize(self, addon_settings):\n    \"\"\"Called during Addon Manager creation.\n\n    Collects needed data, checks asyncio presence.\n    Sets 'enabled' according to global settings for the addon.\n    Shouldn't be doing any initialization, that's a job for 'tray_init'\n    \"\"\"\n\n    # some parts of code need to run sequentially, not in async\n    self.lock = None\n    self._sync_studio_settings = None\n    # settings for all enabled projects for sync\n    self._sync_project_settings = None\n    self.sitesync_thread = None  # asyncio requires new thread\n\n    self._paused = False\n    self._paused_projects = set()\n    self._paused_representations = set()\n    self._anatomies = {}\n\n    # list of long blocking tasks\n    self.long_running_tasks = deque()\n    # projects that long tasks are running on\n    self.projects_processed = set()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.is_paused","title":"<code>is_paused()</code>","text":"<p>Is server paused</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_paused(self):\n    \"\"\" Is server paused \"\"\"\n    return self._paused\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.is_project_enabled","title":"<code>is_project_enabled(project_name, single=False)</code>","text":"<p>Checks if 'project_name' is enabled for syncing. 'get_sync_project_setting' is potentially expensive operation (pulls settings for all projects if cached version is not available), using project_settings for specific project should be faster. Args:     project_name (str)     single (bool): use 'get_addon_project_settings' method</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_project_enabled(self, project_name, single=False):\n    \"\"\"Checks if 'project_name' is enabled for syncing.\n    'get_sync_project_setting' is potentially expensive operation (pulls\n    settings for all projects if cached version is not available), using\n    project_settings for specific project should be faster.\n    Args:\n        project_name (str)\n        single (bool): use 'get_addon_project_settings' method\n    \"\"\"\n    if self.enabled:\n        if single:\n            project_settings = get_addon_project_settings(\n                self.name, self.version, project_name\n            )\n        else:\n            project_settings = self.get_sync_project_setting(project_name)\n        if project_settings and project_settings.get(\"enabled\"):\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.is_project_paused","title":"<code>is_project_paused(project_name, check_parents=False)</code>","text":"<p>Is project sync paused.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> required <code>check_parents</code> <code>bool</code> <p>check if server itself is not paused</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is project paused.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_project_paused(self, project_name, check_parents=False):\n    \"\"\"Is project sync paused.\n\n    Args:\n        project_name (str):\n        check_parents (bool): check if server itself\n            is not paused\n\n    Returns:\n        bool: Is project paused.\n\n    \"\"\"\n    is_paused = project_name in self._paused_projects\n    if check_parents:\n        is_paused = is_paused or self.is_paused()\n    return is_paused\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.is_representation_on_site","title":"<code>is_representation_on_site(project_name, representation_id, site_name, max_retries=None)</code>","text":"<p>Check if representation has all files available on site.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if representation has all files correctly on the site.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_representation_on_site(\n    self, project_name, representation_id, site_name, max_retries=None\n):\n    \"\"\"Check if representation has all files available on site.\n\n    Args:\n        project_name (str)\n        representation_id (str)\n        site_name (str)\n        max_retries (int) (optional) - provide only if method used in while\n            loop to bail out\n\n    Returns:\n        bool: True if representation has all files correctly on the site.\n\n    Raises:\n          ValueError  Only If 'max_retries' provided if upload/download\n            failed too many times to limit infinite loop check.\n\n    \"\"\"\n    representation_status = self.get_repre_sync_state(\n        project_name, representation_id, site_name)\n    if not representation_status:\n        return False\n\n    if site_name == get_local_site_id():\n        status = representation_status[\"localStatus\"]\n    else:\n        status = representation_status[\"remoteStatus\"]\n\n    if max_retries:\n        tries = status.get(\"retries\", 0)\n        if tries &gt;= max_retries:\n            raise ValueError(\"Failed too many times\")\n\n    return status[\"status\"] == SiteSyncStatus.OK\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.is_representation_paused","title":"<code>is_representation_paused(representation_id, check_parents=False, project_name=None)</code>","text":"<p>Is representation paused.</p> <p>Parameters:</p> Name Type Description Default <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>check_parents</code> <code>bool</code> <p>Check if parent project or server itself are not paused.</p> <code>False</code> <code>project_name</code> <code>str</code> <p>Project to check if paused.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is representation paused now.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def is_representation_paused(\n    self, representation_id, check_parents=False, project_name=None\n):\n    \"\"\"Is representation paused.\n\n    Args:\n        representation_id (str): Representation id.\n        check_parents (bool): Check if parent project or server itself\n            are not paused.\n        project_name (str): Project to check if paused.\n\n        if 'check_parents', 'project_name' should be set too\n\n    Returns:\n        bool: Is representation paused now.\n\n    \"\"\"\n    is_paused = representation_id in self._paused_representations\n    if check_parents and project_name:\n        is_paused = (\n            is_paused\n            or self.is_project_paused(project_name)\n            or self.is_paused()\n        )\n    return is_paused\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.pause_project","title":"<code>pause_project(project_name)</code>","text":"<p>Pause sync of whole project.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def pause_project(self, project_name):\n    \"\"\"Pause sync of whole project.\n\n    Args:\n        project_name (str): Project name.\n\n    \"\"\"\n    self.log.info(\"Pausing SiteSync for {}\".format(project_name))\n    self._paused_projects.add(project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.pause_representation","title":"<code>pause_representation(project_name, representation_id, site_name)</code>","text":"<p>Pause sync of representation entity on site.</p> <p>Sets 'representation_id' as paused, eg. no syncing should be     happening on it.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>site_name</code> <code>str</code> <p>Site name 'gdrive', 'studio' etc.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def pause_representation(\n    self, project_name, representation_id, site_name\n):\n    \"\"\"Pause sync of representation entity on site.\n\n    Sets 'representation_id' as paused, eg. no syncing should be\n        happening on it.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        site_name (str): Site name 'gdrive', 'studio' etc.\n\n    \"\"\"\n    self.log.info(\"Pausing SiteSync for {}\".format(representation_id))\n    self._paused_representations.add(representation_id)\n    repre_entity = get_representation_by_id(\n        project_name, representation_id\n    )\n    self.update_db(project_name, repre_entity, site_name, pause=True)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.pause_server","title":"<code>pause_server()</code>","text":"<p>Pause sync server.</p> <p>It won't check anything, not uploading/downloading...</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def pause_server(self):\n    \"\"\"Pause sync server.\n\n    It won't check anything, not uploading/downloading...\n    \"\"\"\n    self.log.info(\"Pausing SiteSync\")\n    self._paused = True\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.remove_site","title":"<code>remove_site(project_name, representation_id, site_name, remove_local_files=False)</code>","text":"<p>Removes site for particular representation in project.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>project name (must match DB)</p> required <code>representation_id</code> <code>str</code> <p>MongoDB _id value</p> required <code>site_name</code> <code>str</code> <p>name of configured and active site</p> required <code>remove_local_files</code> <code>bool</code> <p>remove only files for 'local_id' site</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Throws if any issue.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def remove_site(\n    self,\n    project_name,\n    representation_id,\n    site_name,\n    remove_local_files=False\n):\n    \"\"\"Removes site for particular representation in project.\n\n    Args:\n        project_name (str): project name (must match DB)\n        representation_id (str): MongoDB _id value\n        site_name (str): name of configured and active site\n        remove_local_files (bool): remove only files for 'local_id'\n            site\n\n    Raises:\n        ValueError: Throws if any issue.\n\n    \"\"\"\n    if not self.get_sync_project_setting(project_name):\n        raise ValueError(\"Project not configured\")\n\n    sync_info = self.get_repre_sync_state(\n        project_name,\n        representation_id,\n        site_name\n    )\n    if not sync_info:\n        msg = \"Site {} not found\".format(site_name)\n        self.log.warning(msg)\n        return\n\n    endpoint = \"{}/{}/state/{}/{}\".format(\n        self.endpoint_prefix,\n        project_name,\n        representation_id,\n        site_name\n    )\n\n    response = ayon_api.delete(endpoint)\n    if response.status_code not in [200, 204]:\n        raise RuntimeError(\"Cannot update status\")\n\n    if remove_local_files:\n        self._remove_local_file(project_name, representation_id, site_name)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.reset_site_on_representation","title":"<code>reset_site_on_representation(project_name, representation_id, side=None, file_id=None, site_name=None)</code>","text":"<pre><code>Reset information about synchronization for particular 'file_id'\nand provider.\nUseful for testing or forcing file to be reuploaded.\n\n'side' and 'site_name' are disjunctive.\n\n'side' is used for resetting local or remote side for\ncurrent user for repre.\n\n'site_name' is used to set synchronization for particular site.\nShould be used when repre should be synced to new site.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of project (eg. collection) in DB</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>file_id</code> <code>str</code> <p>File id in representation.</p> <code>None</code> <code>side</code> <code>str</code> <p>Local or remote side.</p> <code>None</code> <code>site_name</code> <code>str</code> <p>for adding new site</p> <code>None</code> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def reset_site_on_representation(\n    self,\n    project_name,\n    representation_id,\n    side=None,\n    file_id=None,\n    site_name=None\n):\n    \"\"\"\n        Reset information about synchronization for particular 'file_id'\n        and provider.\n        Useful for testing or forcing file to be reuploaded.\n\n        'side' and 'site_name' are disjunctive.\n\n        'side' is used for resetting local or remote side for\n        current user for repre.\n\n        'site_name' is used to set synchronization for particular site.\n        Should be used when repre should be synced to new site.\n\n    Args:\n        project_name (str): name of project (eg. collection) in DB\n        representation_id (str): Representation id.\n        file_id (str): File id in representation.\n        side (str): Local or remote side.\n        site_name (str): for adding new site\n\n    Raises:\n        SiteAlreadyPresentError - if adding already existing site and\n            not 'force'\n        ValueError - other errors (repre not found, misconfiguration)\n    \"\"\"\n    representation = get_representation_by_id(\n        project_name, representation_id\n    )\n    if not representation:\n        raise ValueError(\n            \"Representation {} not found in {}\".format(\n                representation_id, project_name\n            )\n        )\n\n    if side and site_name:\n        raise ValueError(\n            \"Misconfiguration, only one of side and\"\n            \" site_name arguments should be passed.\"\n        )\n\n    if side:\n        if side == \"local\":\n            site_name = self.get_active_site(project_name)\n        else:\n            site_name = self.get_remote_site(project_name)\n\n    self.add_site(\n        project_name, representation_id, site_name, file_id, force=True\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.reset_timer","title":"<code>reset_timer()</code>","text":"<p>Called when waiting for next loop should be skipped.</p> <p>In case of user's involvement (reset site), start that right away.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def reset_timer(self):\n    \"\"\"\n        Called when waiting for next loop should be skipped.\n\n        In case of user's involvement (reset site), start that right away.\n    \"\"\"\n\n    if not self.enabled:\n        return\n\n    if self.sitesync_thread is None:\n        self._reset_timer_with_rest_api()\n    else:\n        self.sitesync_thread.reset_timer()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.server_init","title":"<code>server_init()</code>","text":"<p>Actual initialization of Sync Server.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def server_init(self):\n    \"\"\"Actual initialization of Sync Server.\"\"\"\n    # import only in tray or Python3, because of Python2 hosts\n    if not self.enabled:\n        return\n\n    from .sitesync import SiteSyncThread\n\n    self.lock = threading.Lock()\n\n    self.sitesync_thread = SiteSyncThread(self)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.set_sync_project_settings","title":"<code>set_sync_project_settings(exclude_locals=False)</code>","text":"<p>Set sync_project_settings for all projects (caching) Args:     exclude_locals (bool): ignore overrides from Local Settings For performance</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def set_sync_project_settings(self, exclude_locals=False):\n    \"\"\"\n        Set sync_project_settings for all projects (caching)\n        Args:\n            exclude_locals (bool): ignore overrides from Local Settings\n        For performance\n    \"\"\"\n    sync_project_settings = self._prepare_sync_project_settings(\n        exclude_locals)\n\n    self._sync_project_settings = sync_project_settings\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.tray_exit","title":"<code>tray_exit()</code>","text":"<p>Stops sync thread if running.</p> <p>Called from Addon Manager</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def tray_exit(self):\n    \"\"\"Stops sync thread if running.\n\n    Called from Addon Manager\n    \"\"\"\n    self.server_exit()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.tray_init","title":"<code>tray_init()</code>","text":"<p>Initialization of Site Sync Server for Tray.</p> <p>Called when tray is initialized, it checks if addon should be enabled. If not, no initialization necessary.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def tray_init(self):\n    \"\"\"Initialization of Site Sync Server for Tray.\n\n    Called when tray is initialized, it checks if addon should be\n    enabled. If not, no initialization necessary.\n    \"\"\"\n    self.server_init()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.tray_start","title":"<code>tray_start()</code>","text":"<p>Triggered when Tray is started.</p> <p>Checks if configuration presets are available and if there is any provider ('gdrive', 'S3') that is activated (eg. has valid credentials).</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def tray_start(self):\n    \"\"\"Triggered when Tray is started.\n\n    Checks if configuration presets are available and if there is\n    any provider ('gdrive', 'S3') that is activated\n    (eg. has valid credentials).\n    \"\"\"\n    self.server_start()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.unpause_project","title":"<code>unpause_project(project_name)</code>","text":"<p>Unpause sync of whole project.</p> <p>Does not fail or warn if project wasn't paused.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def unpause_project(self, project_name):\n    \"\"\"Unpause sync of whole project.\n\n    Does not fail or warn if project wasn't paused.\n\n    Args:\n        project_name (str): Project name.\n\n    \"\"\"\n    self.log.info(\"Unpausing SiteSync for {}\".format(project_name))\n    try:\n        self._paused_projects.remove(project_name)\n    except KeyError:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.unpause_representation","title":"<code>unpause_representation(project_name, representation_id, site_name)</code>","text":"<p>Unpause sync of representation entity on site.</p> <p>Does not fail or warn if repre wasn't paused.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>representation_id</code> <code>str</code> <p>Representation id.</p> required <code>site_name</code> <code>str</code> <p>Site name 'gdrive', 'studio' etc.</p> required Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def unpause_representation(\n    self, project_name, representation_id, site_name\n):\n    \"\"\"Unpause sync of representation entity on site.\n\n    Does not fail or warn if repre wasn't paused.\n\n    Args:\n        project_name (str): Project name.\n        representation_id (str): Representation id.\n        site_name (str): Site name 'gdrive', 'studio' etc.\n    \"\"\"\n    self.log.info(\"Unpausing SiteSync for {}\".format(representation_id))\n    try:\n        self._paused_representations.remove(representation_id)\n    except KeyError:\n        pass\n    # self.paused_representations is not persistent\n    repre_entity = get_representation_by_id(\n        project_name, representation_id\n    )\n    self.update_db(project_name, repre_entity, site_name, pause=False)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.unpause_server","title":"<code>unpause_server()</code>","text":"<p>Unpause server sync.</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def unpause_server(self):\n    \"\"\"Unpause server sync.\"\"\"\n    self.log.info(\"Unpausing SiteSync\")\n    self._paused = False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.update_db","title":"<code>update_db(project_name, repre_status, site_name, new_file_id=None, file=None, side=None, error=None, progress=None, priority=None, pause=None)</code>","text":"<p>Update 'provider' portion of records in DB.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Project name. Force to db connection as each file might come from different collection.</p> required <code>repre_status</code> <code>dict</code> <p>Representation status from sitesync database.</p> required <code>site_name</code> <code>str</code> <p>Site name.</p> required <code>new_file_id</code> <code>Optional[str]</code> <p>File id of new file.</p> <code>None</code> <code>file</code> <code>dict[str, Any]</code> <p>info about processed file (pulled from DB)</p> <code>None</code> <code>side</code> <code>str</code> <p>'local' | 'remote'</p> <code>None</code> <code>error</code> <code>str</code> <p>exception message</p> <code>None</code> <code>progress</code> <code>float</code> <p>0-1 of progress of upload/download</p> <code>None</code> <code>priority</code> <code>int</code> <p>0-100 set priority</p> <code>None</code> <code>pause</code> <code>bool</code> <p>stop synchronizing (only before starting of download, upload)</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def update_db(\n    self,\n    project_name,\n    repre_status,\n    site_name,\n    new_file_id=None,\n    file=None,\n    side=None,\n    error=None,\n    progress=None,\n    priority=None,\n    pause=None\n):\n    \"\"\"Update 'provider' portion of records in DB.\n\n    Args:\n        project_name (str): Project name. Force to db connection as\n            each file might come from different collection.\n        repre_status (dict): Representation status from sitesync database.\n        site_name (str): Site name.\n        new_file_id (Optional[str]): File id of new file.\n        file (dict[str, Any]): info about processed file (pulled from DB)\n        side (str): 'local' | 'remote'\n        error (str): exception message\n        progress (float): 0-1 of progress of upload/download\n        priority (int): 0-100 set priority\n        pause (bool): stop synchronizing (only before starting of download,\n            upload)\n\n    Returns:\n        None\n    \"\"\"\n    files_status = []\n    for file_status in repre_status[\"files\"]:\n        status_entity = copy.deepcopy(\n            file_status[\"{}Status\".format(side)]\n        )\n        status_entity[\"fileHash\"] = file_status[\"fileHash\"]\n        status_entity[\"id\"] = file_status[\"id\"]\n        if file_status[\"fileHash\"] == file[\"fileHash\"]:\n            if new_file_id:\n                status_entity[\"status\"] = SiteSyncStatus.OK\n                status_entity.pop(\"message\")\n                status_entity.pop(\"retries\")\n            elif progress is not None:\n                status_entity[\"status\"] = SiteSyncStatus.IN_PROGRESS\n                status_entity[\"progress\"] = progress\n            elif error:\n                max_retries = int(\n                    self.sync_project_settings\n                    [project_name]\n                    [\"config\"]\n                    [\"retry_cnt\"]\n                )\n                tries = status_entity.get(\"retries\", 0)\n                tries += 1\n                status_entity[\"retries\"] = tries\n                status_entity[\"message\"] = error\n                if tries &gt;= max_retries:\n                    status_entity[\"status\"] = SiteSyncStatus.FAILED\n            elif pause is not None:\n                if pause:\n                    status_entity[\"pause\"] = True\n                else:\n                    status_entity.remove(\"pause\")\n            files_status.append(status_entity)\n\n    representation_id = repre_status[\"representationId\"]\n\n    endpoint = \"{}/{}/state/{}/{}\".format(\n        self.endpoint_prefix,\n        project_name,\n        representation_id,\n        site_name)\n\n    # get to upload\n    kwargs = {\n        \"files\": files_status\n    }\n\n    if priority:\n        kwargs[\"priority\"] = priority\n\n    response = ayon_api.post(endpoint, **kwargs)\n    if response.status_code not in [200, 204]:\n        raise RuntimeError(\"Cannot update status\")\n\n    if progress is not None or priority is not None:\n        return\n\n    status = \"failed\"\n    error_str = \"with error {}\".format(error)\n    if new_file_id:\n        status = \"succeeded with id {}\".format(new_file_id)\n        error_str = \"\"\n\n    source_file = file.get(\"path\", \"\")\n\n    self.log.debug(\n        \"File for {} - {source_file} process {status} {error_str}\".format(\n            representation_id,\n            status=status,\n            source_file=source_file,\n            error_str=error_str\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/addon.html#client.ayon_sitesync.addon.SiteSyncAddon.validate_project","title":"<code>validate_project(project_name, site_name, reset_missing=False)</code>","text":"<p>Validate 'project_name' of 'site_name' and its local files</p> <p>If file present and not marked with a 'site_name' in DB, DB is updated with site name and file modified date.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>project name</p> required <code>site_name</code> <code>str</code> <p>active site name</p> required <code>reset_missing</code> <code>bool</code> <p>if True reset site in DB if missing physically to be resynched</p> <code>False</code> Source code in <code>client/ayon_sitesync/addon.py</code> <pre><code>def validate_project(self, project_name, site_name, reset_missing=False):\n    \"\"\"Validate 'project_name' of 'site_name' and its local files\n\n    If file present and not marked with a 'site_name' in DB, DB is\n    updated with site name and file modified date.\n\n    Args:\n        project_name (str): project name\n        site_name (str): active site name\n        reset_missing (bool): if True reset site in DB if missing\n            physically to be resynched\n    \"\"\"\n    self.log.debug(\"Validation of {} for {} started\".format(\n        project_name, site_name\n    ))\n    repre_entities = list(get_representations(project_name))\n    if not repre_entities:\n        self.log.debug(\"No repre found\")\n        return\n\n    sites_added = 0\n    sites_reset = 0\n    repre_ids = [repre[\"id\"] for repre in repre_entities]\n    repre_states = self.get_representations_sync_state(\n        project_name, repre_ids, site_name, site_name)\n\n    for repre_entity in repre_entities:\n        repre_id = repre_entity[\"id\"]\n        is_on_site = False\n        repre_state = repre_states.get(repre_id)\n        if repre_state:\n            is_on_site = repre_state[0] == SiteSyncStatus.OK\n        for repre_file in repre_entity.get(\"files\", []):\n            file_path = repre_file.get(\"path\", \"\")\n            local_file_path = self.get_local_file_path(\n                project_name, site_name, file_path\n            )\n\n            file_exists = (\n                local_file_path and os.path.exists(local_file_path)\n            )\n            if not is_on_site:\n                if file_exists:\n                    self.log.debug(\n                        f\"Adding presence on site '{site_name}' for \"\n                        f\"'{repre_id}'\"\n                    )\n                    self.add_site(\n                        project_name,\n                        repre_id,\n                        site_name=site_name,\n                        file_id=repre_file[\"id\"],\n                        force=True,\n                        status=SiteSyncStatus.OK\n                    )\n                    sites_added += 1\n            else:\n                if not file_exists and reset_missing:\n                    self.log.debug(\n                        \"Resetting site {} for {}\".format(\n                            site_name, repre_id\n                        ))\n                    self.reset_site_on_representation(\n                        project_name,\n                        repre_id,\n                        site_name=site_name,\n                        file_id=repre_file[\"_id\"]\n                    )\n                    sites_reset += 1\n\n    if sites_added % 100 == 0:\n        self.log.debug(\"Sites added {}\".format(sites_added))\n\n    self.log.debug(\"Validation of {} for {} ended\".format(\n        project_name, site_name\n    ))\n    self.log.info(\"Sites added {}, sites reset {}\".format(\n        sites_added, reset_missing\n    ))\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html","title":"sitesync","text":"<p>Python 3 only implementation.</p>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.SiteSyncThread","title":"<code>SiteSyncThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Separate thread running synchronization server with asyncio loop. Stopped when tray is closed.</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>class SiteSyncThread(threading.Thread):\n    \"\"\"\n        Separate thread running synchronization server with asyncio loop.\n        Stopped when tray is closed.\n    \"\"\"\n    def __init__(self, addon):\n        self.log = Logger.get_logger(self.__class__.__name__)\n        super(SiteSyncThread, self).__init__()\n        self.addon = addon\n        self.loop = None\n        self.is_running = False\n        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=3)\n        self.timer = None\n\n    def run(self):\n        self.is_running = True\n\n        try:\n            self.log.info(\"Starting SiteSync\")\n            self.loop = asyncio.new_event_loop()  # create new loop for thread\n            asyncio.set_event_loop(self.loop)\n            self.loop.set_default_executor(self.executor)\n\n            asyncio.ensure_future(self.check_shutdown(), loop=self.loop)\n            asyncio.ensure_future(self.sync_loop(), loop=self.loop)\n            self.log.info(\"SiteSync Started\")\n            self.loop.run_forever()\n        except Exception:\n            self.log.warning(\n                \"SiteSync service has failed\", exc_info=True\n            )\n        finally:\n            self.loop.close()  # optional\n\n    async def sync_loop(self):\n        \"\"\"\n            Runs permanently, each time:\n                - gets list of collections in DB\n                - gets list of active remote providers (has configuration,\n                    credentials)\n                - for each project_name it looks for representations that\n                  should be synced\n                - synchronize found collections\n                - update representations - fills error messages for exceptions\n                - waits X seconds and repeat\n        Returns:\n\n        \"\"\"\n        while self.is_running and not self.addon.is_paused():\n            try:\n                start_time = time.time()\n                self.addon.set_sync_project_settings()  # clean cache\n                project_name = None\n                enabled_projects = self.addon.get_enabled_projects()\n                for project_name in enabled_projects:\n                    await self._sync_project(project_name)\n\n                duration = time.time() - start_time\n                self.log.debug(\"One loop took {:.2f}s\".format(duration))\n\n                delay = self.addon.get_loop_delay(project_name)\n                self.log.debug(\n                    \"Waiting for {} seconds to new loop\".format(delay)\n                )\n                self.timer = asyncio.create_task(self.run_timer(delay))\n                await asyncio.gather(self.timer)\n\n            except ConnectionResetError:\n                self.log.warning(\n                    \"ConnectionResetError in sync loop, trying next loop\",\n                    exc_info=True)\n            except asyncio.exceptions.CancelledError:\n                # cancelling timer\n                pass\n            except ResumableError:\n                self.log.warning(\n                    \"ResumableError in sync loop, trying next loop\",\n                    exc_info=True)\n            except Exception:\n                self.stop()\n                self.log.warning(\n                    \"Unhandled except. in sync loop, stopping server\",\n                    exc_info=True)\n\n    def stop(self):\n        \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n        self.is_running = False\n\n    async def check_shutdown(self):\n        \"\"\" Future that is running and checks if server should be running\n            periodically.\n        \"\"\"\n        while self.is_running:\n            if self.addon.long_running_tasks:\n                task = self.addon.long_running_tasks.pop()\n                self.log.info(\"starting long running\")\n                await self.loop.run_in_executor(None, task[\"func\"])\n                self.log.info(\"finished long running\")\n                self.addon.projects_processed.remove(task[\"project_name\"])\n            await asyncio.sleep(0.5)\n\n        tasks = [\n            task\n            for task in asyncio.all_tasks()\n            if task is not asyncio.current_task()\n        ]\n        list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        self.log.debug(\n            f\"Finished awaiting cancelled tasks, results: {results}...\")\n        await self.loop.shutdown_asyncgens()\n        # to really make sure everything else has time to stop\n        self.executor.shutdown(wait=True)\n        await asyncio.sleep(0.07)\n        self.loop.stop()\n\n    async def run_timer(self, delay):\n        \"\"\"Wait for 'delay' seconds to start next loop\"\"\"\n        await asyncio.sleep(delay)\n\n    def reset_timer(self):\n        \"\"\"Called when waiting for next loop should be skipped\"\"\"\n        self.log.debug(\"Resetting timer\")\n        if self.timer:\n            self.timer.cancel()\n            self.timer = None\n\n    def _working_sites(self, project_name, sync_config):\n        if self.addon.is_project_paused(project_name):\n            self.log.debug(\"Both sites same, skipping\")\n            return None, None\n\n        local_site = self.addon.get_active_site(project_name)\n        remote_site = self.addon.get_remote_site(project_name)\n        if local_site == remote_site:\n            self.log.debug(\"{}-{} sites same, skipping\".format(\n                local_site, remote_site))\n            return None, None\n\n        local_site_config = sync_config.get(\"sites\")[local_site]\n        remote_site_config = sync_config.get(\"sites\")[remote_site]\n        if not all([\n            _site_is_working(\n                self.addon, project_name, local_site, local_site_config\n            ),\n            _site_is_working(\n                self.addon, project_name, remote_site, remote_site_config\n            )\n        ]):\n            self.log.debug((\n                \"Some of the sites {} - {} in {} is not working properly\"\n            ).format(local_site, remote_site, project_name))\n\n            return None, None\n\n        return local_site, remote_site\n\n    def _get_remote_provider_info(\n        self, project_name, remote_site, site_preset\n    ):\n        remote_provider = self.addon.get_provider_for_site(site=remote_site)\n        handler = lib.factory.get_provider(\n            remote_provider,\n            project_name,\n            remote_site,\n            presets=site_preset\n        )\n        limit = lib.factory.get_provider_batch_limit(remote_provider)\n\n        return handler, remote_provider, limit\n\n    async def _sync_project(self, project_name):\n        self.log.info(f\"Processing '{project_name}'\")\n        preset = self.addon.sync_project_settings[project_name]\n\n        local_site, remote_site = self._working_sites(\n            project_name, preset\n        )\n        if not local_site or not remote_site:\n            return\n\n        remote_site_preset = preset.get(\"sites\")[remote_site]\n\n        handler, remote_provider, limit = self._get_remote_provider_info(\n            project_name,\n            remote_site,\n            remote_site_preset\n        )\n\n        repre_states = self.addon.get_sync_representations(\n            project_name,\n            local_site,\n            remote_site,\n            limit\n        )\n\n        task_files_to_process = []\n        files_processed_info = []\n        # process only unique file paths in one batch\n        # multiple representation could have same file path\n        # (textures),\n        # upload process can find already uploaded file and\n        # reuse same id\n        processed_file_path = set()\n\n        # first call to get_provider could be expensive, its\n        # building folder tree structure in memory\n        # call only if needed, eg. DO_UPLOAD or DO_DOWNLOAD\n        for repre_state in repre_states:\n            repre_id = repre_state[\"representationId\"]\n            # QUESTION Why is not project passed in?\n            # QUESTION Why there is not option to check all representations\n            #    in one batch?\n            if self.addon.is_representation_paused(repre_id):\n                continue\n            file_states = repre_state.get(\"files\") or []\n            for file_state in file_states:\n                # skip already processed files\n                # WARNING Using empty string for path is dangerous!!!\n                file_path = file_state.get(\"path\", \"\")\n                if file_path in processed_file_path:\n                    continue\n                status = self.addon.check_status(\n                    file_state,\n                    local_site,\n                    remote_site,\n                    preset.get(\"config\")\n                )\n                if (status == SyncStatus.DO_UPLOAD and\n                        len(task_files_to_process) &lt; limit):\n                    tree = handler.get_tree()\n                    task = asyncio.create_task(\n                        upload(\n                            self.addon,\n                            project_name,\n                            file_state,\n                            repre_state,\n                            remote_provider,\n                            remote_site,\n                            tree,\n                            remote_site_preset\n                        )\n                    )\n                    task_files_to_process.append(task)\n                    # store info for exception handlingy\n                    files_processed_info.append((\n                        file_state,\n                        repre_state,\n                        remote_site,\n                        \"remote\",\n                        project_name\n                    ))\n                    processed_file_path.add(file_path)\n\n                if (status == SyncStatus.DO_DOWNLOAD and\n                        len(task_files_to_process) &lt; limit):\n                    tree = handler.get_tree()\n                    task = asyncio.create_task(\n                        download(\n                            self.addon,\n                            project_name,\n                            file_state,\n                            repre_state,\n                            remote_provider,\n                            remote_site,\n                            tree,\n                            remote_site_preset\n                        )\n                    )\n                    task_files_to_process.append(task)\n\n                    files_processed_info.append((\n                        file_state,\n                        repre_state,\n                        local_site,\n                        \"local\",\n                        project_name\n                    ))\n                    processed_file_path.add(file_path)\n\n        self.log.debug(\"Sync tasks count {}\".format(\n            len(task_files_to_process)\n        ))\n        files_created = await asyncio.gather(\n            *task_files_to_process,\n            return_exceptions=True\n        )\n\n        for file_result, info in zip(files_created, files_processed_info):\n            file_state, repre_status, site_name, side, project_name = info\n            error = None\n            if isinstance(file_result, BaseException):\n                error = str(file_result)\n                self.log.warning(error, exc_info=True)\n                file_result = None  # it is exception &gt;&gt; no id &gt;&gt; reset\n\n            self.addon.update_db(\n                project_name=project_name,\n                new_file_id=file_result,\n                file=file_state,\n                repre_status=repre_status,\n                site_name=site_name,\n                side=side,\n                error=error\n            )\n\n            repre_id = repre_status[\"representationId\"]\n            self.addon.handle_alternate_site(\n                project_name,\n                repre_id,\n                site_name,\n                file_state[\"fileHash\"]\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.SiteSyncThread.check_shutdown","title":"<code>check_shutdown()</code>  <code>async</code>","text":"<p>Future that is running and checks if server should be running periodically.</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>async def check_shutdown(self):\n    \"\"\" Future that is running and checks if server should be running\n        periodically.\n    \"\"\"\n    while self.is_running:\n        if self.addon.long_running_tasks:\n            task = self.addon.long_running_tasks.pop()\n            self.log.info(\"starting long running\")\n            await self.loop.run_in_executor(None, task[\"func\"])\n            self.log.info(\"finished long running\")\n            self.addon.projects_processed.remove(task[\"project_name\"])\n        await asyncio.sleep(0.5)\n\n    tasks = [\n        task\n        for task in asyncio.all_tasks()\n        if task is not asyncio.current_task()\n    ]\n    list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    self.log.debug(\n        f\"Finished awaiting cancelled tasks, results: {results}...\")\n    await self.loop.shutdown_asyncgens()\n    # to really make sure everything else has time to stop\n    self.executor.shutdown(wait=True)\n    await asyncio.sleep(0.07)\n    self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.SiteSyncThread.reset_timer","title":"<code>reset_timer()</code>","text":"<p>Called when waiting for next loop should be skipped</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>def reset_timer(self):\n    \"\"\"Called when waiting for next loop should be skipped\"\"\"\n    self.log.debug(\"Resetting timer\")\n    if self.timer:\n        self.timer.cancel()\n        self.timer = None\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.SiteSyncThread.run_timer","title":"<code>run_timer(delay)</code>  <code>async</code>","text":"<p>Wait for 'delay' seconds to start next loop</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>async def run_timer(self, delay):\n    \"\"\"Wait for 'delay' seconds to start next loop\"\"\"\n    await asyncio.sleep(delay)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.SiteSyncThread.stop","title":"<code>stop()</code>","text":"<p>Sets is_running flag to false, 'check_shutdown' shuts server down</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>def stop(self):\n    \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n    self.is_running = False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.SiteSyncThread.sync_loop","title":"<code>sync_loop()</code>  <code>async</code>","text":"<pre><code>Runs permanently, each time:\n    - gets list of collections in DB\n    - gets list of active remote providers (has configuration,\n        credentials)\n    - for each project_name it looks for representations that\n      should be synced\n    - synchronize found collections\n    - update representations - fills error messages for exceptions\n    - waits X seconds and repeat\n</code></pre> <p>Returns:</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>async def sync_loop(self):\n    \"\"\"\n        Runs permanently, each time:\n            - gets list of collections in DB\n            - gets list of active remote providers (has configuration,\n                credentials)\n            - for each project_name it looks for representations that\n              should be synced\n            - synchronize found collections\n            - update representations - fills error messages for exceptions\n            - waits X seconds and repeat\n    Returns:\n\n    \"\"\"\n    while self.is_running and not self.addon.is_paused():\n        try:\n            start_time = time.time()\n            self.addon.set_sync_project_settings()  # clean cache\n            project_name = None\n            enabled_projects = self.addon.get_enabled_projects()\n            for project_name in enabled_projects:\n                await self._sync_project(project_name)\n\n            duration = time.time() - start_time\n            self.log.debug(\"One loop took {:.2f}s\".format(duration))\n\n            delay = self.addon.get_loop_delay(project_name)\n            self.log.debug(\n                \"Waiting for {} seconds to new loop\".format(delay)\n            )\n            self.timer = asyncio.create_task(self.run_timer(delay))\n            await asyncio.gather(self.timer)\n\n        except ConnectionResetError:\n            self.log.warning(\n                \"ConnectionResetError in sync loop, trying next loop\",\n                exc_info=True)\n        except asyncio.exceptions.CancelledError:\n            # cancelling timer\n            pass\n        except ResumableError:\n            self.log.warning(\n                \"ResumableError in sync loop, trying next loop\",\n                exc_info=True)\n        except Exception:\n            self.stop()\n            self.log.warning(\n                \"Unhandled except. in sync loop, stopping server\",\n                exc_info=True)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.download","title":"<code>download(addon, project_name, file, representation, provider_name, remote_site_name, tree=None, preset=None)</code>  <code>async</code>","text":"<p>Downloads file to local folder denoted in representation.Context.</p> <p>Parameters:</p> Name Type Description Default <code>addon</code> <code>SiteSyncAddon</code> <p>SiteSyncAddon object.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>file</code> <code>dict) </code> <p>Info about processed file.</p> required <code>representation</code> <code>dict</code> <p>repr that 'file' belongs to</p> required <code>provider_name</code> <code>str</code> <p>'gdrive' etc</p> required <code>remote_site_name</code> <code>str</code> <p>site on provider, single provider(gdrive) could have multiple sites (different accounts, credentials)</p> required <code>tree</code> <code>Optional[dict]</code> <p>Injected memory structure for performance.</p> <code>None</code> <code>preset</code> <code>Optional[dict]</code> <p>Site config ('credentials_url', 'root'...).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Name of local file</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>async def download(\n    addon,\n    project_name,\n    file,\n    representation,\n    provider_name,\n    remote_site_name,\n    tree=None,\n    preset=None\n):\n    \"\"\"Downloads file to local folder denoted in representation.Context.\n\n    Args:\n        addon (SiteSyncAddon): SiteSyncAddon object.\n        project_name (str): Project name.\n        file (dict) : Info about processed file.\n        representation (dict):  repr that 'file' belongs to\n        provider_name (str):  'gdrive' etc\n        remote_site_name (str): site on provider, single provider(gdrive)\n            could have multiple sites (different accounts, credentials)\n        tree (Optional[dict]): Injected memory structure for performance.\n        preset (Optional[dict]): Site config ('credentials_url', 'root'...).\n\n    Returns:\n        str: Name of local file\n\n    \"\"\"\n    with addon.lock:\n        remote_handler = lib.factory.get_provider(\n            provider_name,\n            project_name,\n            remote_site_name,\n            tree=tree,\n            presets=preset\n        )\n\n        file_path = file.get(\"path\", \"\")\n        local_file_path, remote_file_path = resolve_paths(\n            addon, file_path, project_name, remote_site_name, remote_handler\n        )\n\n        local_folder = os.path.dirname(local_file_path)\n        os.makedirs(local_folder, exist_ok=True)\n\n    local_site = addon.get_active_site(project_name)\n\n    loop = asyncio.get_running_loop()\n    file_id = await loop.run_in_executor(\n        None,\n        remote_handler.download_file,\n        remote_file_path,\n        local_file_path,\n        addon,\n        project_name,\n        file,\n        representation,\n        local_site,\n        True\n    )\n\n    return file_id\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.download_last_published_workfile","title":"<code>download_last_published_workfile(host_name, project_name, task_name, workfile_representation, max_retries, anatomy=None, sitesync_addon=None)</code>","text":"<p>Download the last published workfile</p> <p>Parameters:</p> Name Type Description Default <code>host_name</code> <code>str</code> <p>Host name.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>task_name</code> <code>str</code> <p>Task name.</p> required <code>workfile_representation</code> <code>dict</code> <p>Workfile representation.</p> required <code>max_retries</code> <code>int</code> <p>complete file failure only after so many attempts</p> required <code>anatomy</code> <code>Optional[Anatomy]</code> <p>Project anatomy, used for optimization. Defaults to None.</p> <code>None</code> <code>sitesync_addon</code> <code>Optional[SiteSyncAddon]</code> <p>Addons manager, used for optimization.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: last published workfile path localized</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>def download_last_published_workfile(\n    host_name: str,\n    project_name: str,\n    task_name: str,\n    workfile_representation: dict,\n    max_retries: int,\n    anatomy: Anatomy = None,\n    sitesync_addon=None,\n) -&gt; Union[str, None]:\n    \"\"\"Download the last published workfile\n\n    Args:\n        host_name (str): Host name.\n        project_name (str): Project name.\n        task_name (str): Task name.\n        workfile_representation (dict): Workfile representation.\n        max_retries (int): complete file failure only after so many attempts\n        anatomy (Optional[Anatomy]): Project anatomy, used for optimization.\n            Defaults to None.\n        sitesync_addon (Optional[SiteSyncAddon]): Addons manager,\n            used for optimization.\n\n    Returns:\n        Union[str, None]: last published workfile path localized\n\n    \"\"\"\n    if not workfile_representation:\n        print(\n            \"Not published workfile for task '{}' and host '{}'.\".format(\n                task_name, host_name\n            )\n        )\n        return None\n\n    if sitesync_addon is None:\n        addons_manager = AddonsManager()\n        sitesync_addon = addons_manager.addons_by_name.get(\"sitesync\")\n\n    # Get sync server addon\n    if not sitesync_addon or not sitesync_addon.enabled:\n        print(\"Site sync addon is disabled or unavailable.\")\n        return None\n\n    if not anatomy:\n        anatomy = Anatomy(project_name)\n\n    last_published_workfile_path = get_representation_path_with_anatomy(\n        workfile_representation, anatomy\n    )\n    if not last_published_workfile_path:\n        return None\n\n    # If representation isn't available on remote site, then return.\n    remote_site = sitesync_addon.get_remote_site(project_name)\n    if not sitesync_addon.is_representation_on_site(\n        project_name,\n        workfile_representation[\"id\"],\n        remote_site,\n    ):\n        print(\n            \"Representation not available for task '{}', site '{}'\".format(\n                task_name, remote_site\n            )\n        )\n        return None\n\n    # Get local site\n    local_site_id = get_local_site_id()\n\n    # Add workfile representation to local site\n    representation_ids = {workfile_representation[\"id\"]}\n    representation_ids.update(\n        get_linked_representation_id(\n            project_name, workfile_representation, \"reference\"\n        )\n    )\n    for repre_id in representation_ids:\n        if not sitesync_addon.is_representation_on_site(\n            project_name, repre_id, local_site_id\n        ):\n            sitesync_addon.add_site(\n                project_name,\n                repre_id,\n                local_site_id,\n                force=True,\n                # priority=99  TODO add when implemented\n            )\n    sitesync_addon.reset_timer()\n    print(\"Starting to download:{}\".format(last_published_workfile_path))\n    # While representation unavailable locally, wait.\n    while not sitesync_addon.is_representation_on_site(\n        project_name,\n        workfile_representation[\"id\"],\n        local_site_id,\n        max_retries=max_retries\n    ):\n        time.sleep(5)\n\n    return last_published_workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.resolve_paths","title":"<code>resolve_paths(addon, file_path, project_name, remote_site_name=None, remote_handler=None)</code>","text":"<p>Resolve local and remote full path.</p> <p>Returns tuple of local and remote file paths with {root} placeholders replaced with proper values from Settings or Anatomy</p> <p>Ejected here because of Python 2 hosts (GDriveHandler is an issue)</p> <p>Parameters:</p> Name Type Description Default <code>addon</code> <code>SiteSyncAddon</code> <p>object to run SiteSyncAddon API</p> required <code>file_path</code> <code>str</code> <p>File path with {root}.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>remote_site_name</code> <code>Optional[str]</code> <p>Remote site name.</p> <code>None</code> <code>remote_handler</code> <code>Optional[AbstractProvider]</code> <p>implementation</p> <code>None</code> <p>Returns:</p> Type Description <p>tuple[str, str]: Proper absolute paths, remote path is optional.</p> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>def resolve_paths(\n    addon, file_path, project_name, remote_site_name=None, remote_handler=None\n):\n    \"\"\"Resolve local and remote full path.\n\n    Returns tuple of local and remote file paths with {root}\n    placeholders replaced with proper values from Settings or Anatomy\n\n    Ejected here because of Python 2 hosts (GDriveHandler is an issue)\n\n    Args:\n        addon (SiteSyncAddon): object to run SiteSyncAddon API\n        file_path (str): File path with {root}.\n        project_name (str): Project name.\n        remote_site_name (Optional[str]): Remote site name.\n        remote_handler (Optional[AbstractProvider]): implementation\n\n    Returns:\n        tuple[str, str]: Proper absolute paths, remote path is optional.\n\n    \"\"\"\n    remote_file_path = \"\"\n    if remote_handler:\n        remote_file_path = remote_handler.resolve_path(file_path)\n\n    local_handler = lib.factory.get_provider(\n        \"local_drive\", project_name, addon.get_active_site(project_name)\n    )\n    local_file_path = local_handler.resolve_path(file_path)\n\n    return local_file_path, remote_file_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/sitesync.html#client.ayon_sitesync.sitesync.upload","title":"<code>upload(addon, project_name, file, representation, provider_name, remote_site_name, tree=None, preset=None)</code>  <code>async</code>","text":"<p>Upload representation file.</p> <p>Upload single 'file' of a 'representation' to 'provider'. Source url is taken from 'file' portion, where {root} placeholder is replaced by 'representation.Context.root' Provider could be one of implemented in provider.py.</p> <p>Updates database, fills in id of file from provider (ie. file_id     from GDrive), 'created_dt' - time of upload</p> <p>Value of 'provider_name' doesn't have to match to 'site_name', single provider (GDrive) might have multiple sites ('projectA', 'projectB')</p> <p>Parameters:</p> Name Type Description Default <code>addon</code> <code>SiteSyncAddon</code> <p>object to run SiteSyncAddon API</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>file</code> <code>dict[str, Any]</code> <p>of file from representation in Mongo</p> required <code>representation</code> <code>dictionary</code> <p>of representation</p> required <code>provider_name</code> <code>str</code> <p>gdrive, gdc etc.</p> required <code>remote_site_name</code> <code>string</code> <p>Site on provider, single provider(gdrive) could have multiple sites (different accounts, credentials)</p> required <code>tree</code> <code>Optional[dict]</code> <p>Injected memory structure for performance.</p> <code>None</code> <code>preset</code> <code>Optional[dict]</code> <p>site config ('credentials_url', 'root'...)</p> <code>None</code> Source code in <code>client/ayon_sitesync/sitesync.py</code> <pre><code>async def upload(\n    addon,\n    project_name,\n    file,\n    representation,\n    provider_name,\n    remote_site_name,\n    tree=None,\n    preset=None\n):\n    \"\"\"Upload representation file.\n\n    Upload single 'file' of a 'representation' to 'provider'.\n    Source url is taken from 'file' portion, where {root} placeholder\n    is replaced by 'representation.Context.root'\n    Provider could be one of implemented in provider.py.\n\n    Updates database, fills in id of file from provider (ie. file_id\n        from GDrive), 'created_dt' - time of upload\n\n    Value of 'provider_name' doesn't have to match to 'site_name', single\n    provider (GDrive) might have multiple sites ('projectA', 'projectB')\n\n    Args:\n        addon (SiteSyncAddon): object to run SiteSyncAddon API\n        project_name (str): Project name.\n        file (dict[str, Any]): of file from representation in Mongo\n        representation (dictionary): of representation\n        provider_name (str): gdrive, gdc etc.\n        remote_site_name (string): Site on provider, single provider(gdrive)\n            could have multiple sites (different accounts, credentials)\n        tree (Optional[dict]): Injected memory structure for performance.\n        preset (Optional[dict]): site config ('credentials_url', 'root'...)\n\n    \"\"\"\n    # create ids sequentially, upload file in parallel later\n    with addon.lock:\n        # this part modifies structure on 'remote_site', only single\n        # thread can do that at a time, upload/download to prepared\n        # structure should be run in parallel\n        remote_handler = lib.factory.get_provider(\n            provider_name,\n            project_name,\n            remote_site_name,\n            tree=tree,\n            presets=preset\n        )\n\n        file_path = file.get(\"path\", \"\")\n\n        local_file_path, remote_file_path = resolve_paths(\n            addon, file_path, project_name,\n            remote_site_name, remote_handler\n        )\n\n        target_folder = os.path.dirname(remote_file_path)\n        folder_id = remote_handler.create_folder(target_folder)\n\n        if not folder_id:\n            err = \"Folder {} wasn't created. Check permissions.\". \\\n                format(target_folder)\n            raise NotADirectoryError(err)\n\n    loop = asyncio.get_running_loop()\n    file_id = await loop.run_in_executor(\n        None,\n        remote_handler.upload_file,\n        local_file_path,\n        remote_file_path,\n        addon,\n        project_name,\n        file,\n        representation,\n        remote_site_name,\n        True\n    )\n\n    return file_id\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_sitesync/utils.html#client.ayon_sitesync.utils.ResumableError","title":"<code>ResumableError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error which could be temporary, skip current loop, try next time</p> Source code in <code>client/ayon_sitesync/utils.py</code> <pre><code>class ResumableError(Exception):\n    \"\"\"Error which could be temporary, skip current loop, try next time\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/utils.html#client.ayon_sitesync.utils.SiteAlreadyPresentError","title":"<code>SiteAlreadyPresentError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Representation has already site skeleton present.</p> Source code in <code>client/ayon_sitesync/utils.py</code> <pre><code>class SiteAlreadyPresentError(Exception):\n    \"\"\"Representation has already site skeleton present.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/utils.html#client.ayon_sitesync.utils.get_linked_representation_id","title":"<code>get_linked_representation_id(project_name, repre_entity, link_type, max_depth=None)</code>","text":"<p>Returns list of linked ids of particular type (if provided).</p> <p>One of representation document or representation id must be passed. Note:     Representation links now works only from representation through         version back to representations.</p> Todos <p>Missing depth query. Not sure how it did find more representations     in depth, probably links to version? This function should probably live in sitesync addon?</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of project where look for links.</p> required <code>repre_entity</code> <code>dict[str, Any]</code> <p>Representation entity.</p> required <code>link_type</code> <code>str</code> <p>Type of link (e.g. 'reference', ...).</p> required <code>max_depth</code> <code>int</code> <p>Limit recursion level. Default: 0</p> <code>None</code> <p>Returns:</p> Type Description <p>List[ObjectId] Linked representation ids.</p> Source code in <code>client/ayon_sitesync/utils.py</code> <pre><code>def get_linked_representation_id(\n    project_name,\n    repre_entity,\n    link_type,\n    max_depth=None\n):\n    \"\"\"Returns list of linked ids of particular type (if provided).\n\n    One of representation document or representation id must be passed.\n    Note:\n        Representation links now works only from representation through\n            version back to representations.\n\n    Todos:\n        Missing depth query. Not sure how it did find more representations\n            in depth, probably links to version?\n        This function should probably live in sitesync addon?\n\n    Args:\n        project_name (str): Name of project where look for links.\n        repre_entity (dict[str, Any]): Representation entity.\n        link_type (str): Type of link (e.g. 'reference', ...).\n        max_depth (int): Limit recursion level. Default: 0\n\n    Returns:\n        List[ObjectId] Linked representation ids.\n    \"\"\"\n\n    if not repre_entity:\n        return []\n\n    version_id = repre_entity[\"versionId\"]\n    if max_depth is None or max_depth == 0:\n        max_depth = 1\n\n    link_types = None\n    if link_type:\n        link_types = [link_type]\n\n    # Store already found version ids to avoid recursion, and also to store\n    #   output -&gt; Don't forget to remove 'version_id' at the end!!!\n    linked_version_ids = {version_id}\n    # Each loop of depth will reset this variable\n    versions_to_check = {version_id}\n    for _ in range(max_depth):\n        if not versions_to_check:\n            break\n\n        versions_links = get_versions_links(\n            project_name,\n            versions_to_check,\n            link_types=link_types,\n            link_direction=\"in\")  # looking for 'in'puts for version\n\n        versions_to_check = set()\n        for links in versions_links.values():\n            for link in links:\n                # Care only about version links\n                if link[\"entityType\"] != \"version\":\n                    continue\n                entity_id = link[\"entityId\"]\n                linked_version_ids.add(entity_id)\n                versions_to_check.add(entity_id)\n\n    linked_version_ids.remove(version_id)\n    if not linked_version_ids:\n        return []\n    representations = get_representations(\n        project_name,\n        version_ids=linked_version_ids,\n        fields=[\"id\"])\n    return [\n        repre[\"id\"]\n        for repre in representations\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/utils.html#client.ayon_sitesync.utils.time_function","title":"<code>time_function(method)</code>","text":"<p>Decorator to print how much time function took. For debugging. Depends on presence of 'log' object</p> Source code in <code>client/ayon_sitesync/utils.py</code> <pre><code>def time_function(method):\n    \"\"\" Decorator to print how much time function took.\n        For debugging.\n        Depends on presence of 'log' object\n    \"\"\"\n\n    def timed(*args, **kw):\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if \"log_time\" in kw:\n            name = kw.get(\"log_name\", method.__name__.upper())\n            kw[\"log_time\"][name] = int((te - ts) * 1000)\n        else:\n            log.debug(\"%r  %2.2f ms\" % (method.__name__, (te - ts) * 1000))\n        return result\n\n    return timed\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/version.html","title":"version","text":"<p>Package declaring AYON addon 'sitesync' version.</p>"},{"location":"autoapi/client/ayon_sitesync/launch_hooks/index.html","title":"launch_hooks","text":""},{"location":"autoapi/client/ayon_sitesync/launch_hooks/pre_copy_last_published_workfile.html","title":"pre_copy_last_published_workfile","text":""},{"location":"autoapi/client/ayon_sitesync/launch_hooks/pre_copy_last_published_workfile.html#client.ayon_sitesync.launch_hooks.pre_copy_last_published_workfile.CopyLastPublishedWorkfile","title":"<code>CopyLastPublishedWorkfile</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Copy last published workfile as first workfile.</p> <p>Prelaunch hook works only if last workfile leads to not existing file.     - That is possible only if it's first version.</p> Source code in <code>client/ayon_sitesync/launch_hooks/pre_copy_last_published_workfile.py</code> <pre><code>class CopyLastPublishedWorkfile(PreLaunchHook):\n    \"\"\"Copy last published workfile as first workfile.\n\n    Prelaunch hook works only if last workfile leads to not existing file.\n        - That is possible only if it's first version.\n    \"\"\"\n\n    # Before `AddLastWorkfileToLaunchArgs`\n    order = -1\n    # any DCC could be used but TrayPublisher and other specials\n    app_groups = [\"blender\", \"photoshop\", \"tvpaint\", \"aftereffects\",\n                  \"nuke\", \"nukeassist\", \"nukex\", \"hiero\", \"nukestudio\",\n                  \"maya\", \"harmony\", \"celaction\", \"flame\", \"fusion\",\n                  \"houdini\", \"tvpaint\"]\n\n    def execute(self):\n        \"\"\"Check if local workfile doesn't exist, else copy it.\n\n        1- Check if setting for this feature is enabled\n        2- Check if workfile in work area doesn't exist\n        3- Check if published workfile exists and is copied locally in publish\n        4- Substitute copied published workfile as first workfile\n           with incremented version by +1\n\n        Returns:\n            None: This is a void method.\n        \"\"\"\n        project_name = self.data[\"project_name\"]\n        sitesync_addon = self.addons_manager.get(\"sitesync\")\n        if (\n            not sitesync_addon\n            or not sitesync_addon.enabled\n            or not sitesync_addon.is_project_enabled(project_name, True)\n        ):\n            self.log.debug(\"Sync server module is not enabled or available\")\n            return\n\n        # Check there is no workfile available\n        last_workfile = self.data.get(\"last_workfile_path\")\n        if os.path.exists(last_workfile):\n            self.log.debug(\n                \"Last workfile exists. Skipping {} process.\".format(\n                    self.__class__.__name__\n                )\n            )\n            return\n\n        project_settings = self.data[\"project_settings\"]\n\n        # Get data\n        anatomy = self.data[\"anatomy\"]\n        task_id = self.data[\"task_entity\"][\"id\"]\n        folder_entity = self.data[\"folder_entity\"]\n        folder_id = folder_entity[\"id\"]\n        task_name = self.data[\"task_name\"]\n        task_type = self.data[\"task_type\"]\n        host_name = self.application.host_name\n        project_entity = self.data[\"project_entity\"]\n        task_entity = self.data[\"task_entity\"]\n\n        use_last_published_workfile = should_use_last_workfile_on_launch(\n            project_name, host_name, task_name, task_type,\n            project_settings=project_settings\n        )\n\n        if use_last_published_workfile is None:\n            self.log.info(\n                (\n                    \"Seems like old version of settings is used.\"\n                    ' Can\\'t access custom templates in host \"{}\".'.format(\n                        host_name\n                    )\n                )\n            )\n            return\n        elif use_last_published_workfile is False:\n            self.log.info(\n                (\n                    'Project \"{}\" has turned off to use last published'\n                    ' workfile as first workfile for host \"{}\"'.format(\n                        project_name, host_name\n                    )\n                )\n            )\n            return\n\n        self.log.info(\"Trying to fetch last published workfile...\")\n\n        workfile_representation = (\n            self._get_last_published_workfile_representation(\n                project_name, folder_id, task_id, host_name\n            )\n        )\n\n        if not workfile_representation:\n            self.log.info(\"Couldn't find published workfile representation\")\n            return\n\n        max_retries = int(\n            sitesync_addon.sync_project_settings\n            [project_name]\n            [\"config\"]\n            [\"retry_cnt\"]\n        )\n\n        # Copy file and substitute path\n        last_published_workfile_path = download_last_published_workfile(\n            host_name,\n            project_name,\n            task_name,\n            workfile_representation,\n            max_retries,\n            anatomy=anatomy,\n            sitesync_addon=sitesync_addon,\n        )\n        if not last_published_workfile_path:\n            self.log.debug(\n                \"Couldn't download {}\".format(last_published_workfile_path)\n            )\n            return\n\n        # Get workfile data\n        workfile_data = get_template_data(\n            project_entity, folder_entity, task_entity, host_name,\n            project_settings\n        )\n\n        extension = last_published_workfile_path.split(\".\")[-1]\n        workfile_data[\"version\"] = (\n                workfile_representation[\"context\"][\"version\"] + 1)\n        workfile_data[\"ext\"] = extension\n\n        template_key = get_workfile_template_key(\n            task_name, host_name, project_name, project_settings\n        )\n        template = anatomy.get_template_item(\"work\", template_key, \"path\")\n        local_workfile_path = template.format_strict(workfile_data)\n\n        # Copy last published workfile to local workfile directory\n        shutil.copy(\n            last_published_workfile_path,\n            local_workfile_path,\n        )\n\n        self.data[\"last_workfile_path\"] = local_workfile_path\n        # Keep source filepath for further path conformation\n        self.data[\"source_filepath\"] = last_published_workfile_path\n\n    def _get_last_published_workfile_representation(self,\n            project_name, folder_id, task_id, host_name):\n        \"\"\"Looks for last published representation for host and context\"\"\"\n        product_entities = get_products(\n            project_name,\n            folder_ids={folder_id},\n            product_types={\"workfile\"}\n        )\n        product_ids = {\n            product_entity[\"id\"]\n            for product_entity in product_entities\n        }\n        if not product_ids:\n            return\n        versions_by_product_id = get_last_versions(\n            project_name,\n            product_ids\n        )\n        version_ids = {\n            version_entity[\"id\"]\n            for version_entity in versions_by_product_id.values()\n            if version_entity[\"taskId\"] == task_id\n        }\n        if not version_ids:\n            return\n\n        addons_manager = self.addons_manager\n        host_addon = addons_manager[host_name]\n        workfile_extensions = host_addon.get_workfile_extensions()\n\n        for representation_entity in get_representations(\n            project_name,\n            version_ids=version_ids,\n        ):\n            ext = representation_entity[\"context\"].get(\"ext\")\n            ext = f\".{ext}\"\n            if ext in workfile_extensions:\n                return representation_entity\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/launch_hooks/pre_copy_last_published_workfile.html#client.ayon_sitesync.launch_hooks.pre_copy_last_published_workfile.CopyLastPublishedWorkfile.execute","title":"<code>execute()</code>","text":"<p>Check if local workfile doesn't exist, else copy it.</p> <p>1- Check if setting for this feature is enabled 2- Check if workfile in work area doesn't exist 3- Check if published workfile exists and is copied locally in publish 4- Substitute copied published workfile as first workfile    with incremented version by +1</p> <p>Returns:</p> Name Type Description <code>None</code> <p>This is a void method.</p> Source code in <code>client/ayon_sitesync/launch_hooks/pre_copy_last_published_workfile.py</code> <pre><code>def execute(self):\n    \"\"\"Check if local workfile doesn't exist, else copy it.\n\n    1- Check if setting for this feature is enabled\n    2- Check if workfile in work area doesn't exist\n    3- Check if published workfile exists and is copied locally in publish\n    4- Substitute copied published workfile as first workfile\n       with incremented version by +1\n\n    Returns:\n        None: This is a void method.\n    \"\"\"\n    project_name = self.data[\"project_name\"]\n    sitesync_addon = self.addons_manager.get(\"sitesync\")\n    if (\n        not sitesync_addon\n        or not sitesync_addon.enabled\n        or not sitesync_addon.is_project_enabled(project_name, True)\n    ):\n        self.log.debug(\"Sync server module is not enabled or available\")\n        return\n\n    # Check there is no workfile available\n    last_workfile = self.data.get(\"last_workfile_path\")\n    if os.path.exists(last_workfile):\n        self.log.debug(\n            \"Last workfile exists. Skipping {} process.\".format(\n                self.__class__.__name__\n            )\n        )\n        return\n\n    project_settings = self.data[\"project_settings\"]\n\n    # Get data\n    anatomy = self.data[\"anatomy\"]\n    task_id = self.data[\"task_entity\"][\"id\"]\n    folder_entity = self.data[\"folder_entity\"]\n    folder_id = folder_entity[\"id\"]\n    task_name = self.data[\"task_name\"]\n    task_type = self.data[\"task_type\"]\n    host_name = self.application.host_name\n    project_entity = self.data[\"project_entity\"]\n    task_entity = self.data[\"task_entity\"]\n\n    use_last_published_workfile = should_use_last_workfile_on_launch(\n        project_name, host_name, task_name, task_type,\n        project_settings=project_settings\n    )\n\n    if use_last_published_workfile is None:\n        self.log.info(\n            (\n                \"Seems like old version of settings is used.\"\n                ' Can\\'t access custom templates in host \"{}\".'.format(\n                    host_name\n                )\n            )\n        )\n        return\n    elif use_last_published_workfile is False:\n        self.log.info(\n            (\n                'Project \"{}\" has turned off to use last published'\n                ' workfile as first workfile for host \"{}\"'.format(\n                    project_name, host_name\n                )\n            )\n        )\n        return\n\n    self.log.info(\"Trying to fetch last published workfile...\")\n\n    workfile_representation = (\n        self._get_last_published_workfile_representation(\n            project_name, folder_id, task_id, host_name\n        )\n    )\n\n    if not workfile_representation:\n        self.log.info(\"Couldn't find published workfile representation\")\n        return\n\n    max_retries = int(\n        sitesync_addon.sync_project_settings\n        [project_name]\n        [\"config\"]\n        [\"retry_cnt\"]\n    )\n\n    # Copy file and substitute path\n    last_published_workfile_path = download_last_published_workfile(\n        host_name,\n        project_name,\n        task_name,\n        workfile_representation,\n        max_retries,\n        anatomy=anatomy,\n        sitesync_addon=sitesync_addon,\n    )\n    if not last_published_workfile_path:\n        self.log.debug(\n            \"Couldn't download {}\".format(last_published_workfile_path)\n        )\n        return\n\n    # Get workfile data\n    workfile_data = get_template_data(\n        project_entity, folder_entity, task_entity, host_name,\n        project_settings\n    )\n\n    extension = last_published_workfile_path.split(\".\")[-1]\n    workfile_data[\"version\"] = (\n            workfile_representation[\"context\"][\"version\"] + 1)\n    workfile_data[\"ext\"] = extension\n\n    template_key = get_workfile_template_key(\n        task_name, host_name, project_name, project_settings\n    )\n    template = anatomy.get_template_item(\"work\", template_key, \"path\")\n    local_workfile_path = template.format_strict(workfile_data)\n\n    # Copy last published workfile to local workfile directory\n    shutil.copy(\n        last_published_workfile_path,\n        local_workfile_path,\n    )\n\n    self.data[\"last_workfile_path\"] = local_workfile_path\n    # Keep source filepath for further path conformation\n    self.data[\"source_filepath\"] = last_published_workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_sitesync/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_sitesync/plugins/publish/integrate_site_sync.html","title":"integrate_site_sync","text":"<p>Adds state of published representations for syncing.</p> <p>Each published representation might be marked to be synced to multiple sites. On some might be present (by default 'studio'), on some needs to be synchronized.</p>"},{"location":"autoapi/client/ayon_sitesync/plugins/publish/integrate_site_sync.html#client.ayon_sitesync.plugins.publish.integrate_site_sync.IntegrateSiteSync","title":"<code>IntegrateSiteSync</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Adds state of published representations for syncing.</p> Source code in <code>client/ayon_sitesync/plugins/publish/integrate_site_sync.py</code> <pre><code>class IntegrateSiteSync(pyblish.api.InstancePlugin):\n    \"\"\"Adds state of published representations for syncing.\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.2\n    label = \"Integrate Site Sync state\"\n\n    def process(self, instance):\n        published_representations = instance.data.get(\n            \"published_representations\")\n        if not published_representations:\n            self.log.debug(\"Instance does not have published representations\")\n            return\n\n        context = instance.context\n        project_name = context.data[\"projectEntity\"][\"name\"]\n        addons_manager = context.data[\"ayonAddonsManager\"]\n        sitesync_addon = addons_manager.get_enabled_addon(\"sitesync\")\n        if sitesync_addon is None:\n            return\n\n        sites = sitesync_addon.compute_resource_sync_sites(\n            project_name=project_name\n        )\n        for repre_id, inst in published_representations.items():\n            for site_info in sites:\n                sitesync_addon.add_site(\n                    project_name,\n                    repre_id,\n                    site_info[\"name\"],\n                    status=site_info[\"status\"]\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/index.html","title":"providers","text":""},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html","title":"abstract_provider","text":""},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider","title":"<code>AbstractProvider</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>class AbstractProvider(ABC):\n    CODE = \"\"\n    LABEL = \"\"\n\n    _log = None\n\n    def __init__(self, project_name, site_name, tree=None, presets=None):\n        self.presets = None\n        self.active = False\n        self.site_name = site_name\n\n        self.presets = presets\n\n        super(AbstractProvider, self).__init__()\n\n    @property\n    def log(self):\n        if self._log is None:\n            self._log = Logger.get_logger(self.__class__.__name__)\n        return self._log\n\n    @abstractmethod\n    def is_active(self):\n        \"\"\"\n            Returns True if provider is activated, eg. has working credentials.\n        Returns:\n            (boolean)\n        \"\"\"\n\n    @abstractmethod\n    def upload_file(\n        self,\n        source_path,\n        target_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site,\n        overwrite=False\n    ):\n        \"\"\"\n            Copy file from 'source_path' to 'target_path' on provider.\n            Use 'overwrite' boolean to rewrite existing file on provider\n\n        Args:\n            source_path (string): absolute path on provider\n            target_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site (str): site name\n            overwrite (boolean): replace existing file\n        Returns:\n            (string) file_id of created/modified file ,\n                throws FileExistsError, FileNotFoundError exceptions\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def download_file(\n        self,\n        source_path,\n        local_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site,\n        overwrite=False\n    ):\n        \"\"\"\n            Download file from provider into local system\n\n        Args:\n            source_path (string): absolute path on provider\n            local_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site (str): site name\n            overwrite (boolean): replace existing file\n        Returns:\n            (string) file_id of created/modified file ,\n                throws FileExistsError, FileNotFoundError exceptions\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_file(self, path):\n        \"\"\"\n            Deletes file from 'path'. Expects path to specific file.\n\n        Args:\n            path (string): absolute path to particular file\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def list_folder(self, folder_path):\n        \"\"\"\n            List all files and subfolders of particular path non-recursively.\n        Args:\n            folder_path (string): absolut path on provider\n\n        Returns:\n            (list)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def create_folder(self, folder_path):\n        \"\"\"\n            Create all nonexistent folders and subfolders in 'path'.\n\n        Args:\n            path (string): absolute path\n\n        Returns:\n            (string) folder id of lowest subfolder from 'path'\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_tree(self):\n        \"\"\"\n            Creates folder structure for providers which do not provide\n            tree folder structure (GDrive has no accessible tree structure,\n            only parents and their parents)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_roots_config(self, anatomy=None):\n        \"\"\"\n            Returns root values for path resolving\n\n            Takes value from Anatomy which takes values from Settings\n            overridden by Local Settings\n\n        Returns:\n            (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                     OR\n                     {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n            Format is importing for usage of python's format ** approach\n        \"\"\"\n        pass\n\n    def resolve_path(self, path, root_config=None, anatomy=None):\n        \"\"\"\n            Replaces all root placeholders with proper values\n\n            Args:\n                path(string): root[work]/folder...\n                root_config (dict): {'work': \"c:/...\"...}\n                anatomy (Anatomy): object of Anatomy\n            Returns:\n                (string): proper url\n        \"\"\"\n        if not root_config:\n            root_config = self.get_roots_config(anatomy)\n\n        if root_config:\n            root_config = {\"root\": root_config.get(\"root\") or root_config}\n\n        try:\n            if not root_config:\n                raise KeyError\n\n            path = path.format(**root_config)\n        except KeyError:\n            try:\n                path = anatomy.fill_root(path)\n            except KeyError:\n                msg = \"Error in resolving local root from anatomy\"\n                self.log.error(msg)\n                raise ValueError(msg)\n        except IndexError:\n            msg = \"Path {} contains unfillable placeholder\"\n            self.log.error(msg)\n            raise ValueError(msg)\n\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.create_folder","title":"<code>create_folder(folder_path)</code>  <code>abstractmethod</code>","text":"<pre><code>Create all nonexistent folders and subfolders in 'path'.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path</p> required <p>Returns:</p> Type Description <p>(string) folder id of lowest subfolder from 'path'</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef create_folder(self, folder_path):\n    \"\"\"\n        Create all nonexistent folders and subfolders in 'path'.\n\n    Args:\n        path (string): absolute path\n\n    Returns:\n        (string) folder id of lowest subfolder from 'path'\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.delete_file","title":"<code>delete_file(path)</code>  <code>abstractmethod</code>","text":"<pre><code>Deletes file from 'path'. Expects path to specific file.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path to particular file</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef delete_file(self, path):\n    \"\"\"\n        Deletes file from 'path'. Expects path to specific file.\n\n    Args:\n        path (string): absolute path to particular file\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.download_file","title":"<code>download_file(source_path, local_path, addon, project_name, file, repre_status, site, overwrite=False)</code>  <code>abstractmethod</code>","text":"<pre><code>Download file from provider into local system\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>local_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:     (string) file_id of created/modified file ,         throws FileExistsError, FileNotFoundError exceptions</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef download_file(\n    self,\n    source_path,\n    local_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site,\n    overwrite=False\n):\n    \"\"\"\n        Download file from provider into local system\n\n    Args:\n        source_path (string): absolute path on provider\n        local_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site (str): site name\n        overwrite (boolean): replace existing file\n    Returns:\n        (string) file_id of created/modified file ,\n            throws FileExistsError, FileNotFoundError exceptions\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.get_roots_config","title":"<code>get_roots_config(anatomy=None)</code>  <code>abstractmethod</code>","text":"<pre><code>Returns root values for path resolving\n\nTakes value from Anatomy which takes values from Settings\noverridden by Local Settings\n</code></pre> <p>Returns:</p> Type Description <p>(dict) - {\"root\": {\"root\": \"/My Drive\"}}      OR      {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}</p> <p>Format is importing for usage of python's format ** approach</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef get_roots_config(self, anatomy=None):\n    \"\"\"\n        Returns root values for path resolving\n\n        Takes value from Anatomy which takes values from Settings\n        overridden by Local Settings\n\n    Returns:\n        (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                 OR\n                 {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n        Format is importing for usage of python's format ** approach\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.get_tree","title":"<code>get_tree()</code>  <code>abstractmethod</code>","text":"<p>Creates folder structure for providers which do not provide tree folder structure (GDrive has no accessible tree structure, only parents and their parents)</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef get_tree(self):\n    \"\"\"\n        Creates folder structure for providers which do not provide\n        tree folder structure (GDrive has no accessible tree structure,\n        only parents and their parents)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.is_active","title":"<code>is_active()</code>  <code>abstractmethod</code>","text":"<pre><code>Returns True if provider is activated, eg. has working credentials.\n</code></pre> <p>Returns:     (boolean)</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef is_active(self):\n    \"\"\"\n        Returns True if provider is activated, eg. has working credentials.\n    Returns:\n        (boolean)\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.list_folder","title":"<code>list_folder(folder_path)</code>  <code>abstractmethod</code>","text":"<pre><code>List all files and subfolders of particular path non-recursively.\n</code></pre> <p>Args:     folder_path (string): absolut path on provider</p> <p>Returns:</p> Type Description <p>(list)</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef list_folder(self, folder_path):\n    \"\"\"\n        List all files and subfolders of particular path non-recursively.\n    Args:\n        folder_path (string): absolut path on provider\n\n    Returns:\n        (list)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.resolve_path","title":"<code>resolve_path(path, root_config=None, anatomy=None)</code>","text":"<p>Replaces all root placeholders with proper values</p> <p>Parameters:</p> Name Type Description Default <code>path(string)</code> <p>root[work]/folder...</p> required <code>root_config</code> <code>dict</code> <p>{'work': \"c:/...\"...}</p> <code>None</code> <code>anatomy</code> <code>Anatomy</code> <p>object of Anatomy</p> <code>None</code> <p>Returns:     (string): proper url</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>def resolve_path(self, path, root_config=None, anatomy=None):\n    \"\"\"\n        Replaces all root placeholders with proper values\n\n        Args:\n            path(string): root[work]/folder...\n            root_config (dict): {'work': \"c:/...\"...}\n            anatomy (Anatomy): object of Anatomy\n        Returns:\n            (string): proper url\n    \"\"\"\n    if not root_config:\n        root_config = self.get_roots_config(anatomy)\n\n    if root_config:\n        root_config = {\"root\": root_config.get(\"root\") or root_config}\n\n    try:\n        if not root_config:\n            raise KeyError\n\n        path = path.format(**root_config)\n    except KeyError:\n        try:\n            path = anatomy.fill_root(path)\n        except KeyError:\n            msg = \"Error in resolving local root from anatomy\"\n            self.log.error(msg)\n            raise ValueError(msg)\n    except IndexError:\n        msg = \"Path {} contains unfillable placeholder\"\n        self.log.error(msg)\n        raise ValueError(msg)\n\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/abstract_provider.html#client.ayon_sitesync.providers.abstract_provider.AbstractProvider.upload_file","title":"<code>upload_file(source_path, target_path, addon, project_name, file, repre_status, site, overwrite=False)</code>  <code>abstractmethod</code>","text":"<pre><code>Copy file from 'source_path' to 'target_path' on provider.\nUse 'overwrite' boolean to rewrite existing file on provider\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>target_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:     (string) file_id of created/modified file ,         throws FileExistsError, FileNotFoundError exceptions</p> Source code in <code>client/ayon_sitesync/providers/abstract_provider.py</code> <pre><code>@abstractmethod\ndef upload_file(\n    self,\n    source_path,\n    target_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site,\n    overwrite=False\n):\n    \"\"\"\n        Copy file from 'source_path' to 'target_path' on provider.\n        Use 'overwrite' boolean to rewrite existing file on provider\n\n    Args:\n        source_path (string): absolute path on provider\n        target_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site (str): site name\n        overwrite (boolean): replace existing file\n    Returns:\n        (string) file_id of created/modified file ,\n            throws FileExistsError, FileNotFoundError exceptions\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html","title":"dropbox","text":""},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler","title":"<code>DropboxHandler</code>","text":"<p>               Bases: <code>AbstractProvider</code></p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>class DropboxHandler(AbstractProvider):\n    CODE = \"dropbox\"\n    LABEL = \"Dropbox\"\n\n    def __init__(self, project_name, site_name, tree=None, presets=None):\n        self.active = False\n        self.site_name = site_name\n        self.presets = presets\n        self.dbx = None\n\n        if not self.presets:\n            self.log.info(\n                \"Sync Server: There are no presets for {}.\".format(site_name)\n            )\n            return\n\n        if not self.presets.get(\"enabled\"):\n            self.log.debug(\"Sync Server: Site {} not enabled for {}.\".\n                      format(site_name, project_name))\n            return\n\n        token = self.presets.get(\"token\", \"\")\n        if not token:\n            msg = \"Sync Server: No access token for dropbox provider\"\n            self.log.info(msg)\n            return\n\n        team_folder_name = self.presets.get(\"team_folder_name\", \"\")\n        if not team_folder_name:\n            msg = \"Sync Server: No team folder name for dropbox provider\"\n            self.log.info(msg)\n            return\n\n        acting_as_member = self.presets.get(\"acting_as_member\", \"\")\n        if not acting_as_member:\n            msg = (\n                \"Sync Server: No acting member for dropbox provider\"\n            )\n            self.log.info(msg)\n            return\n\n        try:\n            self.dbx = self._get_service(\n                token, acting_as_member, team_folder_name\n            )\n        except Exception as e:\n            self.log.info(\"Could not establish dropbox object: {}\".format(e))\n            return\n\n        super(AbstractProvider, self).__init__()\n\n    def _get_service(self, token, acting_as_member, team_folder_name):\n        dbx = dropbox.DropboxTeam(token)\n\n        # Getting member id.\n        member_id = None\n        member_names = []\n        for member in dbx.team_members_list().members:\n            member_names.append(member.profile.name.display_name)\n            if member.profile.name.display_name == acting_as_member:\n                member_id = member.profile.team_member_id\n\n        if member_id is None:\n            raise ValueError(\n                \"Could not find member \\\"{}\\\". Available members: {}\".format(\n                    acting_as_member, member_names\n                )\n            )\n\n        # Getting team folder id.\n        team_folder_id = None\n        team_folder_names = []\n        for entry in dbx.team_team_folder_list().team_folders:\n            team_folder_names.append(entry.name)\n            if entry.name == team_folder_name:\n                team_folder_id = entry.team_folder_id\n\n        if team_folder_id is None:\n            raise ValueError(\n                \"Could not find team folder \\\"{}\\\". Available folders: \"\n                \"{}\".format(\n                    team_folder_name, team_folder_names\n                )\n            )\n\n        # Establish dropbox object.\n        path_root = dropbox.common.PathRoot.namespace_id(team_folder_id)\n        return dropbox.DropboxTeam(\n            token\n        ).with_path_root(path_root).as_user(member_id)\n\n    def is_active(self):\n        \"\"\"\n            Returns True if provider is activated, eg. has working credentials.\n        Returns:\n            (boolean)\n        \"\"\"\n        return self.presets.get(\"enabled\") and self.dbx is not None\n\n    def _path_exists(self, path):\n        try:\n            entries = self.dbx.files_list_folder(\n                path=os.path.dirname(path)\n            ).entries\n        except dropbox.exceptions.ApiError:\n            return False\n\n        for entry in entries:\n            if entry.name == os.path.basename(path):\n                return True\n\n        return False\n\n    def upload_file(\n        self,\n        source_path,\n        target_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site_name,\n        overwrite=False\n    ):\n        \"\"\"\n            Copy file from 'source_path' to 'target_path' on provider.\n            Use 'overwrite' boolean to rewrite existing file on provider\n\n        Args:\n            source_path (string): absolute path on provider\n            target_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site_name (str): site name\n            overwrite (boolean): replace existing file\n        Returns:\n            (string) file_id of created file, raises exception\n        \"\"\"\n        # Check source path.\n        if not os.path.exists(source_path):\n            raise FileNotFoundError(\n                \"Source file {} doesn't exist.\".format(source_path)\n            )\n\n        if self._path_exists(target_path) and not overwrite:\n            raise FileExistsError(\n                \"File already exists, use 'overwrite' argument\"\n            )\n\n        mode = dropbox.files.WriteMode(\"add\", None)\n        if overwrite:\n            mode = dropbox.files.WriteMode.overwrite\n\n        with open(source_path, \"rb\") as f:\n            file_size = os.path.getsize(source_path)\n\n            CHUNK_SIZE = 50 * 1024 * 1024\n\n            if file_size &lt;= CHUNK_SIZE:\n                self.dbx.files_upload(f.read(), target_path, mode=mode)\n            else:\n                upload_session_start_result = \\\n                    self.dbx.files_upload_session_start(f.read(CHUNK_SIZE))\n\n                cursor = dropbox.files.UploadSessionCursor(\n                    session_id=upload_session_start_result.session_id,\n                    offset=f.tell())\n\n                commit = dropbox.files.CommitInfo(path=target_path, mode=mode)\n\n                while f.tell() &lt; file_size:\n                    if (file_size - f.tell()) &lt;= CHUNK_SIZE:\n                        self.dbx.files_upload_session_finish(\n                            f.read(CHUNK_SIZE),\n                            cursor,\n                            commit)\n                    else:\n                        self.dbx.files_upload_session_append(\n                            f.read(CHUNK_SIZE),\n                            cursor.session_id,\n                            cursor.offset)\n                        cursor.offset = f.tell()\n\n        addon.update_db(\n            project_name=project_name,\n            new_file_id=None,\n            file=file,\n            repre_status=repre_status,\n            site_name=site_name,\n            side=\"remote\",\n            progress=100\n        )\n\n        return target_path\n\n    def download_file(\n        self,\n        source_path,\n        local_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site_name,\n        overwrite=False\n    ):\n        \"\"\"\n            Download file from provider into local system\n\n        Args:\n            source_path (string): absolute path on provider\n            local_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site_name (str): site name\n            overwrite (boolean): replace existing file\n        Returns:\n            None\n        \"\"\"\n        # Check source path.\n        if not self._path_exists(source_path):\n            raise FileNotFoundError(\n                \"Source file {} doesn't exist.\".format(source_path)\n            )\n\n        if os.path.exists(local_path) and not overwrite:\n            raise FileExistsError(\n                \"File already exists, use 'overwrite' argument\"\n            )\n\n        if os.path.exists(local_path) and overwrite:\n            os.unlink(local_path)\n\n        self.dbx.files_download_to_file(local_path, source_path)\n\n        addon.update_db(\n            project_name=project_name,\n            new_file_id=None,\n            file=file,\n            repre_status=repre_status,\n            site_name=site_name,\n            side=\"local\",\n            progress=100\n        )\n\n        return os.path.basename(source_path)\n\n    def delete_file(self, path):\n        \"\"\"\n            Deletes file from 'path'. Expects path to specific file.\n\n        Args:\n            path (string): absolute path to particular file\n\n        Returns:\n            None\n        \"\"\"\n        if not self._path_exists(path):\n            raise FileExistsError(\"File {} doesn't exist\".format(path))\n\n        self.dbx.files_delete(path)\n\n    def list_folder(self, folder_path):\n        \"\"\"\n            List all files and subfolders of particular path non-recursively.\n        Args:\n            folder_path (string): absolut path on provider\n\n        Returns:\n            (list)\n        \"\"\"\n        if not self._path_exists(folder_path):\n            raise FileExistsError(\n                \"Folder \\\"{}\\\" does not exist\".format(folder_path)\n            )\n\n        entry_names = []\n        for entry in self.dbx.files_list_folder(path=folder_path).entries:\n            entry_names.append(entry.name)\n        return entry_names\n\n    def create_folder(self, folder_path):\n        \"\"\"\n            Create all nonexistent folders and subfolders in 'path'.\n\n        Args:\n            path (string): absolute path\n\n        Returns:\n            (string) folder id of lowest subfolder from 'path'\n        \"\"\"\n        if self._path_exists(folder_path):\n            return folder_path\n\n        self.dbx.files_create_folder_v2(folder_path)\n\n        return folder_path\n\n    def get_tree(self):\n        \"\"\"\n            Creates folder structure for providers which do not provide\n            tree folder structure (GDrive has no accessible tree structure,\n            only parents and their parents)\n        \"\"\"\n        pass\n\n    def get_roots_config(self, anatomy=None):\n        \"\"\"\n            Returns root values for path resolving\n\n            Takes value from Anatomy which takes values from Settings\n            overridden by Local Settings\n\n        Returns:\n            (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                     OR\n                     {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n            Format is importing for usage of python's format ** approach\n        \"\"\"\n        # TODO implement multiple roots\n        return {\"root\": {\"work\": self.presets['root']}}\n\n    def resolve_path(self, path, root_config=None, anatomy=None):\n        \"\"\"\n            Replaces all root placeholders with proper values\n\n            Args:\n                path(string): root[work]/folder...\n                root_config (dict): {'work': \"c:/...\"...}\n                anatomy (Anatomy): object of Anatomy\n            Returns:\n                (string): proper url\n        \"\"\"\n        if not root_config:\n            root_config = self.get_roots_config(anatomy)\n\n        if root_config and not root_config.get(\"root\"):\n            root_config = {\"root\": root_config}\n\n        try:\n            if not root_config:\n                raise KeyError\n\n            path = path.format(**root_config)\n        except KeyError:\n            try:\n                path = anatomy.fill_root(path)\n            except KeyError:\n                msg = \"Error in resolving local root from anatomy\"\n                self.log.error(msg)\n                raise ValueError(msg)\n\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.create_folder","title":"<code>create_folder(folder_path)</code>","text":"<pre><code>Create all nonexistent folders and subfolders in 'path'.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path</p> required <p>Returns:</p> Type Description <p>(string) folder id of lowest subfolder from 'path'</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def create_folder(self, folder_path):\n    \"\"\"\n        Create all nonexistent folders and subfolders in 'path'.\n\n    Args:\n        path (string): absolute path\n\n    Returns:\n        (string) folder id of lowest subfolder from 'path'\n    \"\"\"\n    if self._path_exists(folder_path):\n        return folder_path\n\n    self.dbx.files_create_folder_v2(folder_path)\n\n    return folder_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.delete_file","title":"<code>delete_file(path)</code>","text":"<pre><code>Deletes file from 'path'. Expects path to specific file.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path to particular file</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def delete_file(self, path):\n    \"\"\"\n        Deletes file from 'path'. Expects path to specific file.\n\n    Args:\n        path (string): absolute path to particular file\n\n    Returns:\n        None\n    \"\"\"\n    if not self._path_exists(path):\n        raise FileExistsError(\"File {} doesn't exist\".format(path))\n\n    self.dbx.files_delete(path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.download_file","title":"<code>download_file(source_path, local_path, addon, project_name, file, repre_status, site_name, overwrite=False)</code>","text":"<pre><code>Download file from provider into local system\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>local_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site_name</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:     None</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def download_file(\n    self,\n    source_path,\n    local_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site_name,\n    overwrite=False\n):\n    \"\"\"\n        Download file from provider into local system\n\n    Args:\n        source_path (string): absolute path on provider\n        local_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site_name (str): site name\n        overwrite (boolean): replace existing file\n    Returns:\n        None\n    \"\"\"\n    # Check source path.\n    if not self._path_exists(source_path):\n        raise FileNotFoundError(\n            \"Source file {} doesn't exist.\".format(source_path)\n        )\n\n    if os.path.exists(local_path) and not overwrite:\n        raise FileExistsError(\n            \"File already exists, use 'overwrite' argument\"\n        )\n\n    if os.path.exists(local_path) and overwrite:\n        os.unlink(local_path)\n\n    self.dbx.files_download_to_file(local_path, source_path)\n\n    addon.update_db(\n        project_name=project_name,\n        new_file_id=None,\n        file=file,\n        repre_status=repre_status,\n        site_name=site_name,\n        side=\"local\",\n        progress=100\n    )\n\n    return os.path.basename(source_path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.get_roots_config","title":"<code>get_roots_config(anatomy=None)</code>","text":"<pre><code>Returns root values for path resolving\n\nTakes value from Anatomy which takes values from Settings\noverridden by Local Settings\n</code></pre> <p>Returns:</p> Type Description <p>(dict) - {\"root\": {\"root\": \"/My Drive\"}}      OR      {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}</p> <p>Format is importing for usage of python's format ** approach</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def get_roots_config(self, anatomy=None):\n    \"\"\"\n        Returns root values for path resolving\n\n        Takes value from Anatomy which takes values from Settings\n        overridden by Local Settings\n\n    Returns:\n        (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                 OR\n                 {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n        Format is importing for usage of python's format ** approach\n    \"\"\"\n    # TODO implement multiple roots\n    return {\"root\": {\"work\": self.presets['root']}}\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.get_tree","title":"<code>get_tree()</code>","text":"<p>Creates folder structure for providers which do not provide tree folder structure (GDrive has no accessible tree structure, only parents and their parents)</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def get_tree(self):\n    \"\"\"\n        Creates folder structure for providers which do not provide\n        tree folder structure (GDrive has no accessible tree structure,\n        only parents and their parents)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.is_active","title":"<code>is_active()</code>","text":"<pre><code>Returns True if provider is activated, eg. has working credentials.\n</code></pre> <p>Returns:     (boolean)</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def is_active(self):\n    \"\"\"\n        Returns True if provider is activated, eg. has working credentials.\n    Returns:\n        (boolean)\n    \"\"\"\n    return self.presets.get(\"enabled\") and self.dbx is not None\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.list_folder","title":"<code>list_folder(folder_path)</code>","text":"<pre><code>List all files and subfolders of particular path non-recursively.\n</code></pre> <p>Args:     folder_path (string): absolut path on provider</p> <p>Returns:</p> Type Description <p>(list)</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def list_folder(self, folder_path):\n    \"\"\"\n        List all files and subfolders of particular path non-recursively.\n    Args:\n        folder_path (string): absolut path on provider\n\n    Returns:\n        (list)\n    \"\"\"\n    if not self._path_exists(folder_path):\n        raise FileExistsError(\n            \"Folder \\\"{}\\\" does not exist\".format(folder_path)\n        )\n\n    entry_names = []\n    for entry in self.dbx.files_list_folder(path=folder_path).entries:\n        entry_names.append(entry.name)\n    return entry_names\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.resolve_path","title":"<code>resolve_path(path, root_config=None, anatomy=None)</code>","text":"<p>Replaces all root placeholders with proper values</p> <p>Parameters:</p> Name Type Description Default <code>path(string)</code> <p>root[work]/folder...</p> required <code>root_config</code> <code>dict</code> <p>{'work': \"c:/...\"...}</p> <code>None</code> <code>anatomy</code> <code>Anatomy</code> <p>object of Anatomy</p> <code>None</code> <p>Returns:     (string): proper url</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def resolve_path(self, path, root_config=None, anatomy=None):\n    \"\"\"\n        Replaces all root placeholders with proper values\n\n        Args:\n            path(string): root[work]/folder...\n            root_config (dict): {'work': \"c:/...\"...}\n            anatomy (Anatomy): object of Anatomy\n        Returns:\n            (string): proper url\n    \"\"\"\n    if not root_config:\n        root_config = self.get_roots_config(anatomy)\n\n    if root_config and not root_config.get(\"root\"):\n        root_config = {\"root\": root_config}\n\n    try:\n        if not root_config:\n            raise KeyError\n\n        path = path.format(**root_config)\n    except KeyError:\n        try:\n            path = anatomy.fill_root(path)\n        except KeyError:\n            msg = \"Error in resolving local root from anatomy\"\n            self.log.error(msg)\n            raise ValueError(msg)\n\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/dropbox.html#client.ayon_sitesync.providers.dropbox.DropboxHandler.upload_file","title":"<code>upload_file(source_path, target_path, addon, project_name, file, repre_status, site_name, overwrite=False)</code>","text":"<pre><code>Copy file from 'source_path' to 'target_path' on provider.\nUse 'overwrite' boolean to rewrite existing file on provider\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>target_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site_name</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:     (string) file_id of created file, raises exception</p> Source code in <code>client/ayon_sitesync/providers/dropbox.py</code> <pre><code>def upload_file(\n    self,\n    source_path,\n    target_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site_name,\n    overwrite=False\n):\n    \"\"\"\n        Copy file from 'source_path' to 'target_path' on provider.\n        Use 'overwrite' boolean to rewrite existing file on provider\n\n    Args:\n        source_path (string): absolute path on provider\n        target_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site_name (str): site name\n        overwrite (boolean): replace existing file\n    Returns:\n        (string) file_id of created file, raises exception\n    \"\"\"\n    # Check source path.\n    if not os.path.exists(source_path):\n        raise FileNotFoundError(\n            \"Source file {} doesn't exist.\".format(source_path)\n        )\n\n    if self._path_exists(target_path) and not overwrite:\n        raise FileExistsError(\n            \"File already exists, use 'overwrite' argument\"\n        )\n\n    mode = dropbox.files.WriteMode(\"add\", None)\n    if overwrite:\n        mode = dropbox.files.WriteMode.overwrite\n\n    with open(source_path, \"rb\") as f:\n        file_size = os.path.getsize(source_path)\n\n        CHUNK_SIZE = 50 * 1024 * 1024\n\n        if file_size &lt;= CHUNK_SIZE:\n            self.dbx.files_upload(f.read(), target_path, mode=mode)\n        else:\n            upload_session_start_result = \\\n                self.dbx.files_upload_session_start(f.read(CHUNK_SIZE))\n\n            cursor = dropbox.files.UploadSessionCursor(\n                session_id=upload_session_start_result.session_id,\n                offset=f.tell())\n\n            commit = dropbox.files.CommitInfo(path=target_path, mode=mode)\n\n            while f.tell() &lt; file_size:\n                if (file_size - f.tell()) &lt;= CHUNK_SIZE:\n                    self.dbx.files_upload_session_finish(\n                        f.read(CHUNK_SIZE),\n                        cursor,\n                        commit)\n                else:\n                    self.dbx.files_upload_session_append(\n                        f.read(CHUNK_SIZE),\n                        cursor.session_id,\n                        cursor.offset)\n                    cursor.offset = f.tell()\n\n    addon.update_db(\n        project_name=project_name,\n        new_file_id=None,\n        file=file,\n        repre_status=repre_status,\n        site_name=site_name,\n        side=\"remote\",\n        progress=100\n    )\n\n    return target_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html","title":"gdrive","text":""},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler","title":"<code>GDriveHandler</code>","text":"<p>               Bases: <code>AbstractProvider</code></p> <p>Implementation of Google Drive API. As GD API doesn't have real folder structure, 'tree' in memory structure is build in constructor to map folder paths to folder ids, which are used in API. Building of this tree might be expensive and slow and should be run only when necessary. Currently is set to lazy creation, created only after first call when necessary.</p> <p>Configuration for provider is in     'settings/defaults/project_settings/global.json'</p> <p>Settings could be overwritten per project.</p> Example of config <p>\"gdrive\": {   - site name   \"provider\": \"gdrive\", - type of provider, label must be registered   \"credentials_url\": \"/my_secret_folder/credentials.json\",   \"root\": {  - could be \"root\": \"/My Drive\" for single root       \"root_one\": \"/My Drive\",       \"root_two\": \"/My Drive/different_folder\"   } }</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>class GDriveHandler(AbstractProvider):\n    \"\"\"\n        Implementation of Google Drive API.\n        As GD API doesn't have real folder structure, 'tree' in memory\n        structure is build in constructor to map folder paths to folder ids,\n        which are used in API. Building of this tree might be expensive and\n        slow and should be run only when necessary. Currently is set to\n        lazy creation, created only after first call when necessary.\n\n        Configuration for provider is in\n            'settings/defaults/project_settings/global.json'\n\n        Settings could be overwritten per project.\n\n        Example of config:\n          \"gdrive\": {   - site name\n            \"provider\": \"gdrive\", - type of provider, label must be registered\n            \"credentials_url\": \"/my_secret_folder/credentials.json\",\n            \"root\": {  - could be \"root\": \"/My Drive\" for single root\n                \"root_one\": \"/My Drive\",\n                \"root_two\": \"/My Drive/different_folder\"\n            }\n          }\n    \"\"\"\n    CODE = \"gdrive\"\n    LABEL = \"Google Drive\"\n\n    FOLDER_STR = \"application/vnd.google-apps.folder\"\n    MY_DRIVE_STR = \"My Drive\"  # name of root folder of regular Google drive\n    CHUNK_SIZE = 2097152  # must be divisible by 256! used for upload chunks\n\n    def __init__(self, project_name, site_name, tree=None, presets=None):\n        self.active = False\n        self.project_name = project_name\n        self.site_name = site_name\n        self.service = None\n        self.root = None\n\n        self.presets = presets\n        if not self.presets:\n            self.log.info(\n                \"Sync Server: There are no presets for {}.\".format(site_name)\n            )\n            return\n\n        if not self.presets.get(\"enabled\"):\n            self.log.debug(\n                \"Sync Server: Site {} not enabled for {}.\".format(\n                    site_name, project_name\n                )\n            )\n            return\n\n        current_platform = platform.system().lower()\n        cred_paths = self.presets.get(\"credentials_url\", {}). \\\n            get(current_platform) or []\n        cred_path = None\n        for check_path in cred_paths:\n            if not os.path.exists(check_path):\n                continue\n            cred_path = check_path\n            break\n\n        if not cred_path:\n            msg = \"Sync Server: Please, fill the credentials for gdrive \"\\\n                  \"provider for platform '{}' !\".format(current_platform)\n            self.log.info(msg)\n            return\n\n        try:\n            cred_path = cred_path.format(**os.environ)\n        except KeyError as e:\n            self.log.info((\n                \"Sync Server: The key(s) {} does not exist in the \"\n                \"environment variables\"\n            ).format(\" \".join(e.args)))\n            return\n\n        if not os.path.exists(cred_path):\n            msg = \"Sync Server: No credentials for gdrive provider \" + \\\n                  \"for '{}' on path '{}'!\".format(site_name, cred_path)\n            self.log.info(msg)\n            return\n\n        self.service = None\n        self.service = self._get_gd_service(cred_path)\n\n        self._tree = tree\n        self.active = True\n\n    def is_active(self):\n        \"\"\"\n            Returns True if provider is activated, eg. has working credentials.\n        Returns:\n            (boolean)\n        \"\"\"\n        return self.presets.get(\"enabled\") and self.service is not None\n\n    def get_roots_config(self, anatomy=None):\n        \"\"\"\n            Returns root values for path resolving\n\n            Use only Settings as GDrive cannot be modified by Local Settings\n\n        Returns:\n            (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                     OR\n                     {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n            Format is importing for usage of python's format ** approach\n        \"\"\"\n        # GDrive roots cannot be locally overridden\n        # TODO implement multiple roots\n        return {\"root\": {\"work\": self.presets[\"root\"]}}\n\n    def get_tree(self):\n        \"\"\"\n            Building of the folder tree could be potentially expensive,\n            constructor provides argument that could inject previously created\n            tree.\n            Tree structure must be handled in thread safe fashion!\n        Returns:\n             (dictionary) - url to id mapping\n        \"\"\"\n        if not self._tree:\n            self._tree = self._build_tree(self.list_folders())\n        return self._tree\n\n    def create_folder(self, path):\n        \"\"\"\n            Create all nonexistent folders and subfolders in 'path'.\n            Updates self._tree structure with new paths\n\n        Args:\n            path (string): absolute path, starts with GDrive root,\n                           without filename\n        Returns:\n            (string) folder id of lowest subfolder from 'path'\n        \"\"\"\n        folder_id = self.folder_path_exists(path)\n        if folder_id:\n            return folder_id\n        parts = path.split(\"/\")\n        folders_to_create = []\n\n        while parts:\n            folders_to_create.append(parts.pop())\n            path = \"/\".join(parts)\n            path = path.strip()\n            folder_id = self.folder_path_exists(path)  # lowest common path\n            if folder_id:\n                while folders_to_create:\n                    new_folder_name = folders_to_create.pop()\n                    folder_metadata = {\n                        \"name\": new_folder_name,\n                        \"mimeType\": \"application/vnd.google-apps.folder\",\n                        \"parents\": [folder_id]\n                    }\n                    folder = self.service.files().create(\n                        body=folder_metadata,\n                        supportsAllDrives=True,\n                        fields=\"id\").execute()\n                    folder_id = folder[\"id\"]\n\n                    new_path_key = path + \"/\" + new_folder_name\n                    self.get_tree()[new_path_key] = {\"id\": folder_id}\n\n                    path = new_path_key\n                return folder_id\n\n    def upload_file(\n        self,\n        source_path,\n        target_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site_name,\n        overwrite=False\n    ):\n        \"\"\"\n            Uploads single file from 'source_path' to destination 'path'.\n            It creates all folders on the path if are not existing.\n\n        Args:\n            source_path (string): absolute path on provider\n            target_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site_name (str): site name\n            overwrite (boolean): replace existing file\n\n        Returns:\n            (string) file_id of created/modified file ,\n                throws FileExistsError, FileNotFoundError exceptions\n        \"\"\"\n        if not os.path.isfile(source_path):\n            raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                    .format(source_path))\n\n        root, ext = os.path.splitext(target_path)\n        if ext:\n            # full path\n            target_name = os.path.basename(target_path)\n            target_path = os.path.dirname(target_path)\n        else:\n            target_name = os.path.basename(source_path)\n        target_file = self.file_path_exists(target_path + \"/\" + target_name)\n        if target_file and not overwrite:\n            raise FileExistsError(\"File already exists, \"\n                                  \"use 'overwrite' argument\")\n\n        folder_id = self.folder_path_exists(target_path)\n        if not folder_id:\n            raise NotADirectoryError(\n                \"Folder {} doesn't exists\".format(target_path))\n\n        file_metadata = {\n            \"name\": target_name\n        }\n        media = MediaFileUpload(source_path,\n                                mimetype=\"application/octet-stream\",\n                                chunksize=self.CHUNK_SIZE,\n                                resumable=True)\n\n        try:\n            if not target_file:\n                # update doesnt like parent\n                file_metadata[\"parents\"] = [folder_id]\n\n                request = self.service.files().create(\n                    body=file_metadata,\n                    supportsAllDrives=True,\n                    media_body=media,\n                    fields=\"id\"\n                )\n            else:\n                request = self.service.files().update(\n                    fileId=target_file[\"id\"],\n                    body=file_metadata,\n                    supportsAllDrives=True,\n                    media_body=media,\n                    fields=\"id\"\n                )\n\n            media.stream()\n            self.log.debug(\"Start Upload! {}\".format(source_path))\n            last_tick = status = response = None\n            status_val = 0\n            while response is None:\n                if addon.is_representation_paused(\n                        repre_status[\"representationId\"],\n                        check_parents=True,\n                        project_name=project_name):\n                    raise ValueError(\"Paused during process, please redo.\")\n                if status:\n                    status_val = float(status.progress())\n                if not last_tick or \\\n                        time.time() - last_tick &gt;= addon.LOG_PROGRESS_SEC:\n                    last_tick = time.time()\n                    self.log.debug(\"Uploaded %d%%.\" % int(status_val * 100))\n                    addon.update_db(\n                        project_name=project_name,\n                        new_file_id=None,\n                        file=file,\n                        repre_status=repre_status,\n                        site_name=site_name,\n                        side=\"remote\",\n                        progress=status_val\n                    )\n                status, response = request.next_chunk()\n\n        except errors.HttpError as ex:\n            if ex.resp[\"status\"] == \"404\":\n                return False\n            if ex.resp[\"status\"] == \"403\":\n                # real permission issue\n                if \"has not granted\" in ex._get_reason().strip():\n                    raise PermissionError(ex._get_reason().strip())\n\n                self.log.warning(\n                    \"Forbidden received, hit quota. Injecting 60s delay.\"\n                )\n                time.sleep(60)\n                return False\n            raise\n        return response[\"id\"]\n\n    def download_file(\n        self,\n        source_path,\n        local_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site_name,\n        overwrite=False\n    ):\n        \"\"\"\n            Downloads single file from 'source_path' (remote) to 'local_path'.\n            It creates all folders on the local_path if are not existing.\n            By default existing file on 'local_path' will trigger an exception\n\n        Args:\n            source_path (string): absolute path on provider\n            local_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site_name (str): site name\n            overwrite (boolean): replace existing file\n\n        Returns:\n            (string) file_id of created/modified file ,\n                throws FileExistsError, FileNotFoundError exceptions\n        \"\"\"\n        remote_file = self.file_path_exists(source_path)\n        if not remote_file:\n            raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                    .format(source_path))\n\n        root, ext = os.path.splitext(local_path)\n        if ext:\n            # full path with file name\n            target_name = os.path.basename(local_path)\n            local_path = os.path.dirname(local_path)\n        else:  # just folder, get file name from source\n            target_name = os.path.basename(source_path)\n\n        local_file = os.path.isfile(local_path + \"/\" + target_name)\n\n        if local_file and not overwrite:\n            raise FileExistsError(\"File already exists, \"\n                                  \"use 'overwrite' argument\")\n\n        request = self.service.files().get_media(fileId=remote_file[\"id\"],\n                                                 supportsAllDrives=True)\n\n        with open(local_path + \"/\" + target_name, \"wb\") as fh:\n            downloader = MediaIoBaseDownload(fh, request)\n            last_tick = status = response = None\n            status_val = 0\n            while response is None:\n                if addon.is_representation_paused(\n                    repre_status[\"representationId\"],\n                    check_parents=True,\n                    project_name=project_name\n                ):\n                    raise ValueError(\"Paused during process, please redo.\")\n                if status:\n                    status_val = float(status.progress())\n                if not last_tick or \\\n                        time.time() - last_tick &gt;= addon.LOG_PROGRESS_SEC:\n                    last_tick = time.time()\n                    self.log.debug(\"Downloaded %d%%.\" % int(status_val * 100))\n                    addon.update_db(\n                        project_name=project_name,\n                        new_file_id=None,\n                        file=file,\n                        repre_status=repre_status,\n                        site_name=site_name,\n                        side=\"local\",\n                        progress=status_val\n                    )\n                status, response = downloader.next_chunk()\n\n        return target_name\n\n    def delete_folder(self, path, force=False):\n        \"\"\"\n            Deletes folder on GDrive. Checks if folder contains any files or\n            subfolders. In that case raises error, could be overridden by\n            'force' argument.\n            In that case deletes folder on 'path' and all its children.\n\n        Args:\n            path (string): absolute path on GDrive\n            force (boolean): delete even if children in folder\n\n        Returns:\n            None\n        \"\"\"\n        folder_id = self.folder_path_exists(path)\n        if not folder_id:\n            raise ValueError(\"Not valid folder path {}\".format(path))\n\n        fields = \"nextPageToken, files(id, name, parents)\"\n        q = self._handle_q(\"'{}' in parents \".format(folder_id))\n        response = self.service.files().list(\n            q=q,\n            corpora=\"allDrives\",\n            includeItemsFromAllDrives=True,\n            supportsAllDrives=True,\n            pageSize=\"1\",\n            fields=fields).execute()\n        children = response.get(\"files\", [])\n        if children and not force:\n            raise ValueError(\"Folder {} is not empty, use 'force'\".\n                             format(path))\n\n        self.service.files().delete(fileId=folder_id,\n                                    supportsAllDrives=True).execute()\n\n    def delete_file(self, path):\n        \"\"\"\n            Deletes file from 'path'. Expects path to specific file.\n\n        Args:\n            path: absolute path to particular file\n\n        Returns:\n            None\n        \"\"\"\n        file = self.file_path_exists(path)\n        if not file:\n            raise ValueError(\"File {} doesn't exist\")\n        self.service.files().delete(fileId=file[\"id\"],\n                                    supportsAllDrives=True).execute()\n\n    def list_folder(self, folder_path):\n        \"\"\"\n            List all files and subfolders of particular path non-recursively.\n\n        Args:\n            folder_path (string): absolut path on provider\n        Returns:\n             (list)\n        \"\"\"\n        pass\n\n    @time_function\n    def list_folders(self):\n        \"\"\" Lists all folders in GDrive.\n            Used to build in-memory structure of path to folder ids model.\n\n        Returns:\n            (list) of dictionaries('id', 'name', [parents])\n        \"\"\"\n        folders = []\n        page_token = None\n        fields = \"nextPageToken, files(id, name, parents)\"\n        while True:\n            q = self._handle_q(\"mimeType='application/vnd.google-apps.folder'\")\n            response = self.service.files().list(\n                q=q,\n                pageSize=1000,\n                corpora=\"allDrives\",\n                includeItemsFromAllDrives=True,\n                supportsAllDrives=True,\n                fields=fields,\n                pageToken=page_token).execute()\n            folders.extend(response.get(\"files\", []))\n            page_token = response.get(\"nextPageToken\", None)\n            if page_token is None:\n                break\n\n        return folders\n\n    def list_files(self):\n        \"\"\" Lists all files in GDrive\n            Runs loop through possibly multiple pages. Result could be large,\n            if it would be a problem, change it to generator\n        Returns:\n            (list) of dictionaries('id', 'name', [parents])\n        \"\"\"\n        files = []\n        page_token = None\n        fields = \"nextPageToken, files(id, name, parents)\"\n        while True:\n            q = self._handle_q(\"\")\n            response = self.service.files().list(\n                q=q,\n                corpora=\"allDrives\",\n                includeItemsFromAllDrives=True,\n                supportsAllDrives=True,\n                fields=fields,\n                pageToken=page_token).execute()\n            files.extend(response.get(\"files\", []))\n            page_token = response.get(\"nextPageToken\", None)\n            if page_token is None:\n                break\n\n        return files\n\n    def folder_path_exists(self, file_path):\n        \"\"\"\n            Checks if path from 'file_path' exists. If so, return its\n            folder id.\n        Args:\n            file_path (string): gdrive path with / as a separator\n        Returns:\n            (string) folder id or False\n        \"\"\"\n        if not file_path:\n            return False\n\n        root, ext = os.path.splitext(file_path)\n        if not ext:\n            file_path += \"/\"\n\n        dir_path = os.path.dirname(file_path)\n\n        path = self.get_tree().get(dir_path, None)\n        if path:\n            return path[\"id\"]\n\n        return False\n\n    def file_path_exists(self, file_path):\n        \"\"\"\n            Checks if 'file_path' exists on GDrive\n\n        Args:\n            file_path (string): separated by '/', from root, with file name\n        Returns:\n            (dictionary|boolean) file metadata | False if not found\n        \"\"\"\n        folder_id = self.folder_path_exists(file_path)\n        if folder_id:\n            return self.file_exists(os.path.basename(file_path), folder_id)\n        return False\n\n    def file_exists(self, file_name, folder_id):\n        \"\"\"\n            Checks if 'file_name' exists in 'folder_id'\n\n        Args:\n            file_name (string):\n            folder_id (int): google drive folder id\n\n        Returns:\n            (dictionary|boolean) file metadata, False if not found\n        \"\"\"\n        q = self._handle_q(\"name = '{}' and '{}' in parents\"\n                           .format(file_name, folder_id))\n        response = self.service.files().list(\n            q=q,\n            corpora=\"allDrives\",\n            includeItemsFromAllDrives=True,\n            supportsAllDrives=True,\n            fields=\"nextPageToken, files(id, name, parents, \"\n                   \"mimeType, modifiedTime,size,md5Checksum)\").execute()\n        if len(response.get(\"files\")) &gt; 1:\n            raise ValueError(\"Too many files returned for {} in {}\"\n                             .format(file_name, folder_id))\n\n        file = response.get(\"files\", [])\n        if not file:\n            return False\n        return file[0]\n\n    def _get_gd_service(self, credentials_path):\n        \"\"\"\n            Authorize client with 'credentials.json', uses service account.\n            Service account needs to have target folder shared with.\n            Produces service that communicates with GDrive API.\n\n        Returns:\n            None\n        \"\"\"\n        service = None\n        try:\n            creds = service_account.Credentials.from_service_account_file(\n                credentials_path,\n                scopes=SCOPES)\n            service = build(\"drive\", \"v3\",\n                            credentials=creds, cache_discovery=False)\n        except Exception:\n            self.log.error(\"Connection failed, \" +\n                      \"check '{}' credentials file\".format(credentials_path),\n                      exc_info=True)\n\n        return service\n\n    def _prepare_root_info(self):\n        \"\"\"\n            Prepare info about roots and theirs folder ids from 'presets'.\n            Configuration might be for single or multiroot projects.\n            Regular My Drive and Shared drives are implemented, their root\n            folder ids need to be queried in slightly different way.\n\n        Returns:\n            (dicts) of dicts where root folders are keys\n            throws ResumableError in case of errors.HttpError\n        \"\"\"\n        roots = {}\n        config_roots = self.get_roots_config()[\"root\"]\n        try:\n            for path in config_roots.values():\n                if self.MY_DRIVE_STR in path:\n                    roots[self.MY_DRIVE_STR] = self.service.files()\\\n                                                   .get(fileId=\"root\")\\\n                                                   .execute()\n                else:\n                    shared_drives = []\n                    page_token = None\n\n                    while True:\n                        response = self.service.drives().list(\n                            pageSize=100,\n                            pageToken=page_token).execute()\n                        shared_drives.extend(response.get(\"drives\", []))\n                        page_token = response.get(\"nextPageToken\", None)\n                        if page_token is None:\n                            break\n\n                    folders = path.split(\"/\")\n                    if len(folders) &lt; 2:\n                        raise ValueError(\"Wrong root folder definition {}\".\n                                         format(path))\n\n                    for shared_drive in shared_drives:\n                        if folders[1] in shared_drive[\"name\"]:\n                            roots[shared_drive[\"name\"]] = {\n                                \"name\": shared_drive[\"name\"],\n                                \"id\": shared_drive[\"id\"]}\n            if self.MY_DRIVE_STR not in roots:  # add My Drive always\n                roots[self.MY_DRIVE_STR] = self.service.files() \\\n                    .get(fileId=\"root\").execute()\n        except errors.HttpError:\n            self.log.warning(\"HttpError in sync loop, \"\n                        \"trying next loop\",\n                        exc_info=True)\n            raise ResumableError\n\n        return roots\n\n    @time_function\n    def _build_tree(self, folders):\n        \"\"\"\n            Create in-memory structure resolving paths to folder id as\n            recursive querying might be slower.\n            Initialized in the time of class initialization.\n            Maybe should be persisted\n            Tree is structure of path to id:\n                '/ROOT': {'id': '1234567'}\n                '/ROOT/PROJECT_FOLDER': {'id':'222222'}\n                '/ROOT/PROJECT_FOLDER/Assets': {'id': '3434545'}\n        Args:\n            folders (list): list of dictionaries with folder metadata\n        Returns:\n            (dictionary) path as a key, folder id as a value\n        \"\"\"\n        self.log.debug(\"build_tree len {}\".format(len(folders)))\n        if not self.root:  # build only when necessary, could be expensive\n            self.root = self._prepare_root_info()\n\n        root_ids = []\n        default_root_id = None\n        tree = {}\n        ending_by = {}\n        for root_name, root in self.root.items():  # might be multiple roots\n            if root[\"id\"] not in root_ids:\n                tree[\"/\" + root_name] = {\"id\": root[\"id\"]}\n                ending_by[root[\"id\"]] = \"/\" + root_name\n                root_ids.append(root[\"id\"])\n\n                if self.MY_DRIVE_STR == root_name:\n                    default_root_id = root[\"id\"]\n\n        no_parents_yet = {}\n        while folders:\n            folder = folders.pop(0)\n            parents = folder.get(\"parents\", [])\n            # weird cases, shared folders, etc, parent under root\n            if not parents:\n                parent = default_root_id\n            else:\n                parent = parents[0]\n\n            if folder[\"id\"] in root_ids:  # do not process root\n                continue\n\n            if parent in ending_by:\n                path_key = ending_by[parent] + \"/\" + folder[\"name\"]\n                ending_by[folder[\"id\"]] = path_key\n                tree[path_key] = {\"id\": folder[\"id\"]}\n            else:\n                no_parents_yet.setdefault(parent, []).append((folder[\"id\"],\n                                                              folder[\"name\"]))\n        loop_cnt = 0\n        # break if looped more then X times - safety against infinite loop\n        while no_parents_yet and loop_cnt &lt; 20:\n\n            keys = list(no_parents_yet.keys())\n            for parent in keys:\n                if parent in ending_by.keys():\n                    subfolders = no_parents_yet.pop(parent)\n                    for folder_id, folder_name in subfolders:\n                        path_key = ending_by[parent] + \"/\" + folder_name\n                        ending_by[folder_id] = path_key\n                        tree[path_key] = {\"id\": folder_id}\n            loop_cnt += 1\n\n        if len(no_parents_yet) &gt; 0:\n            self.log.debug(\"Some folders path are not resolved {}\".\n                      format(no_parents_yet))\n            self.log.debug(\"Remove deleted folders from trash.\")\n\n        return tree\n\n    def _get_folder_metadata(self, path):\n        \"\"\"\n            Get info about folder with 'path'\n        Args:\n            path (string):\n\n        Returns:\n         (dictionary) with metadata or raises ValueError\n        \"\"\"\n        try:\n            return self.get_tree()[path]\n        except Exception:\n            raise ValueError(\"Uknown folder id {}\".format(id))\n\n    def _handle_q(self, q, trashed=False):\n        \"\"\" API list call contain trashed and hidden files/folder by default.\n            Usually we dont want those, must be included in query explicitly.\n\n        Args:\n            q (string): query portion\n            trashed (boolean): False|True\n\n        Returns:\n            (string) - modified query\n        \"\"\"\n        parts = [q]\n        if not trashed:\n            parts.append(\" trashed = false \")\n\n        return \" and \".join(parts)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.create_folder","title":"<code>create_folder(path)</code>","text":"<pre><code>Create all nonexistent folders and subfolders in 'path'.\nUpdates self._tree structure with new paths\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path, starts with GDrive root,            without filename</p> required <p>Returns:     (string) folder id of lowest subfolder from 'path'</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def create_folder(self, path):\n    \"\"\"\n        Create all nonexistent folders and subfolders in 'path'.\n        Updates self._tree structure with new paths\n\n    Args:\n        path (string): absolute path, starts with GDrive root,\n                       without filename\n    Returns:\n        (string) folder id of lowest subfolder from 'path'\n    \"\"\"\n    folder_id = self.folder_path_exists(path)\n    if folder_id:\n        return folder_id\n    parts = path.split(\"/\")\n    folders_to_create = []\n\n    while parts:\n        folders_to_create.append(parts.pop())\n        path = \"/\".join(parts)\n        path = path.strip()\n        folder_id = self.folder_path_exists(path)  # lowest common path\n        if folder_id:\n            while folders_to_create:\n                new_folder_name = folders_to_create.pop()\n                folder_metadata = {\n                    \"name\": new_folder_name,\n                    \"mimeType\": \"application/vnd.google-apps.folder\",\n                    \"parents\": [folder_id]\n                }\n                folder = self.service.files().create(\n                    body=folder_metadata,\n                    supportsAllDrives=True,\n                    fields=\"id\").execute()\n                folder_id = folder[\"id\"]\n\n                new_path_key = path + \"/\" + new_folder_name\n                self.get_tree()[new_path_key] = {\"id\": folder_id}\n\n                path = new_path_key\n            return folder_id\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.delete_file","title":"<code>delete_file(path)</code>","text":"<pre><code>Deletes file from 'path'. Expects path to specific file.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>absolute path to particular file</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def delete_file(self, path):\n    \"\"\"\n        Deletes file from 'path'. Expects path to specific file.\n\n    Args:\n        path: absolute path to particular file\n\n    Returns:\n        None\n    \"\"\"\n    file = self.file_path_exists(path)\n    if not file:\n        raise ValueError(\"File {} doesn't exist\")\n    self.service.files().delete(fileId=file[\"id\"],\n                                supportsAllDrives=True).execute()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.delete_folder","title":"<code>delete_folder(path, force=False)</code>","text":"<pre><code>Deletes folder on GDrive. Checks if folder contains any files or\nsubfolders. In that case raises error, could be overridden by\n'force' argument.\nIn that case deletes folder on 'path' and all its children.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path on GDrive</p> required <code>force</code> <code>boolean</code> <p>delete even if children in folder</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def delete_folder(self, path, force=False):\n    \"\"\"\n        Deletes folder on GDrive. Checks if folder contains any files or\n        subfolders. In that case raises error, could be overridden by\n        'force' argument.\n        In that case deletes folder on 'path' and all its children.\n\n    Args:\n        path (string): absolute path on GDrive\n        force (boolean): delete even if children in folder\n\n    Returns:\n        None\n    \"\"\"\n    folder_id = self.folder_path_exists(path)\n    if not folder_id:\n        raise ValueError(\"Not valid folder path {}\".format(path))\n\n    fields = \"nextPageToken, files(id, name, parents)\"\n    q = self._handle_q(\"'{}' in parents \".format(folder_id))\n    response = self.service.files().list(\n        q=q,\n        corpora=\"allDrives\",\n        includeItemsFromAllDrives=True,\n        supportsAllDrives=True,\n        pageSize=\"1\",\n        fields=fields).execute()\n    children = response.get(\"files\", [])\n    if children and not force:\n        raise ValueError(\"Folder {} is not empty, use 'force'\".\n                         format(path))\n\n    self.service.files().delete(fileId=folder_id,\n                                supportsAllDrives=True).execute()\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.download_file","title":"<code>download_file(source_path, local_path, addon, project_name, file, repre_status, site_name, overwrite=False)</code>","text":"<pre><code>Downloads single file from 'source_path' (remote) to 'local_path'.\nIt creates all folders on the local_path if are not existing.\nBy default existing file on 'local_path' will trigger an exception\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>local_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site_name</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:</p> Type Description <p>(string) file_id of created/modified file , throws FileExistsError, FileNotFoundError exceptions</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def download_file(\n    self,\n    source_path,\n    local_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site_name,\n    overwrite=False\n):\n    \"\"\"\n        Downloads single file from 'source_path' (remote) to 'local_path'.\n        It creates all folders on the local_path if are not existing.\n        By default existing file on 'local_path' will trigger an exception\n\n    Args:\n        source_path (string): absolute path on provider\n        local_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site_name (str): site name\n        overwrite (boolean): replace existing file\n\n    Returns:\n        (string) file_id of created/modified file ,\n            throws FileExistsError, FileNotFoundError exceptions\n    \"\"\"\n    remote_file = self.file_path_exists(source_path)\n    if not remote_file:\n        raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                .format(source_path))\n\n    root, ext = os.path.splitext(local_path)\n    if ext:\n        # full path with file name\n        target_name = os.path.basename(local_path)\n        local_path = os.path.dirname(local_path)\n    else:  # just folder, get file name from source\n        target_name = os.path.basename(source_path)\n\n    local_file = os.path.isfile(local_path + \"/\" + target_name)\n\n    if local_file and not overwrite:\n        raise FileExistsError(\"File already exists, \"\n                              \"use 'overwrite' argument\")\n\n    request = self.service.files().get_media(fileId=remote_file[\"id\"],\n                                             supportsAllDrives=True)\n\n    with open(local_path + \"/\" + target_name, \"wb\") as fh:\n        downloader = MediaIoBaseDownload(fh, request)\n        last_tick = status = response = None\n        status_val = 0\n        while response is None:\n            if addon.is_representation_paused(\n                repre_status[\"representationId\"],\n                check_parents=True,\n                project_name=project_name\n            ):\n                raise ValueError(\"Paused during process, please redo.\")\n            if status:\n                status_val = float(status.progress())\n            if not last_tick or \\\n                    time.time() - last_tick &gt;= addon.LOG_PROGRESS_SEC:\n                last_tick = time.time()\n                self.log.debug(\"Downloaded %d%%.\" % int(status_val * 100))\n                addon.update_db(\n                    project_name=project_name,\n                    new_file_id=None,\n                    file=file,\n                    repre_status=repre_status,\n                    site_name=site_name,\n                    side=\"local\",\n                    progress=status_val\n                )\n            status, response = downloader.next_chunk()\n\n    return target_name\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.file_exists","title":"<code>file_exists(file_name, folder_id)</code>","text":"<pre><code>Checks if 'file_name' exists in 'folder_id'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>string</code> required <code>folder_id</code> <code>int</code> <p>google drive folder id</p> required <p>Returns:</p> Type Description <p>(dictionary|boolean) file metadata, False if not found</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def file_exists(self, file_name, folder_id):\n    \"\"\"\n        Checks if 'file_name' exists in 'folder_id'\n\n    Args:\n        file_name (string):\n        folder_id (int): google drive folder id\n\n    Returns:\n        (dictionary|boolean) file metadata, False if not found\n    \"\"\"\n    q = self._handle_q(\"name = '{}' and '{}' in parents\"\n                       .format(file_name, folder_id))\n    response = self.service.files().list(\n        q=q,\n        corpora=\"allDrives\",\n        includeItemsFromAllDrives=True,\n        supportsAllDrives=True,\n        fields=\"nextPageToken, files(id, name, parents, \"\n               \"mimeType, modifiedTime,size,md5Checksum)\").execute()\n    if len(response.get(\"files\")) &gt; 1:\n        raise ValueError(\"Too many files returned for {} in {}\"\n                         .format(file_name, folder_id))\n\n    file = response.get(\"files\", [])\n    if not file:\n        return False\n    return file[0]\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.file_path_exists","title":"<code>file_path_exists(file_path)</code>","text":"<pre><code>Checks if 'file_path' exists on GDrive\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>string</code> <p>separated by '/', from root, with file name</p> required <p>Returns:     (dictionary|boolean) file metadata | False if not found</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def file_path_exists(self, file_path):\n    \"\"\"\n        Checks if 'file_path' exists on GDrive\n\n    Args:\n        file_path (string): separated by '/', from root, with file name\n    Returns:\n        (dictionary|boolean) file metadata | False if not found\n    \"\"\"\n    folder_id = self.folder_path_exists(file_path)\n    if folder_id:\n        return self.file_exists(os.path.basename(file_path), folder_id)\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.folder_path_exists","title":"<code>folder_path_exists(file_path)</code>","text":"<pre><code>Checks if path from 'file_path' exists. If so, return its\nfolder id.\n</code></pre> <p>Args:     file_path (string): gdrive path with / as a separator Returns:     (string) folder id or False</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def folder_path_exists(self, file_path):\n    \"\"\"\n        Checks if path from 'file_path' exists. If so, return its\n        folder id.\n    Args:\n        file_path (string): gdrive path with / as a separator\n    Returns:\n        (string) folder id or False\n    \"\"\"\n    if not file_path:\n        return False\n\n    root, ext = os.path.splitext(file_path)\n    if not ext:\n        file_path += \"/\"\n\n    dir_path = os.path.dirname(file_path)\n\n    path = self.get_tree().get(dir_path, None)\n    if path:\n        return path[\"id\"]\n\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.get_roots_config","title":"<code>get_roots_config(anatomy=None)</code>","text":"<pre><code>Returns root values for path resolving\n\nUse only Settings as GDrive cannot be modified by Local Settings\n</code></pre> <p>Returns:</p> Type Description <p>(dict) - {\"root\": {\"root\": \"/My Drive\"}}      OR      {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}</p> <p>Format is importing for usage of python's format ** approach</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def get_roots_config(self, anatomy=None):\n    \"\"\"\n        Returns root values for path resolving\n\n        Use only Settings as GDrive cannot be modified by Local Settings\n\n    Returns:\n        (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                 OR\n                 {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n        Format is importing for usage of python's format ** approach\n    \"\"\"\n    # GDrive roots cannot be locally overridden\n    # TODO implement multiple roots\n    return {\"root\": {\"work\": self.presets[\"root\"]}}\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.get_tree","title":"<code>get_tree()</code>","text":"<pre><code>Building of the folder tree could be potentially expensive,\nconstructor provides argument that could inject previously created\ntree.\nTree structure must be handled in thread safe fashion!\n</code></pre> <p>Returns:      (dictionary) - url to id mapping</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def get_tree(self):\n    \"\"\"\n        Building of the folder tree could be potentially expensive,\n        constructor provides argument that could inject previously created\n        tree.\n        Tree structure must be handled in thread safe fashion!\n    Returns:\n         (dictionary) - url to id mapping\n    \"\"\"\n    if not self._tree:\n        self._tree = self._build_tree(self.list_folders())\n    return self._tree\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.is_active","title":"<code>is_active()</code>","text":"<pre><code>Returns True if provider is activated, eg. has working credentials.\n</code></pre> <p>Returns:     (boolean)</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def is_active(self):\n    \"\"\"\n        Returns True if provider is activated, eg. has working credentials.\n    Returns:\n        (boolean)\n    \"\"\"\n    return self.presets.get(\"enabled\") and self.service is not None\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.list_files","title":"<code>list_files()</code>","text":"<p>Lists all files in GDrive     Runs loop through possibly multiple pages. Result could be large,     if it would be a problem, change it to generator Returns:     (list) of dictionaries('id', 'name', [parents])</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def list_files(self):\n    \"\"\" Lists all files in GDrive\n        Runs loop through possibly multiple pages. Result could be large,\n        if it would be a problem, change it to generator\n    Returns:\n        (list) of dictionaries('id', 'name', [parents])\n    \"\"\"\n    files = []\n    page_token = None\n    fields = \"nextPageToken, files(id, name, parents)\"\n    while True:\n        q = self._handle_q(\"\")\n        response = self.service.files().list(\n            q=q,\n            corpora=\"allDrives\",\n            includeItemsFromAllDrives=True,\n            supportsAllDrives=True,\n            fields=fields,\n            pageToken=page_token).execute()\n        files.extend(response.get(\"files\", []))\n        page_token = response.get(\"nextPageToken\", None)\n        if page_token is None:\n            break\n\n    return files\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.list_folder","title":"<code>list_folder(folder_path)</code>","text":"<pre><code>List all files and subfolders of particular path non-recursively.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>string</code> <p>absolut path on provider</p> required <p>Returns:      (list)</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def list_folder(self, folder_path):\n    \"\"\"\n        List all files and subfolders of particular path non-recursively.\n\n    Args:\n        folder_path (string): absolut path on provider\n    Returns:\n         (list)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.list_folders","title":"<code>list_folders()</code>","text":"<p>Lists all folders in GDrive.     Used to build in-memory structure of path to folder ids model.</p> <p>Returns:</p> Type Description <p>(list) of dictionaries('id', 'name', [parents])</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>@time_function\ndef list_folders(self):\n    \"\"\" Lists all folders in GDrive.\n        Used to build in-memory structure of path to folder ids model.\n\n    Returns:\n        (list) of dictionaries('id', 'name', [parents])\n    \"\"\"\n    folders = []\n    page_token = None\n    fields = \"nextPageToken, files(id, name, parents)\"\n    while True:\n        q = self._handle_q(\"mimeType='application/vnd.google-apps.folder'\")\n        response = self.service.files().list(\n            q=q,\n            pageSize=1000,\n            corpora=\"allDrives\",\n            includeItemsFromAllDrives=True,\n            supportsAllDrives=True,\n            fields=fields,\n            pageToken=page_token).execute()\n        folders.extend(response.get(\"files\", []))\n        page_token = response.get(\"nextPageToken\", None)\n        if page_token is None:\n            break\n\n    return folders\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/gdrive.html#client.ayon_sitesync.providers.gdrive.GDriveHandler.upload_file","title":"<code>upload_file(source_path, target_path, addon, project_name, file, repre_status, site_name, overwrite=False)</code>","text":"<pre><code>Uploads single file from 'source_path' to destination 'path'.\nIt creates all folders on the path if are not existing.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>target_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site_name</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:</p> Type Description <p>(string) file_id of created/modified file , throws FileExistsError, FileNotFoundError exceptions</p> Source code in <code>client/ayon_sitesync/providers/gdrive.py</code> <pre><code>def upload_file(\n    self,\n    source_path,\n    target_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site_name,\n    overwrite=False\n):\n    \"\"\"\n        Uploads single file from 'source_path' to destination 'path'.\n        It creates all folders on the path if are not existing.\n\n    Args:\n        source_path (string): absolute path on provider\n        target_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site_name (str): site name\n        overwrite (boolean): replace existing file\n\n    Returns:\n        (string) file_id of created/modified file ,\n            throws FileExistsError, FileNotFoundError exceptions\n    \"\"\"\n    if not os.path.isfile(source_path):\n        raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                .format(source_path))\n\n    root, ext = os.path.splitext(target_path)\n    if ext:\n        # full path\n        target_name = os.path.basename(target_path)\n        target_path = os.path.dirname(target_path)\n    else:\n        target_name = os.path.basename(source_path)\n    target_file = self.file_path_exists(target_path + \"/\" + target_name)\n    if target_file and not overwrite:\n        raise FileExistsError(\"File already exists, \"\n                              \"use 'overwrite' argument\")\n\n    folder_id = self.folder_path_exists(target_path)\n    if not folder_id:\n        raise NotADirectoryError(\n            \"Folder {} doesn't exists\".format(target_path))\n\n    file_metadata = {\n        \"name\": target_name\n    }\n    media = MediaFileUpload(source_path,\n                            mimetype=\"application/octet-stream\",\n                            chunksize=self.CHUNK_SIZE,\n                            resumable=True)\n\n    try:\n        if not target_file:\n            # update doesnt like parent\n            file_metadata[\"parents\"] = [folder_id]\n\n            request = self.service.files().create(\n                body=file_metadata,\n                supportsAllDrives=True,\n                media_body=media,\n                fields=\"id\"\n            )\n        else:\n            request = self.service.files().update(\n                fileId=target_file[\"id\"],\n                body=file_metadata,\n                supportsAllDrives=True,\n                media_body=media,\n                fields=\"id\"\n            )\n\n        media.stream()\n        self.log.debug(\"Start Upload! {}\".format(source_path))\n        last_tick = status = response = None\n        status_val = 0\n        while response is None:\n            if addon.is_representation_paused(\n                    repre_status[\"representationId\"],\n                    check_parents=True,\n                    project_name=project_name):\n                raise ValueError(\"Paused during process, please redo.\")\n            if status:\n                status_val = float(status.progress())\n            if not last_tick or \\\n                    time.time() - last_tick &gt;= addon.LOG_PROGRESS_SEC:\n                last_tick = time.time()\n                self.log.debug(\"Uploaded %d%%.\" % int(status_val * 100))\n                addon.update_db(\n                    project_name=project_name,\n                    new_file_id=None,\n                    file=file,\n                    repre_status=repre_status,\n                    site_name=site_name,\n                    side=\"remote\",\n                    progress=status_val\n                )\n            status, response = request.next_chunk()\n\n    except errors.HttpError as ex:\n        if ex.resp[\"status\"] == \"404\":\n            return False\n        if ex.resp[\"status\"] == \"403\":\n            # real permission issue\n            if \"has not granted\" in ex._get_reason().strip():\n                raise PermissionError(ex._get_reason().strip())\n\n            self.log.warning(\n                \"Forbidden received, hit quota. Injecting 60s delay.\"\n            )\n            time.sleep(60)\n            return False\n        raise\n    return response[\"id\"]\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_sitesync/providers/lib.html#client.ayon_sitesync.providers.lib.ProviderFactory","title":"<code>ProviderFactory</code>","text":"<p>Factory class as a creator of multiple cloud destination. Each new implementation needs to be registered and added to Providers enum.</p> Source code in <code>client/ayon_sitesync/providers/lib.py</code> <pre><code>class ProviderFactory:\n    \"\"\"\n        Factory class as a creator of multiple cloud destination.\n        Each new implementation needs to be registered and added to Providers\n        enum.\n    \"\"\"\n    def __init__(self):\n        self.providers = {}  # {'PROVIDER_LABEL: {cls, int},..}\n\n    def register_provider(self, provider, creator, batch_limit):\n        \"\"\"\n            Provide all necessary information for one specific remote provider\n        Args:\n            provider (string): name of provider\n            creator (class): class implementing AbstractProvider\n            batch_limit (int): number of files that could be processed in\n                                    one loop (based on provider API quota)\n        Returns:\n            modifies self.providers and self.sites\n        \"\"\"\n        self.providers[provider] = (creator, batch_limit)\n\n    def get_provider(self, provider, project_name, site_name,\n                     tree=None, presets=None):\n        \"\"\"\n            Returns new instance of provider client for specific site.\n            One provider could have multiple sites.\n\n            'tree' is used for injecting already created memory structure,\n            without it constructor of provider would need to calculate it\n            from scratch, which could be expensive.\n        Args:\n            provider (string):  'gdrive','S3'\n            site_name (string): descriptor of site, different service accounts\n                must have different site name\n            project_name (string): different projects could have diff. sites\n            tree (dictionary):  - folder paths to folder id structure\n            presets (dictionary): config for provider and site (eg.\n                \"credentials_url\"..)\n        Returns:\n            (implementation of AbstractProvider)\n        \"\"\"\n        creator_info = self._get_creator_info(provider)\n        # call init\n        site = creator_info[0](project_name, site_name, tree, presets)\n\n        return site\n\n    def get_provider_batch_limit(self, provider):\n        \"\"\"\n            Each provider has some limit of files that could be  processed in\n            one batch (loop step). It is not 'file' limit per se, but\n            calculation based on API queries for provider.\n            (For example 'gdrive' has 1000 queries for 100 sec, one file could\n            be multiple queries (one for each level of path + check if file\n            exists)\n        Args:\n            provider (string): 'gdrive','S3'\n        Returns:\n        \"\"\"\n        info = self._get_creator_info(provider)\n        return info[1]\n\n    def get_provider_cls(self, provider_code):\n        \"\"\"\n            Returns class object for 'provider_code' to run class methods on.\n        \"\"\"\n        provider_info = self._get_creator_info(provider_code)\n\n        return provider_info[0]\n\n    def _get_creator_info(self, provider):\n        \"\"\"\n            Collect all necessary info for provider. Currently only creator\n            class and batch limit.\n        Args:\n            provider (string): 'gdrive' etc\n        Returns:\n            (tuple): (creator, batch_limit)\n                creator is class of a provider (ex: GDriveHandler)\n                batch_limit denotes how many files synced at single loop\n                   its provided via 'register_provider' as its needed even\n                   before provider class is initialized itself\n                   (setting it as a class variable didn't work)\n        \"\"\"\n        creator_info = self.providers.get(provider)\n        if not creator_info:\n            raise ValueError(\n                \"Provider {} not registered yet\".format(provider))\n        return creator_info\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/lib.html#client.ayon_sitesync.providers.lib.ProviderFactory.get_provider","title":"<code>get_provider(provider, project_name, site_name, tree=None, presets=None)</code>","text":"<pre><code>Returns new instance of provider client for specific site.\nOne provider could have multiple sites.\n\n'tree' is used for injecting already created memory structure,\nwithout it constructor of provider would need to calculate it\nfrom scratch, which could be expensive.\n</code></pre> <p>Args:     provider (string):  'gdrive','S3'     site_name (string): descriptor of site, different service accounts         must have different site name     project_name (string): different projects could have diff. sites     tree (dictionary):  - folder paths to folder id structure     presets (dictionary): config for provider and site (eg.         \"credentials_url\"..) Returns:     (implementation of AbstractProvider)</p> Source code in <code>client/ayon_sitesync/providers/lib.py</code> <pre><code>def get_provider(self, provider, project_name, site_name,\n                 tree=None, presets=None):\n    \"\"\"\n        Returns new instance of provider client for specific site.\n        One provider could have multiple sites.\n\n        'tree' is used for injecting already created memory structure,\n        without it constructor of provider would need to calculate it\n        from scratch, which could be expensive.\n    Args:\n        provider (string):  'gdrive','S3'\n        site_name (string): descriptor of site, different service accounts\n            must have different site name\n        project_name (string): different projects could have diff. sites\n        tree (dictionary):  - folder paths to folder id structure\n        presets (dictionary): config for provider and site (eg.\n            \"credentials_url\"..)\n    Returns:\n        (implementation of AbstractProvider)\n    \"\"\"\n    creator_info = self._get_creator_info(provider)\n    # call init\n    site = creator_info[0](project_name, site_name, tree, presets)\n\n    return site\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/lib.html#client.ayon_sitesync.providers.lib.ProviderFactory.get_provider_batch_limit","title":"<code>get_provider_batch_limit(provider)</code>","text":"<pre><code>Each provider has some limit of files that could be  processed in\none batch (loop step). It is not 'file' limit per se, but\ncalculation based on API queries for provider.\n(For example 'gdrive' has 1000 queries for 100 sec, one file could\nbe multiple queries (one for each level of path + check if file\nexists)\n</code></pre> <p>Args:     provider (string): 'gdrive','S3' Returns:</p> Source code in <code>client/ayon_sitesync/providers/lib.py</code> <pre><code>def get_provider_batch_limit(self, provider):\n    \"\"\"\n        Each provider has some limit of files that could be  processed in\n        one batch (loop step). It is not 'file' limit per se, but\n        calculation based on API queries for provider.\n        (For example 'gdrive' has 1000 queries for 100 sec, one file could\n        be multiple queries (one for each level of path + check if file\n        exists)\n    Args:\n        provider (string): 'gdrive','S3'\n    Returns:\n    \"\"\"\n    info = self._get_creator_info(provider)\n    return info[1]\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/lib.html#client.ayon_sitesync.providers.lib.ProviderFactory.get_provider_cls","title":"<code>get_provider_cls(provider_code)</code>","text":"<p>Returns class object for 'provider_code' to run class methods on.</p> Source code in <code>client/ayon_sitesync/providers/lib.py</code> <pre><code>def get_provider_cls(self, provider_code):\n    \"\"\"\n        Returns class object for 'provider_code' to run class methods on.\n    \"\"\"\n    provider_info = self._get_creator_info(provider_code)\n\n    return provider_info[0]\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/lib.html#client.ayon_sitesync.providers.lib.ProviderFactory.register_provider","title":"<code>register_provider(provider, creator, batch_limit)</code>","text":"<pre><code>Provide all necessary information for one specific remote provider\n</code></pre> <p>Args:     provider (string): name of provider     creator (class): class implementing AbstractProvider     batch_limit (int): number of files that could be processed in                             one loop (based on provider API quota) Returns:     modifies self.providers and self.sites</p> Source code in <code>client/ayon_sitesync/providers/lib.py</code> <pre><code>def register_provider(self, provider, creator, batch_limit):\n    \"\"\"\n        Provide all necessary information for one specific remote provider\n    Args:\n        provider (string): name of provider\n        creator (class): class implementing AbstractProvider\n        batch_limit (int): number of files that could be processed in\n                                one loop (based on provider API quota)\n    Returns:\n        modifies self.providers and self.sites\n    \"\"\"\n    self.providers[provider] = (creator, batch_limit)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html","title":"local_drive","text":""},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler","title":"<code>LocalDriveHandler</code>","text":"<p>               Bases: <code>AbstractProvider</code></p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>class LocalDriveHandler(AbstractProvider):\n    CODE = \"local_drive\"\n    LABEL = \"Local drive\"\n\n    \"\"\" Handles required operations on mounted disks with OS \"\"\"\n    def __init__(self, project_name, site_name, tree=None, presets=None):\n        self.presets = None\n        self.active = False\n        self.project_name = project_name\n        self.site_name = site_name\n        self._editable_properties = {}\n\n        self.active = self.is_active()\n\n    def is_active(self):\n        return True\n\n    def upload_file(\n        self,\n        source_path,\n        target_path,\n        server,\n        project_name,\n        file,\n        representation,\n        site,\n        overwrite=False,\n        direction=\"Upload\"\n    ):\n        \"\"\"\n            Copies file from 'source_path' to 'target_path'\n        \"\"\"\n        if not os.path.isfile(source_path):\n            raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                    .format(source_path))\n\n        if overwrite:\n            thread = threading.Thread(target=self._copy,\n                                      args=(source_path, target_path))\n            thread.start()\n            self._mark_progress(\n                project_name,\n                file,\n                representation,\n                server,\n                site,\n                source_path,\n                target_path,\n                direction\n            )\n        else:\n            if os.path.exists(target_path):\n                raise ValueError(\"File {} exists, set overwrite\".\n                                 format(target_path))\n\n        return os.path.basename(target_path)\n\n    def download_file(self, source_path, local_path,\n                      server, project_name, file, representation, site,\n                      overwrite=False):\n        \"\"\"\n            Download a file form 'source_path' to 'local_path'\n        \"\"\"\n        return self.upload_file(\n            source_path,\n            local_path,\n            server,\n            project_name,\n            file,\n            representation,\n            site,\n            overwrite,\n            direction=\"Download\"\n        )\n\n    def delete_file(self, path):\n        \"\"\"\n            Deletes a file at 'path'\n        \"\"\"\n        if os.path.exists(path):\n            os.remove(path)\n\n    def list_folder(self, folder_path):\n        \"\"\"\n            Returns list of files and subfolder in a 'folder_path'. Non recurs\n        \"\"\"\n        lst = []\n        if os.path.isdir(folder_path):\n            for (dir_path, dir_names, file_names) in os.walk(folder_path):\n                for name in file_names:\n                    lst.append(os.path.join(dir_path, name))\n                for name in dir_names:\n                    lst.append(os.path.join(dir_path, name))\n\n        return lst\n\n    def create_folder(self, folder_path):\n        \"\"\"\n            Creates 'folder_path' on local system\n\n            Args:\n                folder_path (string): absolute path on local (and mounted) disk\n\n            Returns:\n                (string) - sends back folder_path to denote folder(s) was\n                    created\n        \"\"\"\n        os.makedirs(folder_path, exist_ok=True)\n        return folder_path\n\n    def get_roots_config(self, anatomy=None):\n        \"\"\"\n            Returns root values for path resolving\n\n            Takes value from Anatomy which takes values from Settings\n            overridden by Local Settings\n\n        Returns:\n            (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                     OR\n                     {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n            Format is importing for usage of python's format ** approach\n        \"\"\"\n        site_name = self._normalize_site_name(self.site_name)\n        if not anatomy:\n            anatomy = Anatomy(self.project_name,\n                              site_name)\n\n        # TODO cleanup when Anatomy will implement siteRoots method\n        roots = anatomy.roots\n        root_values = [root.value for root in roots.values()]\n        if not all(root_values):\n            manager = AddonsManager()\n            sitesync_addon = manager.get_enabled_addon(\"sitesync\")\n            if not sitesync_addon:\n                raise RuntimeError(\"No SiteSync addon\")\n            roots = sitesync_addon._get_project_roots_for_site(\n                self.project_name, site_name)\n\n        return {'root': roots}\n\n    def get_tree(self):\n        return\n\n    def _copy(self, source_path, target_path):\n        print(\"copying {}-&gt;{}\".format(source_path, target_path))\n        try:\n            shutil.copy(source_path, target_path)\n        except shutil.SameFileError:\n            print(\"same files, skipping\")\n\n    def _mark_progress(\n        self,\n        project_name,\n        file,\n        repre_status,\n        server,\n        site_name,\n        source_path,\n        target_path,\n        direction\n    ):\n        \"\"\"\n            Updates progress field in DB by values 0-1.\n\n            Compares file sizes of source and target.\n        \"\"\"\n        source_file_size = os.path.getsize(source_path)\n        target_file_size = 0\n        last_tick = status_val = None\n        side = \"local\"\n        if direction == \"Upload\":\n            side = \"remote\"\n        while source_file_size != target_file_size:\n            if not last_tick or \\\n                    time.time() - last_tick &gt;= server.LOG_PROGRESS_SEC:\n                status_val = target_file_size / source_file_size\n                last_tick = time.time()\n                log.debug(direction + \"ed %d%%.\" % int(status_val * 100))\n                server.update_db(\n                    project_name=project_name,\n                    new_file_id=None,\n                    file=file,\n                    repre_status=repre_status,\n                    site_name=site_name,\n                    side=side,\n                    progress=status_val\n                )\n            try:\n                target_file_size = os.path.getsize(target_path)\n            except FileNotFoundError:\n                pass\n            time.sleep(0.5)\n\n    def _normalize_site_name(self, site_name):\n        \"\"\"Transform user id to 'local' for Local settings\"\"\"\n        if site_name != 'studio':\n            return 'local'\n        return site_name\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.LABEL","title":"<code>LABEL = 'Local drive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Handles required operations on mounted disks with OS</p>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.create_folder","title":"<code>create_folder(folder_path)</code>","text":"<p>Creates 'folder_path' on local system</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>string</code> <p>absolute path on local (and mounted) disk</p> required <p>Returns:</p> Type Description <p>(string) - sends back folder_path to denote folder(s) was created</p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>def create_folder(self, folder_path):\n    \"\"\"\n        Creates 'folder_path' on local system\n\n        Args:\n            folder_path (string): absolute path on local (and mounted) disk\n\n        Returns:\n            (string) - sends back folder_path to denote folder(s) was\n                created\n    \"\"\"\n    os.makedirs(folder_path, exist_ok=True)\n    return folder_path\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.delete_file","title":"<code>delete_file(path)</code>","text":"<p>Deletes a file at 'path'</p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>def delete_file(self, path):\n    \"\"\"\n        Deletes a file at 'path'\n    \"\"\"\n    if os.path.exists(path):\n        os.remove(path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.download_file","title":"<code>download_file(source_path, local_path, server, project_name, file, representation, site, overwrite=False)</code>","text":"<p>Download a file form 'source_path' to 'local_path'</p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>def download_file(self, source_path, local_path,\n                  server, project_name, file, representation, site,\n                  overwrite=False):\n    \"\"\"\n        Download a file form 'source_path' to 'local_path'\n    \"\"\"\n    return self.upload_file(\n        source_path,\n        local_path,\n        server,\n        project_name,\n        file,\n        representation,\n        site,\n        overwrite,\n        direction=\"Download\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.get_roots_config","title":"<code>get_roots_config(anatomy=None)</code>","text":"<pre><code>Returns root values for path resolving\n\nTakes value from Anatomy which takes values from Settings\noverridden by Local Settings\n</code></pre> <p>Returns:</p> Type Description <p>(dict) - {\"root\": {\"root\": \"/My Drive\"}}      OR      {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}</p> <p>Format is importing for usage of python's format ** approach</p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>def get_roots_config(self, anatomy=None):\n    \"\"\"\n        Returns root values for path resolving\n\n        Takes value from Anatomy which takes values from Settings\n        overridden by Local Settings\n\n    Returns:\n        (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                 OR\n                 {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n        Format is importing for usage of python's format ** approach\n    \"\"\"\n    site_name = self._normalize_site_name(self.site_name)\n    if not anatomy:\n        anatomy = Anatomy(self.project_name,\n                          site_name)\n\n    # TODO cleanup when Anatomy will implement siteRoots method\n    roots = anatomy.roots\n    root_values = [root.value for root in roots.values()]\n    if not all(root_values):\n        manager = AddonsManager()\n        sitesync_addon = manager.get_enabled_addon(\"sitesync\")\n        if not sitesync_addon:\n            raise RuntimeError(\"No SiteSync addon\")\n        roots = sitesync_addon._get_project_roots_for_site(\n            self.project_name, site_name)\n\n    return {'root': roots}\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.list_folder","title":"<code>list_folder(folder_path)</code>","text":"<p>Returns list of files and subfolder in a 'folder_path'. Non recurs</p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>def list_folder(self, folder_path):\n    \"\"\"\n        Returns list of files and subfolder in a 'folder_path'. Non recurs\n    \"\"\"\n    lst = []\n    if os.path.isdir(folder_path):\n        for (dir_path, dir_names, file_names) in os.walk(folder_path):\n            for name in file_names:\n                lst.append(os.path.join(dir_path, name))\n            for name in dir_names:\n                lst.append(os.path.join(dir_path, name))\n\n    return lst\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/local_drive.html#client.ayon_sitesync.providers.local_drive.LocalDriveHandler.upload_file","title":"<code>upload_file(source_path, target_path, server, project_name, file, representation, site, overwrite=False, direction='Upload')</code>","text":"<p>Copies file from 'source_path' to 'target_path'</p> Source code in <code>client/ayon_sitesync/providers/local_drive.py</code> <pre><code>def upload_file(\n    self,\n    source_path,\n    target_path,\n    server,\n    project_name,\n    file,\n    representation,\n    site,\n    overwrite=False,\n    direction=\"Upload\"\n):\n    \"\"\"\n        Copies file from 'source_path' to 'target_path'\n    \"\"\"\n    if not os.path.isfile(source_path):\n        raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                .format(source_path))\n\n    if overwrite:\n        thread = threading.Thread(target=self._copy,\n                                  args=(source_path, target_path))\n        thread.start()\n        self._mark_progress(\n            project_name,\n            file,\n            representation,\n            server,\n            site,\n            source_path,\n            target_path,\n            direction\n        )\n    else:\n        if os.path.exists(target_path):\n            raise ValueError(\"File {} exists, set overwrite\".\n                             format(target_path))\n\n    return os.path.basename(target_path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html","title":"sftp","text":""},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler","title":"<code>SFTPHandler</code>","text":"<p>               Bases: <code>AbstractProvider</code></p> <p>Implementation of SFTP API.</p> Authentication could be done in 2 ways <ul> <li>user and password</li> <li>ssh key file for user (optionally password for ssh key)</li> </ul> <p>Settings could be overwritten per project.</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>class SFTPHandler(AbstractProvider):\n    \"\"\"\n        Implementation of SFTP API.\n\n        Authentication could be done in 2 ways:\n            - user and password\n            - ssh key file for user (optionally password for ssh key)\n\n        Settings could be overwritten per project.\n\n    \"\"\"\n    CODE = \"sftp\"\n    LABEL = \"SFTP\"\n\n    def __init__(self, project_name, site_name, tree=None, presets=None):\n        self.presets = None\n        self.project_name = project_name\n        self.site_name = site_name\n        self.root = None\n        self._conn = None\n\n        self.presets = presets\n        if not self.presets:\n            self.log.warning(\n                \"Sync Server: There are no presets for {}.\".format(site_name)\n            )\n            return\n\n        # store to instance for reconnect\n        self.sftp_host = presets[\"sftp_host\"]\n        self.sftp_port = presets[\"sftp_port\"]\n        self.sftp_user = presets[\"sftp_user\"]\n        self.sftp_pass = presets[\"sftp_pass\"]\n        self.sftp_key = presets[\"sftp_key\"]\n        self.sftp_key_pass = presets[\"sftp_key_pass\"]\n\n        self._tree = None\n\n    @property\n    def conn(self):\n        \"\"\"SFTP connection, cannot be used in all places though.\"\"\"\n        if not self._conn:\n            self._conn = self._get_conn()\n\n        return self._conn\n\n    def is_active(self):\n        \"\"\"\n            Returns True if provider is activated, eg. has working credentials.\n        Returns:\n            (boolean)\n        \"\"\"\n        return self.presets.get(\"enabled\") and self.conn is not None\n\n    def get_roots_config(self, anatomy=None):\n        \"\"\"\n            Returns root values for path resolving\n\n            Use only Settings as GDrive cannot be modified by Local Settings\n\n        Returns:\n            (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                     OR\n                     {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n            Format is importing for usage of python's format ** approach\n        \"\"\"\n        # TODO implement multiple roots\n        return {\"root\": {\"work\": self.presets[\"root\"]}}\n\n    def get_tree(self):\n        \"\"\"\n            Building of the folder tree could be potentially expensive,\n            constructor provides argument that could inject previously created\n            tree.\n            Tree structure must be handled in thread safe fashion!\n        Returns:\n             (dictionary) - url to id mapping\n        \"\"\"\n        # not needed in this provider\n        pass\n\n    def create_folder(self, path):\n        \"\"\"\n            Create all nonexistent folders and subfolders in 'path'.\n            Updates self._tree structure with new paths\n\n        Args:\n            path (string): absolute path, starts with GDrive root,\n                           without filename\n        Returns:\n            (string) folder id of lowest subfolder from 'path'\n        \"\"\"\n        self.conn.makedirs(path)\n\n        return os.path.basename(path)\n\n    def upload_file(\n        self,\n        source_path,\n        target_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site_name,\n        overwrite=False\n    ):\n        \"\"\"\n            Uploads single file from 'source_path' to destination 'path'.\n            It creates all folders on the path if are not existing.\n\n        Args:\n            source_path (string): absolute path on provider\n            target_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site_name (str): site name\n            overwrite (boolean): replace existing file\n\n        Returns:\n            (string) file_id of created/modified file ,\n                throws FileExistsError, FileNotFoundError exceptions\n        \"\"\"\n        if not os.path.isfile(source_path):\n            raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                    .format(source_path))\n\n        if self.file_path_exists(target_path):\n            if not overwrite:\n                raise ValueError(\"File {} exists, set overwrite\".\n                                 format(target_path))\n\n        thread = threading.Thread(target=self._upload,\n                                  args=(source_path, target_path))\n        thread.start()\n        self._mark_progress(\n            project_name,\n            file,\n            repre_status,\n            addon,\n            site_name,\n            source_path,\n            target_path,\n            \"upload\"\n        )\n\n        return os.path.basename(target_path)\n\n    def _upload(self, source_path, target_path):\n        print(\"copying {}-&gt;{}\".format(source_path, target_path))\n        conn = self._get_conn()\n        conn.put(source_path, target_path)\n\n    def download_file(\n        self,\n        source_path,\n        target_path,\n        addon,\n        project_name,\n        file,\n        repre_status,\n        site_name,\n        overwrite=False\n    ):\n        \"\"\"\n            Downloads single file from 'source_path' (remote) to 'target_path'.\n            It creates all folders on the local_path if are not existing.\n            By default existing file on 'target_path' will trigger an exception\n\n        Args:\n            source_path (string): absolute path on provider\n            target_path (string): absolute path with or without name of the file\n            addon (SiteSyncAddon): addon instance to call update_db on\n            project_name (str):\n            file (dict): info about uploaded file (matches structure from db)\n            repre_status (dict): complete representation containing\n                sync progress\n            site_name (str): site name\n            overwrite (boolean): replace existing file\n\n        Returns:\n            (string) file_id of created/modified file ,\n                throws FileExistsError, FileNotFoundError exceptions\n        \"\"\"\n        if not self.file_path_exists(source_path):\n            raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                    .format(source_path))\n\n        if os.path.isfile(target_path):\n            if not overwrite:\n                raise ValueError(\"File {} exists, set overwrite\".\n                                 format(target_path))\n\n        thread = threading.Thread(target=self._download,\n                                  args=(source_path, target_path))\n        thread.start()\n        self._mark_progress(\n            project_name,\n            file,\n            repre_status,\n            addon,\n            site_name,\n            source_path,\n            target_path,\n            \"download\"\n        )\n\n        return os.path.basename(target_path)\n\n    def _download(self, source_path, target_path):\n        print(\"downloading {}-&gt;{}\".format(source_path, target_path))\n        conn = self._get_conn()\n        conn.get(source_path, target_path)\n\n    def delete_file(self, path):\n        \"\"\"\n            Deletes file from 'path'. Expects path to specific file.\n\n        Args:\n            path: absolute path to particular file\n\n        Returns:\n            None\n        \"\"\"\n        if not self.file_path_exists(path):\n            raise FileNotFoundError(\"File {} to be deleted doesn't exist.\"\n                                    .format(path))\n\n        self.conn.remove(path)\n\n    def list_folder(self, folder_path):\n        \"\"\"\n            List all files and subfolders of particular path non-recursively.\n\n        Args:\n            folder_path (string): absolut path on provider\n        Returns:\n             (list)\n        \"\"\"\n        return list(pysftp.path_advance(folder_path))\n\n    def folder_path_exists(self, file_path):\n        \"\"\"\n            Checks if path from 'file_path' exists. If so, return its\n            folder id.\n        Args:\n            file_path (string): path with / as a separator\n        Returns:\n            (string) folder id or False\n        \"\"\"\n        if not file_path:\n            return False\n\n        return self.conn.isdir(file_path)\n\n    def file_path_exists(self, file_path):\n        \"\"\"\n            Checks if 'file_path' exists on GDrive\n\n        Args:\n            file_path (string): separated by '/', from root, with file name\n        Returns:\n            (dictionary|boolean) file metadata | False if not found\n        \"\"\"\n        if not file_path:\n            return False\n\n        return self.conn.isfile(file_path)\n\n    def _get_conn(self):\n        \"\"\"\n            Returns fresh sftp connection.\n\n            It seems that connection cannot be cached into self.conn, at least\n            for get and put which run in separate threads.\n\n        Returns:\n            pysftp.Connection\n        \"\"\"\n        if not pysftp:\n            raise ImportError\n\n        cnopts = pysftp.CnOpts()\n        cnopts.hostkeys = None\n\n        conn_params = {\n            'host': self.sftp_host,\n            'port': self.sftp_port,\n            'username': self.sftp_user,\n            'cnopts': cnopts\n        }\n        if self.sftp_pass and self.sftp_pass.strip():\n            conn_params['password'] = self.sftp_pass\n        if self.sftp_key:\n            no_configured_file_exist = False   # expects .pem format, not .ppk!\n            key_paths = self.sftp_key[platform.system().lower()]\n            for key_path in key_paths:\n                no_configured_file_exist = True\n                if os.path.exists(key_path):\n                    no_configured_file_exist = False\n                    conn_params['private_key'] = key_path\n                    break\n            if no_configured_file_exist:\n                raise ValueError(f\"Certificate at '{key_paths}' doesn't exist.\")\n        if self.sftp_key_pass:\n            conn_params['private_key_pass'] = self.sftp_key_pass\n\n        try:\n            return pysftp.Connection(**conn_params)\n        except (paramiko.ssh_exception.SSHException,\n                pysftp.exceptions.ConnectionException):\n            self.log.warning(\"Couldn't connect\", exc_info=True)\n\n    def _mark_progress(\n        self,\n        project_name,\n        file,\n        repre_status,\n        server,\n        site_name,\n        source_path,\n        target_path,\n        direction\n    ):\n        \"\"\"\n            Updates progress field in DB by values 0-1.\n\n            Compares file sizes of source and target.\n        \"\"\"\n        pass\n        if direction == \"upload\":\n            side = \"remote\"\n            source_file_size = os.path.getsize(source_path)\n        else:\n            side = \"local\"\n            source_file_size = self.conn.stat(source_path).st_size\n\n        target_file_size = 0\n        last_tick = status_val = None\n        while source_file_size != target_file_size:\n            if not last_tick or \\\n                    time.time() - last_tick &gt;= server.LOG_PROGRESS_SEC:\n                status_val = target_file_size / source_file_size\n                last_tick = time.time()\n                self.log.debug(direction + \"ed %d%%.\" % int(status_val * 100))\n                server.update_db(\n                    project_name=project_name,\n                    new_file_id=None,\n                    file=file,\n                    repre_status=repre_status,\n                    site_name=site_name,\n                    side=side,\n                    progress=status_val\n                )\n            try:\n                if direction == \"upload\":\n                    target_file_size = self.conn.stat(target_path).st_size\n                else:\n                    target_file_size = os.path.getsize(target_path)\n            except FileNotFoundError:\n                pass\n            time.sleep(0.5)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.conn","title":"<code>conn</code>  <code>property</code>","text":"<p>SFTP connection, cannot be used in all places though.</p>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.create_folder","title":"<code>create_folder(path)</code>","text":"<pre><code>Create all nonexistent folders and subfolders in 'path'.\nUpdates self._tree structure with new paths\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>absolute path, starts with GDrive root,            without filename</p> required <p>Returns:     (string) folder id of lowest subfolder from 'path'</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def create_folder(self, path):\n    \"\"\"\n        Create all nonexistent folders and subfolders in 'path'.\n        Updates self._tree structure with new paths\n\n    Args:\n        path (string): absolute path, starts with GDrive root,\n                       without filename\n    Returns:\n        (string) folder id of lowest subfolder from 'path'\n    \"\"\"\n    self.conn.makedirs(path)\n\n    return os.path.basename(path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.delete_file","title":"<code>delete_file(path)</code>","text":"<pre><code>Deletes file from 'path'. Expects path to specific file.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>absolute path to particular file</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def delete_file(self, path):\n    \"\"\"\n        Deletes file from 'path'. Expects path to specific file.\n\n    Args:\n        path: absolute path to particular file\n\n    Returns:\n        None\n    \"\"\"\n    if not self.file_path_exists(path):\n        raise FileNotFoundError(\"File {} to be deleted doesn't exist.\"\n                                .format(path))\n\n    self.conn.remove(path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.download_file","title":"<code>download_file(source_path, target_path, addon, project_name, file, repre_status, site_name, overwrite=False)</code>","text":"<pre><code>Downloads single file from 'source_path' (remote) to 'target_path'.\nIt creates all folders on the local_path if are not existing.\nBy default existing file on 'target_path' will trigger an exception\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>target_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site_name</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:</p> Type Description <p>(string) file_id of created/modified file , throws FileExistsError, FileNotFoundError exceptions</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def download_file(\n    self,\n    source_path,\n    target_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site_name,\n    overwrite=False\n):\n    \"\"\"\n        Downloads single file from 'source_path' (remote) to 'target_path'.\n        It creates all folders on the local_path if are not existing.\n        By default existing file on 'target_path' will trigger an exception\n\n    Args:\n        source_path (string): absolute path on provider\n        target_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site_name (str): site name\n        overwrite (boolean): replace existing file\n\n    Returns:\n        (string) file_id of created/modified file ,\n            throws FileExistsError, FileNotFoundError exceptions\n    \"\"\"\n    if not self.file_path_exists(source_path):\n        raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                .format(source_path))\n\n    if os.path.isfile(target_path):\n        if not overwrite:\n            raise ValueError(\"File {} exists, set overwrite\".\n                             format(target_path))\n\n    thread = threading.Thread(target=self._download,\n                              args=(source_path, target_path))\n    thread.start()\n    self._mark_progress(\n        project_name,\n        file,\n        repre_status,\n        addon,\n        site_name,\n        source_path,\n        target_path,\n        \"download\"\n    )\n\n    return os.path.basename(target_path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.file_path_exists","title":"<code>file_path_exists(file_path)</code>","text":"<pre><code>Checks if 'file_path' exists on GDrive\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>string</code> <p>separated by '/', from root, with file name</p> required <p>Returns:     (dictionary|boolean) file metadata | False if not found</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def file_path_exists(self, file_path):\n    \"\"\"\n        Checks if 'file_path' exists on GDrive\n\n    Args:\n        file_path (string): separated by '/', from root, with file name\n    Returns:\n        (dictionary|boolean) file metadata | False if not found\n    \"\"\"\n    if not file_path:\n        return False\n\n    return self.conn.isfile(file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.folder_path_exists","title":"<code>folder_path_exists(file_path)</code>","text":"<pre><code>Checks if path from 'file_path' exists. If so, return its\nfolder id.\n</code></pre> <p>Args:     file_path (string): path with / as a separator Returns:     (string) folder id or False</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def folder_path_exists(self, file_path):\n    \"\"\"\n        Checks if path from 'file_path' exists. If so, return its\n        folder id.\n    Args:\n        file_path (string): path with / as a separator\n    Returns:\n        (string) folder id or False\n    \"\"\"\n    if not file_path:\n        return False\n\n    return self.conn.isdir(file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.get_roots_config","title":"<code>get_roots_config(anatomy=None)</code>","text":"<pre><code>Returns root values for path resolving\n\nUse only Settings as GDrive cannot be modified by Local Settings\n</code></pre> <p>Returns:</p> Type Description <p>(dict) - {\"root\": {\"root\": \"/My Drive\"}}      OR      {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}</p> <p>Format is importing for usage of python's format ** approach</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def get_roots_config(self, anatomy=None):\n    \"\"\"\n        Returns root values for path resolving\n\n        Use only Settings as GDrive cannot be modified by Local Settings\n\n    Returns:\n        (dict) - {\"root\": {\"root\": \"/My Drive\"}}\n                 OR\n                 {\"root\": {\"root_ONE\": \"value\", \"root_TWO\":\"value}}\n        Format is importing for usage of python's format ** approach\n    \"\"\"\n    # TODO implement multiple roots\n    return {\"root\": {\"work\": self.presets[\"root\"]}}\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.get_tree","title":"<code>get_tree()</code>","text":"<pre><code>Building of the folder tree could be potentially expensive,\nconstructor provides argument that could inject previously created\ntree.\nTree structure must be handled in thread safe fashion!\n</code></pre> <p>Returns:      (dictionary) - url to id mapping</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def get_tree(self):\n    \"\"\"\n        Building of the folder tree could be potentially expensive,\n        constructor provides argument that could inject previously created\n        tree.\n        Tree structure must be handled in thread safe fashion!\n    Returns:\n         (dictionary) - url to id mapping\n    \"\"\"\n    # not needed in this provider\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.is_active","title":"<code>is_active()</code>","text":"<pre><code>Returns True if provider is activated, eg. has working credentials.\n</code></pre> <p>Returns:     (boolean)</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def is_active(self):\n    \"\"\"\n        Returns True if provider is activated, eg. has working credentials.\n    Returns:\n        (boolean)\n    \"\"\"\n    return self.presets.get(\"enabled\") and self.conn is not None\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.list_folder","title":"<code>list_folder(folder_path)</code>","text":"<pre><code>List all files and subfolders of particular path non-recursively.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>string</code> <p>absolut path on provider</p> required <p>Returns:      (list)</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def list_folder(self, folder_path):\n    \"\"\"\n        List all files and subfolders of particular path non-recursively.\n\n    Args:\n        folder_path (string): absolut path on provider\n    Returns:\n         (list)\n    \"\"\"\n    return list(pysftp.path_advance(folder_path))\n</code></pre>"},{"location":"autoapi/client/ayon_sitesync/providers/sftp.html#client.ayon_sitesync.providers.sftp.SFTPHandler.upload_file","title":"<code>upload_file(source_path, target_path, addon, project_name, file, repre_status, site_name, overwrite=False)</code>","text":"<pre><code>Uploads single file from 'source_path' to destination 'path'.\nIt creates all folders on the path if are not existing.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>string</code> <p>absolute path on provider</p> required <code>target_path</code> <code>string</code> <p>absolute path with or without name of the file</p> required <code>addon</code> <code>SiteSyncAddon</code> <p>addon instance to call update_db on</p> required <code>project_name</code> <code>str</code> required <code>file</code> <code>dict</code> <p>info about uploaded file (matches structure from db)</p> required <code>repre_status</code> <code>dict</code> <p>complete representation containing sync progress</p> required <code>site_name</code> <code>str</code> <p>site name</p> required <code>overwrite</code> <code>boolean</code> <p>replace existing file</p> <code>False</code> <p>Returns:</p> Type Description <p>(string) file_id of created/modified file , throws FileExistsError, FileNotFoundError exceptions</p> Source code in <code>client/ayon_sitesync/providers/sftp.py</code> <pre><code>def upload_file(\n    self,\n    source_path,\n    target_path,\n    addon,\n    project_name,\n    file,\n    repre_status,\n    site_name,\n    overwrite=False\n):\n    \"\"\"\n        Uploads single file from 'source_path' to destination 'path'.\n        It creates all folders on the path if are not existing.\n\n    Args:\n        source_path (string): absolute path on provider\n        target_path (string): absolute path with or without name of the file\n        addon (SiteSyncAddon): addon instance to call update_db on\n        project_name (str):\n        file (dict): info about uploaded file (matches structure from db)\n        repre_status (dict): complete representation containing\n            sync progress\n        site_name (str): site name\n        overwrite (boolean): replace existing file\n\n    Returns:\n        (string) file_id of created/modified file ,\n            throws FileExistsError, FileNotFoundError exceptions\n    \"\"\"\n    if not os.path.isfile(source_path):\n        raise FileNotFoundError(\"Source file {} doesn't exist.\"\n                                .format(source_path))\n\n    if self.file_path_exists(target_path):\n        if not overwrite:\n            raise ValueError(\"File {} exists, set overwrite\".\n                             format(target_path))\n\n    thread = threading.Thread(target=self._upload,\n                              args=(source_path, target_path))\n    thread.start()\n    self._mark_progress(\n        project_name,\n        file,\n        repre_status,\n        addon,\n        site_name,\n        source_path,\n        target_path,\n        \"upload\"\n    )\n\n    return os.path.basename(target_path)\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/index.html#server.SiteSync","title":"<code>SiteSync</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> Source code in <code>server/__init__.py</code> <pre><code>class SiteSync(BaseServerAddon):\n    settings_model: Type[SiteSyncSettings] = SiteSyncSettings\n\n    frontend_scopes: dict[str, Any] = {\"project\": {}}\n\n    def initialize(self) -&gt; None:\n\n        self.add_endpoint(\n            \"/{project_name}/get_user_sites\",\n            self.get_user_sites,\n            method=\"GET\",\n        )\n\n        self.add_endpoint(\n            \"/{project_name}/params\",\n            self.get_site_sync_params,\n            method=\"GET\",\n        )\n\n        self.add_endpoint(\n            \"/{project_name}/state\",\n            self.get_site_sync_state,\n            method=\"GET\",\n        )\n\n        self.add_endpoint(\n            \"/{project_name}/state/{representation_id}/{site_name}\",  # noqa\n            self.set_site_sync_representation_state,\n            method=\"POST\",\n        )\n\n        self.add_endpoint(\n            \"/{project_name}/state/{representation_id}/{site_name}\",  # noqa\n            self.remove_site_sync_representation_state,\n            method=\"DELETE\",\n        )\n\n    #\n    # GET SITE SYNC PARAMS\n    #\n\n    async def get_site_sync_params(\n        self,\n        project_name: ProjectName,\n        user: CurrentUser,\n    ) -&gt; SiteSyncParamsModel:\n\n        access_list = await folder_access_list(user, project_name, \"read\")\n        conditions = []\n        if access_list is not None:\n            conditions.append(f\"h.path like ANY ('{{ {','.join(access_list)} }}')\")\n\n        query = f\"\"\"\n            SELECT\n                DISTINCT(r.name) as name,\n                COUNT (*) OVER () as total_count\n            FROM project_{project_name}.representations as r\n            INNER JOIN project_{project_name}.versions as v\n                ON r.version_id = v.id\n            INNER JOIN project_{project_name}.products as p\n                ON v.product_id = p.id\n            INNER JOIN project_{project_name}.hierarchy as h\n                ON p.folder_id = h.id\n            {SQLTool.conditions(conditions)}\n        \"\"\"\n\n        total_count = 0\n        names = []\n        async for row in Postgres.iterate(query):\n            total_count = row[\"total_count\"] or 0\n            names.append(row[\"name\"])\n\n        return SiteSyncParamsModel(count=total_count, names=names)\n\n    #\n    # GET USER SYNC SITES\n    #\n\n    async def get_user_sites(\n        self,\n        project_name: ProjectName,\n        user: CurrentUser,\n    ) -&gt; dict[str, list[str]]:\n        sites = {\"active_site\": [], \"remote_site\": []}\n        site_infos = await Postgres.fetch(\"select id, data from sites\")\n        for site_info in site_infos:\n            settings = await self.get_project_site_settings(\n                project_name, user.name, site_info[\"id\"]\n            )\n            for site_type in [\"active_site\", \"remote_site\"]:\n                used_site = settings.dict()[\"local_setting\"][site_type]\n                if not used_site:\n                    continue\n\n                if used_site == \"local\":\n                    sites[site_type].append(site_info[\"id\"])\n                else:\n                    sites[site_type].append(used_site)\n        return sites\n\n\n    #\n    # GET SITE SYNC OVERAL STATE\n    #\n    async def get_site_sync_state(\n        self,\n        project_name: ProjectName,\n        user: CurrentUser,\n        representationIds: list[str] | None = Query(\n            None,\n            description=\"Filter by representation ids\",\n            example=\"['57cf375c749611ed89de0242ac140004']\",\n        ),\n        repreNameFilter: list[str] | None = Query(None,\n            description=\"Filter by representation name\"),\n        localSite: str = Query(\n            ...,\n            description=\"Name of the local site\",\n            example=\"Machine42\",\n        ),\n        remoteSite: str = Query(\n            ...,\n            description=\"Name of the remote site\",\n            example=\"GDrive\",\n        ),\n        folderFilter: str | None = Query(\n            None,\n            description=\"Filter folders by name\",\n            example=\"sh042\",\n        ),\n        folderIdsFilter: list[str] | None = Query(\n            None,\n            description=\"Filter folders by id, eg filtering by asset ids\",\n            example=\"['57cf375c749611ed89de0242ac140004']\",\n        ),\n        productFilter: str | None = Query(\n            None,\n            description=\"Filter products by name\",\n            example=\"animation\",\n        ),\n        versionFilter: int | None = Query(\n            None,\n            description=\"Filter products by version\",\n            example=\"1\",\n        ),\n        versionIdsFilter: list[str] | None = Query(\n            None,\n            description=\"Filter versions by ids\",\n            example=\"['57cf375c749611ed89de0242ac140004']\",\n        ),\n        localStatusFilter: list[StatusEnum] | None = Query(\n            None,\n            description=f\"List of states to show. Available options: {StatusEnum.__doc__}\",\n            example=[StatusEnum.QUEUED, StatusEnum.IN_PROGRESS],\n        ),\n        remoteStatusFilter: list[StatusEnum] | None = Query(\n            None,\n            description=f\"List of states to show. Available options: {StatusEnum.__doc__}\",\n            example=[StatusEnum.QUEUED, StatusEnum.IN_PROGRESS],\n        ),\n        sortBy: SortByEnum = Query(\n            SortByEnum.folder,\n            description=\"Sort the result by this value\",\n            example=SortByEnum.folder,\n        ),\n        sortDesc: bool = Query(\n            False,\n            name=\"Sort descending\",\n            description=\"Sort the result in descending order\",\n        ),\n        bothOnly: bool = Query(\n            False,\n            name=\"Query only with both sites\",\n            description=\"Used for front end UI to show only repres with\"\n                        \" both sides\",\n        ),\n        # Pagination\n        page: int = Query(1, ge=1),\n        pageLength: int = Query(50, ge=1),\n    ) -&gt; SiteSyncSummaryModel:\n        \"\"\"Return a site sync state.\n\n        Used for querying representations to be synchronized and state of\n        versions and representations to show in Loader UI.\n        \"\"\"\n        await check_sync_status_table(project_name)\n        conditions = []\n\n        if representationIds is not None:\n            conditions.append(f\"r.id IN {SQLTool.array(representationIds)}\")\n\n        if folderFilter:\n            conditions.append(f\"f.name ILIKE '%{folderFilter}%'\")\n\n        if folderIdsFilter:\n            conditions.append(f\"f.id IN {SQLTool.array(folderIdsFilter)}\")\n\n        if productFilter:\n            conditions.append(f\"p.name ILIKE '%{productFilter}%'\")\n\n        if versionFilter:\n            conditions.append(f\"v.version = {versionFilter}\")\n\n        if versionIdsFilter:\n            conditions.append(f\"v.id IN {SQLTool.array(versionIdsFilter)}\")\n\n        if localStatusFilter:\n            statusFilter = [str(s.value) for s in localStatusFilter]\n            conditions.append(f\"local.status IN ({','.join(statusFilter)})\")\n\n        if remoteStatusFilter:\n            statusFilter = [str(s.value) for s in remoteStatusFilter]\n            conditions.append(f\"remote.status IN ({','.join(statusFilter)})\")\n\n        if repreNameFilter:\n            conditions.append(f\"r.name IN {SQLTool.array(repreNameFilter)}\")\n\n        access_list = await folder_access_list(user, project_name, \"read\")\n        if access_list is not None:\n            conditions.append(f\"path like ANY ('{{ {','.join(access_list)} }}')\")\n\n        sites_join = \"LEFT\"\n        if bothOnly:\n            sites_join = \"INNER\"\n\n        query = f\"\"\"\n            SELECT\n                f.name as folder,\n                p.name as product,\n                v.version as version,\n                r.name as representation,\n                h.path as path,\n\n                r.id as representation_id,\n                r.files as representation_files,\n                local.data as local_data,\n                remote.data as remote_data,\n                local.status as localStatus,\n                remote.status as remoteStatus,\n                v.id as version_id\n            FROM\n                project_{project_name}.folders as f\n            INNER JOIN\n                project_{project_name}.products as p\n                ON p.folder_id = f.id\n            INNER JOIN\n                project_{project_name}.versions as v\n                ON v.product_id = p.id\n            INNER JOIN\n                project_{project_name}.representations as r\n                ON r.version_id = v.id\n            INNER JOIN\n                project_{project_name}.hierarchy as h\n                ON f.id = h.id\n            {sites_join} JOIN\n                project_{project_name}.sitesync_files_status as local\n                ON local.representation_id = r.id\n                AND local.site_name = '{localSite}'\n            {sites_join} JOIN\n                project_{project_name}.sitesync_files_status as remote\n                ON remote.representation_id = r.id\n                AND remote.site_name = '{remoteSite}'\n\n            {SQLTool.conditions(conditions)}\n\n            ORDER BY {sortBy.value} {'DESC' if sortDesc else 'ASC'}\n            LIMIT {pageLength}\n            OFFSET { (page-1) * pageLength }\n        \"\"\"\n        repres = []\n\n        async for row in Postgres.iterate(query):\n            files = row[\"representation_files\"]\n            file_count = len(files)\n            total_size = sum([f.get(\"size\") for f in files])\n\n            ldata = row[\"local_data\"] or {}\n            lfiles = ldata.get(\"files\", {})\n            lsize = sum([f.get(\"size\") for f in lfiles.values()] or [0])\n            ltime = max([f.get(\"timestamp\") for f in lfiles.values()] or [0])\n\n            rdata = row[\"remote_data\"] or {}\n            rfiles = rdata.get(\"files\", {})\n            rsize = sum([f.get(\"size\") for f in rfiles.values()] or [0])\n            rtime = max([f.get(\"timestamp\") for f in rfiles.values()] or [0])\n\n            local_status = SyncStatusModel(\n                status=StatusEnum.NOT_AVAILABLE\n                if row[\"localstatus\"] is None\n                else row[\"localstatus\"],\n                totalSize=total_size,\n                size=lsize,\n                timestamp=ltime,\n            )\n            remote_status = SyncStatusModel(\n                status=StatusEnum.NOT_AVAILABLE\n                if row[\"remotestatus\"] is None\n                else row[\"remotestatus\"],\n                totalSize=total_size,\n                size=rsize,\n                timestamp=rtime,\n            )\n\n            file_list = []\n            for file_info in files:\n                file_id = file_info[\"id\"]\n                local_file = lfiles.get(file_id, {})\n                remote_file = rfiles.get(file_id, {})\n\n                file_list.append(\n                    FileModel(\n                        id=file_id,\n                        fileHash=file_info[\"hash\"],\n                        size=file_info[\"size\"],\n                        path=file_info[\"path\"],\n                        baseName=os.path.split(file_info[\"path\"])[1],\n                        localStatus=SyncStatusModel(\n                            status=local_file.get(\"status\",\n                                                StatusEnum.NOT_AVAILABLE),\n                            size=local_file.get(\"size\", 0),\n                            totalSize=file_info[\"size\"],\n                            timestamp=local_file.get(\"timestamp\", 0),\n                            message=local_file.get(\"message\", None),\n                            retries=local_file.get(\"retries\", 0),\n                        ),\n                        remoteStatus=SyncStatusModel(\n                            status=remote_file.get(\"status\",\n                                                StatusEnum.NOT_AVAILABLE),\n                            size=remote_file.get(\"size\", 0),\n                            totalSize=file_info[\"size\"],\n                            timestamp=remote_file.get(\"timestamp\", 0),\n                            message=remote_file.get(\"message\", None),\n                            retries=remote_file.get(\"retries\", 0),\n                        ),\n                    )\n                )\n\n            repres.append(\n                SiteSyncSummaryItem.construct(\n                    folder=row[\"folder\"],\n                    product=row[\"product\"],\n                    version=row[\"version\"],\n                    representation=row[\"representation\"],\n                    representationId=row[\"representation_id\"],\n                    fileCount=file_count,\n                    size=total_size,\n                    localStatus=local_status,\n                    remoteStatus=remote_status,\n                    files=file_list,\n                    version_id=row[\"version_id\"]\n                )\n            )\n\n        return SiteSyncSummaryModel(representations=repres)\n\n\n    #\n    # SET REPRESENTATION SYNC STATE\n    #\n\n    async def set_site_sync_representation_state(\n        self,\n        post_data: RepresentationStateModel,\n        project_name: ProjectName,\n        representation_id: RepresentationID,\n        site_name: str = Path(...),  # TODO: add regex validator/dependency here! Important!\n\n        # TODO: add CurrentUser dependency here! This endpoint is public now!\n    ) -&gt; Response:\n        \"\"\"Adds site information to representation.\n\n        Called after integration to set initial state of representation files on\n        sites.\n        Called repeatedly during synchronization to update progress/store error\n        message\n        \"\"\"\n        await check_sync_status_table(project_name)\n\n        priority = post_data.priority\n\n        async with Postgres.acquire() as conn:\n            async with conn.transaction():\n                query = (\n                    f\"\"\"\n                    SELECT priority, data\n                    FROM project_{project_name}.sitesync_files_status\n                    WHERE representation_id = $1 AND site_name = $2\n                    FOR UPDATE\n                    \"\"\",\n                    representation_id,\n                    site_name,\n                )\n\n                result = await conn.fetch(*query)\n                do_insert = False\n                if not result:\n                    do_insert = True\n                    repre = await RepresentationEntity.load(\n                        project_name, representation_id, transaction=conn\n                    )\n\n                    files = {}\n                    for file_info in repre._payload.files:\n                        fhash = file_info.hash\n                        files[file_info.id] = {\n                            \"hash\": fhash,\n                            \"status\": StatusEnum.NOT_AVAILABLE,\n                            \"size\": 0,\n                            \"timestamp\": 0,\n                        }\n                else:\n                    files = result[0][\"data\"].get(\"files\")\n                    if priority is None:\n                        priority = result[0][\"priority\"]\n\n                for posted_file in post_data.files:\n                    posted_file_id = posted_file.id\n                    if posted_file_id not in files:\n                        logging.warning(f\"{posted_file} not in files\")\n                        continue\n                    files[posted_file_id][\"timestamp\"] = posted_file.timestamp\n                    files[posted_file_id][\"status\"] = posted_file.status\n                    files[posted_file_id][\"size\"] = posted_file.size\n\n                    if posted_file.message:\n                        files[posted_file_id][\"message\"] = posted_file.message\n                    elif \"message\" in files[posted_file_id]:\n                        del files[posted_file_id][\"message\"]\n\n                    if posted_file.retries:\n                        files[posted_file_id][\"retries\"] = posted_file.retries\n                    elif \"retries\" in files[posted_file_id]:\n                        del files[posted_file_id][\"retries\"]\n\n                status = get_overal_status(files)\n\n                if do_insert:\n                    await conn.execute(\n                        f\"\"\"\n                        INSERT INTO project_{project_name}.sitesync_files_status\n                        (representation_id, site_name, status, priority, data)\n                        VALUES ($1, $2, $3, $4, $5)\n                        \"\"\",\n                        representation_id,\n                        site_name,\n                        status,\n                        post_data.priority if post_data.priority is not None else 50,\n                        {\"files\": files},\n                    )\n                else:\n                    await conn.execute(\n                        f\"\"\"\n                        UPDATE project_{project_name}.sitesync_files_status\n                        SET status = $1, data = $2, priority = $3\n                        WHERE representation_id = $4 AND site_name = $5\n                        \"\"\",\n                        status,\n                        {\"files\": files},\n                        priority,\n                        representation_id,\n                        site_name,\n                    )\n\n        return Response(status_code=204)\n\n    async def remove_site_sync_representation_state(\n        self,\n        project_name: ProjectName,\n        user: CurrentUser,\n        representation_id: RepresentationID,\n        site_name: str = Path(...),  # TODO: add regex validator/dependency here! Important!\n    ) -&gt; Response:\n        await check_sync_status_table(project_name)\n\n        async with Postgres.acquire() as conn:\n            async with conn.transaction():\n                query = (\n                    f\"\"\"\n                    DELETE\n                    FROM project_{project_name}.sitesync_files_status\n                    WHERE representation_id = $1 AND site_name = $2\n                    \"\"\",\n                    representation_id,\n                    site_name,\n                )\n\n                await conn.fetch(*query)\n\n                return Response(status_code=204)\n</code></pre>"},{"location":"autoapi/server/index.html#server.SiteSync.get_site_sync_state","title":"<code>get_site_sync_state(project_name, user, representationIds=Query(None, description='Filter by representation ids', example=\"['57cf375c749611ed89de0242ac140004']\"), repreNameFilter=Query(None, description='Filter by representation name'), localSite=Query(..., description='Name of the local site', example='Machine42'), remoteSite=Query(..., description='Name of the remote site', example='GDrive'), folderFilter=Query(None, description='Filter folders by name', example='sh042'), folderIdsFilter=Query(None, description='Filter folders by id, eg filtering by asset ids', example=\"['57cf375c749611ed89de0242ac140004']\"), productFilter=Query(None, description='Filter products by name', example='animation'), versionFilter=Query(None, description='Filter products by version', example='1'), versionIdsFilter=Query(None, description='Filter versions by ids', example=\"['57cf375c749611ed89de0242ac140004']\"), localStatusFilter=Query(None, description=f'List of states to show. Available options: {StatusEnum.__doc__}', example=[StatusEnum.QUEUED, StatusEnum.IN_PROGRESS]), remoteStatusFilter=Query(None, description=f'List of states to show. Available options: {StatusEnum.__doc__}', example=[StatusEnum.QUEUED, StatusEnum.IN_PROGRESS]), sortBy=Query(SortByEnum.folder, description='Sort the result by this value', example=SortByEnum.folder), sortDesc=Query(False, name='Sort descending', description='Sort the result in descending order'), bothOnly=Query(False, name='Query only with both sites', description='Used for front end UI to show only repres with both sides'), page=Query(1, ge=1), pageLength=Query(50, ge=1))</code>  <code>async</code>","text":"<p>Return a site sync state.</p> <p>Used for querying representations to be synchronized and state of versions and representations to show in Loader UI.</p> Source code in <code>server/__init__.py</code> <pre><code>async def get_site_sync_state(\n    self,\n    project_name: ProjectName,\n    user: CurrentUser,\n    representationIds: list[str] | None = Query(\n        None,\n        description=\"Filter by representation ids\",\n        example=\"['57cf375c749611ed89de0242ac140004']\",\n    ),\n    repreNameFilter: list[str] | None = Query(None,\n        description=\"Filter by representation name\"),\n    localSite: str = Query(\n        ...,\n        description=\"Name of the local site\",\n        example=\"Machine42\",\n    ),\n    remoteSite: str = Query(\n        ...,\n        description=\"Name of the remote site\",\n        example=\"GDrive\",\n    ),\n    folderFilter: str | None = Query(\n        None,\n        description=\"Filter folders by name\",\n        example=\"sh042\",\n    ),\n    folderIdsFilter: list[str] | None = Query(\n        None,\n        description=\"Filter folders by id, eg filtering by asset ids\",\n        example=\"['57cf375c749611ed89de0242ac140004']\",\n    ),\n    productFilter: str | None = Query(\n        None,\n        description=\"Filter products by name\",\n        example=\"animation\",\n    ),\n    versionFilter: int | None = Query(\n        None,\n        description=\"Filter products by version\",\n        example=\"1\",\n    ),\n    versionIdsFilter: list[str] | None = Query(\n        None,\n        description=\"Filter versions by ids\",\n        example=\"['57cf375c749611ed89de0242ac140004']\",\n    ),\n    localStatusFilter: list[StatusEnum] | None = Query(\n        None,\n        description=f\"List of states to show. Available options: {StatusEnum.__doc__}\",\n        example=[StatusEnum.QUEUED, StatusEnum.IN_PROGRESS],\n    ),\n    remoteStatusFilter: list[StatusEnum] | None = Query(\n        None,\n        description=f\"List of states to show. Available options: {StatusEnum.__doc__}\",\n        example=[StatusEnum.QUEUED, StatusEnum.IN_PROGRESS],\n    ),\n    sortBy: SortByEnum = Query(\n        SortByEnum.folder,\n        description=\"Sort the result by this value\",\n        example=SortByEnum.folder,\n    ),\n    sortDesc: bool = Query(\n        False,\n        name=\"Sort descending\",\n        description=\"Sort the result in descending order\",\n    ),\n    bothOnly: bool = Query(\n        False,\n        name=\"Query only with both sites\",\n        description=\"Used for front end UI to show only repres with\"\n                    \" both sides\",\n    ),\n    # Pagination\n    page: int = Query(1, ge=1),\n    pageLength: int = Query(50, ge=1),\n) -&gt; SiteSyncSummaryModel:\n    \"\"\"Return a site sync state.\n\n    Used for querying representations to be synchronized and state of\n    versions and representations to show in Loader UI.\n    \"\"\"\n    await check_sync_status_table(project_name)\n    conditions = []\n\n    if representationIds is not None:\n        conditions.append(f\"r.id IN {SQLTool.array(representationIds)}\")\n\n    if folderFilter:\n        conditions.append(f\"f.name ILIKE '%{folderFilter}%'\")\n\n    if folderIdsFilter:\n        conditions.append(f\"f.id IN {SQLTool.array(folderIdsFilter)}\")\n\n    if productFilter:\n        conditions.append(f\"p.name ILIKE '%{productFilter}%'\")\n\n    if versionFilter:\n        conditions.append(f\"v.version = {versionFilter}\")\n\n    if versionIdsFilter:\n        conditions.append(f\"v.id IN {SQLTool.array(versionIdsFilter)}\")\n\n    if localStatusFilter:\n        statusFilter = [str(s.value) for s in localStatusFilter]\n        conditions.append(f\"local.status IN ({','.join(statusFilter)})\")\n\n    if remoteStatusFilter:\n        statusFilter = [str(s.value) for s in remoteStatusFilter]\n        conditions.append(f\"remote.status IN ({','.join(statusFilter)})\")\n\n    if repreNameFilter:\n        conditions.append(f\"r.name IN {SQLTool.array(repreNameFilter)}\")\n\n    access_list = await folder_access_list(user, project_name, \"read\")\n    if access_list is not None:\n        conditions.append(f\"path like ANY ('{{ {','.join(access_list)} }}')\")\n\n    sites_join = \"LEFT\"\n    if bothOnly:\n        sites_join = \"INNER\"\n\n    query = f\"\"\"\n        SELECT\n            f.name as folder,\n            p.name as product,\n            v.version as version,\n            r.name as representation,\n            h.path as path,\n\n            r.id as representation_id,\n            r.files as representation_files,\n            local.data as local_data,\n            remote.data as remote_data,\n            local.status as localStatus,\n            remote.status as remoteStatus,\n            v.id as version_id\n        FROM\n            project_{project_name}.folders as f\n        INNER JOIN\n            project_{project_name}.products as p\n            ON p.folder_id = f.id\n        INNER JOIN\n            project_{project_name}.versions as v\n            ON v.product_id = p.id\n        INNER JOIN\n            project_{project_name}.representations as r\n            ON r.version_id = v.id\n        INNER JOIN\n            project_{project_name}.hierarchy as h\n            ON f.id = h.id\n        {sites_join} JOIN\n            project_{project_name}.sitesync_files_status as local\n            ON local.representation_id = r.id\n            AND local.site_name = '{localSite}'\n        {sites_join} JOIN\n            project_{project_name}.sitesync_files_status as remote\n            ON remote.representation_id = r.id\n            AND remote.site_name = '{remoteSite}'\n\n        {SQLTool.conditions(conditions)}\n\n        ORDER BY {sortBy.value} {'DESC' if sortDesc else 'ASC'}\n        LIMIT {pageLength}\n        OFFSET { (page-1) * pageLength }\n    \"\"\"\n    repres = []\n\n    async for row in Postgres.iterate(query):\n        files = row[\"representation_files\"]\n        file_count = len(files)\n        total_size = sum([f.get(\"size\") for f in files])\n\n        ldata = row[\"local_data\"] or {}\n        lfiles = ldata.get(\"files\", {})\n        lsize = sum([f.get(\"size\") for f in lfiles.values()] or [0])\n        ltime = max([f.get(\"timestamp\") for f in lfiles.values()] or [0])\n\n        rdata = row[\"remote_data\"] or {}\n        rfiles = rdata.get(\"files\", {})\n        rsize = sum([f.get(\"size\") for f in rfiles.values()] or [0])\n        rtime = max([f.get(\"timestamp\") for f in rfiles.values()] or [0])\n\n        local_status = SyncStatusModel(\n            status=StatusEnum.NOT_AVAILABLE\n            if row[\"localstatus\"] is None\n            else row[\"localstatus\"],\n            totalSize=total_size,\n            size=lsize,\n            timestamp=ltime,\n        )\n        remote_status = SyncStatusModel(\n            status=StatusEnum.NOT_AVAILABLE\n            if row[\"remotestatus\"] is None\n            else row[\"remotestatus\"],\n            totalSize=total_size,\n            size=rsize,\n            timestamp=rtime,\n        )\n\n        file_list = []\n        for file_info in files:\n            file_id = file_info[\"id\"]\n            local_file = lfiles.get(file_id, {})\n            remote_file = rfiles.get(file_id, {})\n\n            file_list.append(\n                FileModel(\n                    id=file_id,\n                    fileHash=file_info[\"hash\"],\n                    size=file_info[\"size\"],\n                    path=file_info[\"path\"],\n                    baseName=os.path.split(file_info[\"path\"])[1],\n                    localStatus=SyncStatusModel(\n                        status=local_file.get(\"status\",\n                                            StatusEnum.NOT_AVAILABLE),\n                        size=local_file.get(\"size\", 0),\n                        totalSize=file_info[\"size\"],\n                        timestamp=local_file.get(\"timestamp\", 0),\n                        message=local_file.get(\"message\", None),\n                        retries=local_file.get(\"retries\", 0),\n                    ),\n                    remoteStatus=SyncStatusModel(\n                        status=remote_file.get(\"status\",\n                                            StatusEnum.NOT_AVAILABLE),\n                        size=remote_file.get(\"size\", 0),\n                        totalSize=file_info[\"size\"],\n                        timestamp=remote_file.get(\"timestamp\", 0),\n                        message=remote_file.get(\"message\", None),\n                        retries=remote_file.get(\"retries\", 0),\n                    ),\n                )\n            )\n\n        repres.append(\n            SiteSyncSummaryItem.construct(\n                folder=row[\"folder\"],\n                product=row[\"product\"],\n                version=row[\"version\"],\n                representation=row[\"representation\"],\n                representationId=row[\"representation_id\"],\n                fileCount=file_count,\n                size=total_size,\n                localStatus=local_status,\n                remoteStatus=remote_status,\n                files=file_list,\n                version_id=row[\"version_id\"]\n            )\n        )\n\n    return SiteSyncSummaryModel(representations=repres)\n</code></pre>"},{"location":"autoapi/server/index.html#server.SiteSync.set_site_sync_representation_state","title":"<code>set_site_sync_representation_state(post_data, project_name, representation_id, site_name=Path(...))</code>  <code>async</code>","text":"<p>Adds site information to representation.</p> <p>Called after integration to set initial state of representation files on sites. Called repeatedly during synchronization to update progress/store error message</p> Source code in <code>server/__init__.py</code> <pre><code>async def set_site_sync_representation_state(\n    self,\n    post_data: RepresentationStateModel,\n    project_name: ProjectName,\n    representation_id: RepresentationID,\n    site_name: str = Path(...),  # TODO: add regex validator/dependency here! Important!\n\n    # TODO: add CurrentUser dependency here! This endpoint is public now!\n) -&gt; Response:\n    \"\"\"Adds site information to representation.\n\n    Called after integration to set initial state of representation files on\n    sites.\n    Called repeatedly during synchronization to update progress/store error\n    message\n    \"\"\"\n    await check_sync_status_table(project_name)\n\n    priority = post_data.priority\n\n    async with Postgres.acquire() as conn:\n        async with conn.transaction():\n            query = (\n                f\"\"\"\n                SELECT priority, data\n                FROM project_{project_name}.sitesync_files_status\n                WHERE representation_id = $1 AND site_name = $2\n                FOR UPDATE\n                \"\"\",\n                representation_id,\n                site_name,\n            )\n\n            result = await conn.fetch(*query)\n            do_insert = False\n            if not result:\n                do_insert = True\n                repre = await RepresentationEntity.load(\n                    project_name, representation_id, transaction=conn\n                )\n\n                files = {}\n                for file_info in repre._payload.files:\n                    fhash = file_info.hash\n                    files[file_info.id] = {\n                        \"hash\": fhash,\n                        \"status\": StatusEnum.NOT_AVAILABLE,\n                        \"size\": 0,\n                        \"timestamp\": 0,\n                    }\n            else:\n                files = result[0][\"data\"].get(\"files\")\n                if priority is None:\n                    priority = result[0][\"priority\"]\n\n            for posted_file in post_data.files:\n                posted_file_id = posted_file.id\n                if posted_file_id not in files:\n                    logging.warning(f\"{posted_file} not in files\")\n                    continue\n                files[posted_file_id][\"timestamp\"] = posted_file.timestamp\n                files[posted_file_id][\"status\"] = posted_file.status\n                files[posted_file_id][\"size\"] = posted_file.size\n\n                if posted_file.message:\n                    files[posted_file_id][\"message\"] = posted_file.message\n                elif \"message\" in files[posted_file_id]:\n                    del files[posted_file_id][\"message\"]\n\n                if posted_file.retries:\n                    files[posted_file_id][\"retries\"] = posted_file.retries\n                elif \"retries\" in files[posted_file_id]:\n                    del files[posted_file_id][\"retries\"]\n\n            status = get_overal_status(files)\n\n            if do_insert:\n                await conn.execute(\n                    f\"\"\"\n                    INSERT INTO project_{project_name}.sitesync_files_status\n                    (representation_id, site_name, status, priority, data)\n                    VALUES ($1, $2, $3, $4, $5)\n                    \"\"\",\n                    representation_id,\n                    site_name,\n                    status,\n                    post_data.priority if post_data.priority is not None else 50,\n                    {\"files\": files},\n                )\n            else:\n                await conn.execute(\n                    f\"\"\"\n                    UPDATE project_{project_name}.sitesync_files_status\n                    SET status = $1, data = $2, priority = $3\n                    WHERE representation_id = $4 AND site_name = $5\n                    \"\"\",\n                    status,\n                    {\"files\": files},\n                    priority,\n                    representation_id,\n                    site_name,\n                )\n\n    return Response(status_code=204)\n</code></pre>"},{"location":"autoapi/server/index.html#server.check_sync_status_table","title":"<code>check_sync_status_table(project_name)</code>  <code>async</code>","text":"<p>Checks for existence of <code>sitesync_files_status</code> table, creates if not.</p> Source code in <code>server/__init__.py</code> <pre><code>async def check_sync_status_table(project_name: str) -&gt; None:\n    \"\"\"Checks for existence of `sitesync_files_status` table, creates if not.\"\"\"\n    await Postgres.execute(\n        f\"CREATE TABLE IF NOT EXISTS project_{project_name}.sitesync_files_status (\"\n        f\"\"\"representation_id UUID NOT NULL REFERENCES project_{project_name}.representations(id) ON DELETE CASCADE,\n            site_name VARCHAR NOT NULL,\n            status INTEGER NOT NULL DEFAULT -1,\n            priority INTEGER NOT NULL DEFAULT 50,\n            data JSONB NOT NULL DEFAULT '{{}}'::JSONB,\n            PRIMARY KEY (representation_id, site_name)\n        );\"\"\"\n    )\n    await Postgres.execute(f\"CREATE INDEX IF NOT EXISTS file_status_idx ON project_{project_name}.sitesync_files_status(status);\")\n    await Postgres.execute(f\"CREATE INDEX IF NOT EXISTS file_priority_idx ON project_{project_name}.sitesync_files_status(priority desc);\")\n</code></pre>"},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/models.html","title":"models","text":""},{"location":"autoapi/server/settings/models.html#server.settings.models.StatusEnum","title":"<code>StatusEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>-1 : State is not available 0 : Transfer in progress 1 : File is queued for Transfer 2 : Transfer failed 3 : Tranfer is paused 4 : File/representation is fully synchronized</p> Source code in <code>server/settings/models.py</code> <pre><code>class StatusEnum(enum.IntEnum):\n    \"\"\"\n    -1 : State is not available\n    0 : Transfer in progress\n    1 : File is queued for Transfer\n    2 : Transfer failed\n    3 : Tranfer is paused\n    4 : File/representation is fully synchronized\n    \"\"\"\n\n    NOT_AVAILABLE = -1\n    IN_PROGRESS = 0\n    QUEUED = 1\n    FAILED = 2\n    PAUSED = 3\n    SYNCED = 4\n</code></pre>"},{"location":"autoapi/server/settings/settings.html","title":"settings","text":""},{"location":"autoapi/server/settings/settings.html#server.settings.settings.GeneralSubmodel","title":"<code>GeneralSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Properties for loop and module configuration</p> Source code in <code>server/settings/settings.py</code> <pre><code>class GeneralSubmodel(BaseSettingsModel):\n    \"\"\"Properties for loop and module configuration\"\"\"\n    retry_cnt: int = Field(3, title=\"Retry Count\")\n    loop_delay: int = Field(60, title=\"Loop Delay\")\n    always_accessible_on: list[str] = Field([],\n                                            title=\"Always accessible on sites\")\n    active_site: str = Field(\"studio\", title=\"User Default Active Site\")\n    remote_site: str = Field(\"studio\", title=\"User Default Remote Site\")\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.LocalSubmodel","title":"<code>LocalSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Select your local and remote site</p> Source code in <code>server/settings/settings.py</code> <pre><code>class LocalSubmodel(BaseSettingsModel):\n    \"\"\"Select your local and remote site\"\"\"\n    active_site: str = Field(\"\",\n                             title=\"My Active Site\",\n                             scope=[\"site\"],\n                             enum_resolver=defined_sited_enum_resolver)\n\n    remote_site: str = Field(\"\",\n                             title=\"My Remote Site\",\n                             scope=[\"site\"],\n                             enum_resolver=defined_sited_enum_resolver)\n\n    local_roots: list[RootSubmodel] = Field(\n        default=default_roots,\n        title=\"Local roots overrides\",\n        scope=[\"site\"],\n        description=\"Overrides for local root(s).\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.RootSubmodel","title":"<code>RootSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Setup root paths for local site.</p> <p>Studio roots overrides are in separate <code>Roots</code> tab outside of Site Sync.</p> Source code in <code>server/settings/settings.py</code> <pre><code>class RootSubmodel(BaseSettingsModel):\n    \"\"\"Setup root paths for local site.\n\n    Studio roots overrides are in separate `Roots` tab outside of Site Sync.\n    \"\"\"\n\n    _layout: str = \"expanded\"\n\n    name: str = Field(\n        \"work\",\n        title=\"Root name\",\n        regex=\"^[a-zA-Z0-9_]{1,}$\",\n        scope=[\"site\"],\n    )\n\n    path: str = Field(\n        \"c:/projects_local\",\n        title=\"Path\",\n        scope=[\"site\"],\n    )\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.SiteSyncSettings","title":"<code>SiteSyncSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Settings for synchronization process</p> Source code in <code>server/settings/settings.py</code> <pre><code>class SiteSyncSettings(BaseSettingsModel):\n    \"\"\"Settings for synchronization process\"\"\"\n    enabled: bool = Field(False)\n\n    config: GeneralSubmodel = Field(\n        default_factory=GeneralSubmodel,\n        title=\"Config\"\n    )\n\n    local_setting: LocalSubmodel = Field(\n        default_factory=LocalSubmodel,\n        title=\"Local setting\",\n        scope=[\"site\"],\n        description=\"This setting is only applicable for artist's site\",\n    )\n\n    sites: list[SitesSubmodel] = Field(\n        default_factory=list,\n        scope=[\"studio\", \"project\", \"site\"],\n        title=\"Sites\",\n    )\n\n    @validator(\"sites\")\n    def ensure_unique_names(cls, value):\n        \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.SiteSyncSettings.ensure_unique_names","title":"<code>ensure_unique_names(value)</code>","text":"<p>Ensure name fields within the lists have unique names.</p> Source code in <code>server/settings/settings.py</code> <pre><code>@validator(\"sites\")\ndef ensure_unique_names(cls, value):\n    \"\"\"Ensure name fields within the lists have unique names.\"\"\"\n    ensure_unique_names(value)\n    return value\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.SitesSubmodel","title":"<code>SitesSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Configured additional sites and properties for their providers</p> Source code in <code>server/settings/settings.py</code> <pre><code>class SitesSubmodel(BaseSettingsModel):\n    \"\"\"Configured additional sites and properties for their providers\"\"\"\n    _layout = \"expanded\"\n\n    alternative_sites: list[str] = Field(\n        default_factory=list,\n        title=\"Alternative sites\",\n        scope=[\"studio\", \"project\"],\n        description=\"Files on this site are/should physically present on these\"\n                    \" sites. Example sftp site exposes files from 'studio' \"\n                    \" site\"\n    )\n\n    provider: str = Field(\n        \"\",\n        title=\"Provider\",\n        description=\"Switch between providers\",\n        enum_resolver=lambda: provider_enum,\n        conditionalEnum=True\n    )\n\n    local_drive: LocalDriveSubmodel = Field(\n        default_factory=LocalDriveSubmodel,\n        scope=[\"studio\", \"project\", \"site\"]\n    )\n    gdrive: GoogleDriveSubmodel = Field(\n        default_factory=GoogleDriveSubmodel,\n        scope=[\"studio\", \"project\", \"site\"]\n    )\n    dropbox: DropboxSubmodel = Field(\n        default_factory=DropboxSubmodel,\n        scope=[\"studio\", \"project\", \"site\"]\n    )\n    sftp: SFTPSubmodel = Field(\n        default_factory=SFTPSubmodel,\n        scope=[\"studio\", \"project\", \"site\"]\n    )\n\n    name: str = Field(..., title=\"Site name\",\n                      scope=[\"studio\", \"project\", \"site\"])\n\n    @validator(\"name\")\n    def validate_name(cls, value):\n        \"\"\"Ensure name does not contain weird characters\"\"\"\n        return normalize_name(value)\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.SitesSubmodel.validate_name","title":"<code>validate_name(value)</code>","text":"<p>Ensure name does not contain weird characters</p> Source code in <code>server/settings/settings.py</code> <pre><code>@validator(\"name\")\ndef validate_name(cls, value):\n    \"\"\"Ensure name does not contain weird characters\"\"\"\n    return normalize_name(value)\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.defined_sited_enum_resolver","title":"<code>defined_sited_enum_resolver(addon, settings_variant='production', project_name=None)</code>  <code>async</code>","text":"<p>Provides list of names of configured syncable sites.</p> Source code in <code>server/settings/settings.py</code> <pre><code>async def defined_sited_enum_resolver(\n    addon: \"BaseServerAddon\",\n    settings_variant: str = \"production\",\n    project_name: str | None = None,\n) -&gt; list[str]:\n    \"\"\"Provides list of names of configured syncable sites.\"\"\"\n    if addon is None:\n        return []\n\n    if project_name:\n        settings = await addon.get_project_settings(project_name=project_name,\n                                                    variant=settings_variant)\n    else:\n        settings =  await addon.get_studio_settings(variant=settings_variant)\n\n    sites = [\"local\", \"studio\"]\n    for site_model in settings.sites:\n        sites.append(site_model.name)\n\n    return sites\n</code></pre>"},{"location":"autoapi/server/settings/settings.html#server.settings.settings.provider_resolver","title":"<code>provider_resolver()</code>","text":"<p>Return a list of value/label dicts for the enumerator.</p> <p>Returning a list of dicts is used to allow for a custom label to be displayed in the UI.</p> Source code in <code>server/settings/settings.py</code> <pre><code>def provider_resolver():\n    \"\"\"Return a list of value/label dicts for the enumerator.\n\n    Returning a list of dicts is used to allow for a custom label to be\n    displayed in the UI.\n    \"\"\"\n    provider_dict = {\n        \"gdrive\": \"Google Drive\",\n        \"local_drive\": \"Local Drive\",\n        \"dropbox\": \"Dropbox\",\n        \"sftp\": \"SFTP\"\n    }\n    return [{\"value\": f\"{key}\", \"label\": f\"{label}\"}\n            for key, label in provider_dict.items()]\n</code></pre>"},{"location":"autoapi/server/settings/providers/index.html","title":"providers","text":""},{"location":"autoapi/server/settings/providers/dropbox.html","title":"dropbox","text":""},{"location":"autoapi/server/settings/providers/dropbox.html#server.settings.providers.dropbox.DropboxSubmodel","title":"<code>DropboxSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Specific settings for Dropbox sites.</p> Source code in <code>server/settings/providers/dropbox.py</code> <pre><code>class DropboxSubmodel(BaseSettingsModel):\n    \"\"\"Specific settings for Dropbox sites.\"\"\"\n    _layout = \"expanded\"\n    token: str = Field(\n        \"\",\n        title=\"Access token\",\n        scope=[\"studio\", \"project\", \"site\"],\n        description=\"API access token\",\n    )\n\n    team_folder_name: str = Field(\n        \"\",\n        title=\"Team Folder Name\",\n        scope=[\"studio\", \"project\"],\n    )\n\n    acting_as_member: str = Field(\n        \"\",\n        title=\"Acting As Member\",\n        scope=[\"studio\", \"project\", \"site\"],\n    )\n\n    roots: str = Field(\n        \"\",\n        title=\"Roots\",\n        scope=[\"studio\", \"project\", \"site\"],\n        description=\"Root folder on Dropbox\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/providers/gdrive.html","title":"gdrive","text":""},{"location":"autoapi/server/settings/providers/gdrive.html#server.settings.providers.gdrive.GoogleDriveSubmodel","title":"<code>GoogleDriveSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Specific settings for Google Drive sites.</p> .json file for service account which must have access <p>to shared GDrive folder/drive</p> <p>root: root folder on GDrive, <code>/My Drive</code> prefix is required for classic     GDrive, shared disks don't need that</p> Source code in <code>server/settings/providers/gdrive.py</code> <pre><code>class GoogleDriveSubmodel(BaseSettingsModel):\n    \"\"\"Specific settings for Google Drive sites.\n\n    credentials_url: .json file for service account which must have access\n        to shared GDrive folder/drive\n    root: root folder on GDrive, `/My Drive` prefix is required for classic\n        GDrive, shared disks don't need that\n    \"\"\"\n    _layout = \"expanded\"\n    credentials_url: CredPathPerPlatform = Field(\n        title=\"Credentials url\",\n        scope=[\"studio\", \"project\", \"site\"],\n        default_factory=CredPathPerPlatform,\n        description=\"\"\"Path to credentials .json available on shared disk.\"\"\"\n    )\n\n    roots: str = Field(\n        \"\",\n        title=\"GDrive root folder\",\n        scope=[\"studio\", \"project\"],\n        description=\"Root folder on Google Drive\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/providers/local_drive.html","title":"local_drive","text":""},{"location":"autoapi/server/settings/providers/local_drive.html#server.settings.providers.local_drive.LocalDriveSubmodel","title":"<code>LocalDriveSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Specific settings for Local Drive sites.</p> Source code in <code>server/settings/providers/local_drive.py</code> <pre><code>class LocalDriveSubmodel(BaseSettingsModel):\n    \"\"\"Specific settings for Local Drive sites.\"\"\"\n    _layout = \"compact\"\n    roots: list[Root] = Field(\n        default=default_roots,\n        scope=[\"studio\", \"project\", \"site\"],\n        title=\"Roots\",\n        description=\"Setup root paths for the project\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/providers/sftp.html","title":"sftp","text":""},{"location":"autoapi/server/settings/providers/sftp.html#server.settings.providers.sftp.SFTPSubmodel","title":"<code>SFTPSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Specific settings for SFTP sites.</p> <p>Use sftp_pass OR sftp_key (and sftp_key_pass) to authenticate. sftp_key is public ssh part, expected .pem OpenSSH format, must be accessible on shared drive for all artists, use sftp_pass if no shared drive present on artist's machines.</p> Source code in <code>server/settings/providers/sftp.py</code> <pre><code>class SFTPSubmodel(BaseSettingsModel):\n    \"\"\"Specific settings for SFTP sites.\n\n    Use sftp_pass OR sftp_key (and sftp_key_pass) to authenticate.\n    sftp_key is public ssh part, expected .pem OpenSSH format, must be\n    accessible on shared drive for all artists, use sftp_pass if no shared\n    drive present on artist's machines.\n    \"\"\"\n    _layout = \"expanded\"\n    sftp_host: str = Field(\n        \"\",\n        title=\"SFTP host name\",\n        scope=[\"studio\", \"project\"],\n        description=\"Domain name or IP of sftp server\",\n    )\n\n    sftp_port: int = Field(\n        0,\n        title=\"SFTP port\",\n        scope=[\"studio\", \"project\"],\n    )\n\n    sftp_user: str = Field(\n        \"\",\n        title=\"SFTP user name\",\n        scope=[\"studio\", \"project\", \"site\"],\n    )\n\n    sftp_pass: str = Field(\n        \"\",\n        title=\"SFTP password\",\n        scope=[\"studio\", \"project\", \"site\"],\n        description=\"Use password or ssh key to authenticate\",\n    )\n\n    sftp_key: CredPathPerPlatform = Field(\n        title=\"SFTP key path\",\n        scope=[\"studio\", \"project\", \"site\"],\n        default_factory=CredPathPerPlatform,\n        description=\"Pah to certificate file\",\n    )\n\n    sftp_key_pass: str = Field(\n        \"\",\n        title=\"SFTP user ssh key password\",\n        scope=[\"studio\", \"project\", \"site\"],\n        description=\"Password for ssh key\",\n    )\n\n    roots: str = Field(\n        \"\",\n        title=\"SFTP root folder\",\n        scope=[\"studio\", \"project\"],\n        description=\"Root folder on SFTP\",\n    )\n</code></pre>"}]}